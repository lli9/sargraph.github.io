'use strict';
(function (root, factory) {
    if ("object" == typeof exports && "undefined" != typeof module) {
        module.exports = factory();
    } else {
        if ("function" == typeof define && define.amd) {
            define(factory);
        } else {
            root.Popper = factory();
        }
    }
})(this, function () {
    /**
     * @param {boolean} obj
     * @return {?}
     */
    function isFunction(obj) {
        return obj && "[object Function]" === {}.toString.call(obj);
    }
    /**
     * @param {!Object} node
     * @param {string} name
     * @return {?}
     */
    function getComputedStyle(node, name) {
        if (1 !== node.nodeType) {
            return [];
        }
        var win = node.ownerDocument.defaultView;
        var params = win.getComputedStyle(node, null);
        return name ? params[name] : params;
    }
    /**
     * @param {!Object} node
     * @return {?}
     */
    function getParentNode(node) {
        return "HTML" === node.nodeName ? node : node.parentNode || node.host;
    }
    /**
     * @param {!Object} element
     * @return {?}
     */
    function getScrollParent(element) {
        if (!element) {
            return document.body;
        }
        switch (element.nodeName) {
            case "HTML":
            case "BODY":
                return element.ownerDocument.body;
            case "#document":
                return element.body;
        }
        var style = getComputedStyle(element);
        var overflow = style.overflow;
        var overflowX = style.overflowX;
        var overflowY = style.overflowY;
        return /(auto|scroll|overlay)/.test(overflow + overflowY + overflowX) ? element : getScrollParent(getParentNode(element));
    }
    /**
     * @param {!Object} s
     * @return {?}
     */
    function compare(s) {
        return s && s.referenceNode ? s.referenceNode : s;
    }
    /**
     * @param {number} string
     * @return {?}
     */
    function isIE10$1(string) {
        return 11 === string ? value : 10 === string ? text : value || text;
    }
    /**
     * @param {!Element} node
     * @return {?}
     */
    function getOffsetParent(node) {
        if (!node) {
            return document.documentElement;
        }
        /** @type {(HTMLBodyElement|null)} */
        var text = isIE10$1(10) ? document.body : null;
        var element = node.offsetParent || null;
        for (; element === text && node.nextElementSibling;) {
            element = (node = node.nextElementSibling).offsetParent;
        }
        var parent = element && element.nodeName;
        return parent && "BODY" !== parent && "HTML" !== parent ? -1 !== ["TH", "TD", "TABLE"].indexOf(element.nodeName) && "static" === getComputedStyle(element, "position") ? getOffsetParent(element) : element : node ? node.ownerDocument.documentElement : document.documentElement;
    }
    /**
     * @param {!Node} element
     * @return {?}
     */
    function isOffsetContainer(element) {
        var nodeName = element.nodeName;
        return "BODY" !== nodeName && ("HTML" === nodeName || getOffsetParent(element.firstElementChild) === element);
    }
    /**
     * @param {!Element} node
     * @return {?}
     */
    function getRoot(node) {
        return null === node.parentNode ? node : getRoot(node.parentNode);
    }
    /**
     * @param {!Element} element1
     * @param {!Element} element2
     * @return {?}
     */
    function findCommonOffsetParent(element1, element2) {
        if (!element1 || !element1.nodeType || !element2 || !element2.nodeType) {
            return document.documentElement;
        }
        /** @type {number} */
        var order = element1.compareDocumentPosition(element2) & Node.DOCUMENT_POSITION_FOLLOWING;
        var start = order ? element1 : element2;
        var end = order ? element2 : element1;
        /** @type {(Range|null)} */
        var range = document.createRange();
        range.setStart(start, 0);
        range.setEnd(end, 0);
        /** @type {(Node|null)} */
        var commonAncestorContainer = range.commonAncestorContainer;
        if (element1 !== commonAncestorContainer && element2 !== commonAncestorContainer || start.contains(end)) {
            return isOffsetContainer(commonAncestorContainer) ? commonAncestorContainer : getOffsetParent(commonAncestorContainer);
        }
        var element1root = getRoot(element1);
        return element1root.host ? findCommonOffsetParent(element1root.host, element2) : findCommonOffsetParent(element1, getRoot(element2).host);
    }
    /**
     * @param {!Node} e
     * @return {?}
     */
    function getScroll(e) {
        var v = 1 < arguments.length && void 0 !== arguments[1] ? arguments[1] : "top";
        /** @type {string} */
        var scroll = "top" === v ? "scrollTop" : "scrollLeft";
        var node = e.nodeName;
        if ("BODY" === node || "HTML" === node) {
            var html = e.ownerDocument.documentElement;
            var el = e.ownerDocument.scrollingElement || html;
            return el[scroll];
        }
        return e[scroll];
    }
    /**
     * @param {!ClientRect} rect
     * @param {!Node} element
     * @return {?}
     */
    function includeScroll(rect, element) {
        var isOrChild = 2 < arguments.length && void 0 !== arguments[2] && arguments[2];
        var scrollTop = getScroll(element, "top");
        var scrollLeft = getScroll(element, "left");
        /** @type {number} */
        var modifier = isOrChild ? -1 : 1;
        return rect.top += scrollTop * modifier, rect.bottom += scrollTop * modifier, rect.left += scrollLeft * modifier, rect.right += scrollLeft * modifier, rect;
    }
    /**
     * @param {!Object} styles
     * @param {string} axis
     * @return {?}
     */
    function getBordersSize(styles, axis) {
        /** @type {string} */
        var dirA = "x" === axis ? "Left" : "Top";
        /** @type {string} */
        var dirB = "Left" == dirA ? "Right" : "Bottom";
        return parseFloat(styles["border" + dirA + "Width"], 10) + parseFloat(styles["border" + dirB + "Width"], 10);
    }
    /**
     * @param {string} name
     * @param {!Object} doc
     * @param {!Object} body
     * @param {!Object} computedStyle
     * @return {?}
     */
    function getSize(name, doc, body, computedStyle) {
        return max(doc["offset" + name], doc["scroll" + name], body["client" + name], body["offset" + name], body["scroll" + name], isIE10$1(10) ? parseInt(body["offset" + name]) + parseInt(computedStyle["margin" + ("Height" === name ? "Top" : "Left")]) + parseInt(computedStyle["margin" + ("Height" === name ? "Bottom" : "Right")]) : 0);
    }
    /**
     * @param {!Document} doc
     * @return {?}
     */
    function getWindowSizes(doc) {
        var body = doc.body;
        var html = doc.documentElement;
        var computedStyle = isIE10$1(10) && getComputedStyle(html);
        return {
            height: getSize("Height", body, html, computedStyle),
            width: getSize("Width", body, html, computedStyle)
        };
    }
    /**
     * @param {!Object} element
     * @return {?}
     */
    function getClientRect(element) {
        return _extends({}, element, {
            right: element.left + element.width,
            bottom: element.top + element.height
        });
    }
    /**
     * @param {!Element} element
     * @return {?}
     */
    function getBoundingClientRect(element) {
        var rect = {};
        try {
            if (isIE10$1(10)) {
                rect = element.getBoundingClientRect();
                var scrollTop = getScroll(element, "top");
                var scrollLeft = getScroll(element, "left");
                rect.top += scrollTop;
                rect.left += scrollLeft;
                rect.bottom += scrollTop;
                rect.right += scrollLeft;
            } else {
                rect = element.getBoundingClientRect();
            }
        } catch (t) {
        }
        var result = {
            left: rect.left,
            top: rect.top,
            width: rect.right - rect.left,
            height: rect.bottom - rect.top
        };
        var sizes = "HTML" === element.nodeName ? getWindowSizes(element.ownerDocument) : {};
        var width = sizes.width || element.clientWidth || result.width;
        var height = sizes.height || element.clientHeight || result.height;
        /** @type {number} */
        var horizScrollbar = element.offsetWidth - width;
        /** @type {number} */
        var vertScrollbar = element.offsetHeight - height;
        if (horizScrollbar || vertScrollbar) {
            var styles = getComputedStyle(element);
            /** @type {number} */
            horizScrollbar = horizScrollbar - getBordersSize(styles, "x");
            /** @type {number} */
            vertScrollbar = vertScrollbar - getBordersSize(styles, "y");
            result.width -= horizScrollbar;
            result.height -= vertScrollbar;
        }
        return getClientRect(result);
    }
    /**
     * @param {!HTMLDocument} children
     * @param {!Element} parent
     * @return {?}
     */
    function getOffsetRectRelativeToArbitraryNode(children, parent) {
        var reverseIsSingle = 2 < arguments.length && void 0 !== arguments[2] && arguments[2];
        var istruthy = isIE10$1(10);
        /** @type {boolean} */
        var reverseValue = "HTML" === parent.nodeName;
        var childrenRect = getBoundingClientRect(children);
        var parentRect = getBoundingClientRect(parent);
        var node = getScrollParent(children);
        var styles = getComputedStyle(parent);
        /** @type {number} */
        var borderTopWidth = parseFloat(styles.borderTopWidth, 10);
        /** @type {number} */
        var borderLeftWidth = parseFloat(styles.borderLeftWidth, 10);
        if (reverseIsSingle && reverseValue) {
            /** @type {number} */
            parentRect.top = max(parentRect.top, 0);
            /** @type {number} */
            parentRect.left = max(parentRect.left, 0);
        }
        var offsets = getClientRect({
            top: childrenRect.top - parentRect.top - borderTopWidth,
            left: childrenRect.left - parentRect.left - borderLeftWidth,
            width: childrenRect.width,
            height: childrenRect.height
        });
        if (offsets.marginTop = 0, offsets.marginLeft = 0, !istruthy && reverseValue) {
            /** @type {number} */
            var marginTop = parseFloat(styles.marginTop, 10);
            /** @type {number} */
            var marginLeft = parseFloat(styles.marginLeft, 10);
            offsets.top -= borderTopWidth - marginTop;
            offsets.bottom -= borderTopWidth - marginTop;
            offsets.left -= borderLeftWidth - marginLeft;
            offsets.right -= borderLeftWidth - marginLeft;
            /** @type {number} */
            offsets.marginTop = marginTop;
            /** @type {number} */
            offsets.marginLeft = marginLeft;
        }
        return (istruthy && !reverseIsSingle ? parent.contains(node) : parent === node && "BODY" !== node.nodeName) && (offsets = includeScroll(offsets, parent)), offsets;
    }
    /**
     * @param {!Document} element
     * @return {?}
     */
    function getViewportOffsetRectRelativeToArtbitraryNode(element) {
        var $scrollContainer = 1 < arguments.length && void 0 !== arguments[1] && arguments[1];
        var html = element.ownerDocument.documentElement;
        var relativeOffset = getOffsetRectRelativeToArbitraryNode(element, html);
        /** @type {number} */
        var fullWidth = max(html.clientWidth, window.innerWidth || 0);
        /** @type {number} */
        var h = max(html.clientHeight, window.innerHeight || 0);
        var scrollTop = $scrollContainer ? 0 : getScroll(html);
        var scrollLeft = $scrollContainer ? 0 : getScroll(html, "left");
        var elementRect = {
            top: scrollTop - relativeOffset.top + relativeOffset.marginTop,
            left: scrollLeft - relativeOffset.left + relativeOffset.marginLeft,
            width: fullWidth,
            height: h
        };
        return getClientRect(elementRect);
    }
    /**
     * @param {!Object} element
     * @return {?}
     */
    function isFixed(element) {
        var nodeName = element.nodeName;
        if ("BODY" === nodeName || "HTML" === nodeName) {
            return false;
        }
        if ("fixed" === getComputedStyle(element, "position")) {
            return true;
        }
        var offsetParent = getParentNode(element);
        return !!offsetParent && isFixed(offsetParent);
    }
    /**
     * @param {!Element} target
     * @return {?}
     */
    function get(target) {
        if (!target || !target.parentElement || isIE10$1()) {
            return document.documentElement;
        }
        var element = target.parentElement;
        for (; element && "none" === getComputedStyle(element, "transform");) {
            element = element.parentElement;
        }
        return element || document.documentElement;
    }
    /**
     * @param {!Element} e
     * @param {!Object} element
     * @param {!Function} padding
     * @param {!Object} boundariesElement
     * @return {?}
     */
    function getBoundaries(e, element, padding, boundariesElement) {
        var deep = 4 < arguments.length && void 0 !== arguments[4] && arguments[4];
        var boundaries = {
            top: 0,
            left: 0
        };
        var offsetParent = deep ? get(e) : findCommonOffsetParent(e, compare(element));
        if ("viewport" === boundariesElement) {
            boundaries = getViewportOffsetRectRelativeToArtbitraryNode(offsetParent, deep);
        } else {
            var boundariesNode;
            if ("scrollParent" === boundariesElement) {
                boundariesNode = getScrollParent(getParentNode(element));
                if ("BODY" === boundariesNode.nodeName) {
                    boundariesNode = e.ownerDocument.documentElement;
                }
            } else {
                if ("window" === boundariesElement) {
                    boundariesNode = e.ownerDocument.documentElement;
                } else {
                    /** @type {!Object} */
                    boundariesNode = boundariesElement;
                }
            }
            var offsets = getOffsetRectRelativeToArbitraryNode(boundariesNode, offsetParent, deep);
            if ("HTML" === boundariesNode.nodeName && !isFixed(offsetParent)) {
                var _entity$getData = getWindowSizes(e.ownerDocument);
                var height = _entity$getData.height;
                var width = _entity$getData.width;
                boundaries.top += offsets.top - offsets.marginTop;
                boundaries.bottom = height + offsets.top;
                boundaries.left += offsets.left - offsets.marginLeft;
                boundaries.right = width + offsets.left;
            } else {
                boundaries = offsets;
            }
        }
        padding = padding || 0;
        /** @type {boolean} */
        var hasDefault = "number" == typeof padding;
        return boundaries.left += hasDefault ? padding : padding.left || 0, boundaries.top += hasDefault ? padding : padding.top || 0, boundaries.right -= hasDefault ? padding : padding.right || 0, boundaries.bottom -= hasDefault ? padding : padding.bottom || 0, boundaries;
    }
    /**
     * @param {!Object} location
     * @return {?}
     */
    function getArea(location) {
        var popupOuterWidth = location.width;
        var popupOuterHeight = location.height;
        return popupOuterWidth * popupOuterHeight;
    }
    /**
     * @param {string} placement
     * @param {!ClientRect} refRect
     * @param {!Element} popper
     * @param {!Object} reference
     * @param {!Object} boundariesElement
     * @return {?}
     */
    function computeAutoPlacement(placement, refRect, popper, reference, boundariesElement) {
        var padding = 5 < arguments.length && void 0 !== arguments[5] ? arguments[5] : 0;
        if (-1 === placement.indexOf("auto")) {
            return placement;
        }
        var boundaries = getBoundaries(popper, reference, padding, boundariesElement);
        var rects = {
            top: {
                width: boundaries.width,
                height: refRect.top - boundaries.top
            },
            right: {
                width: boundaries.right - refRect.right,
                height: boundaries.height
            },
            bottom: {
                width: boundaries.width,
                height: boundaries.bottom - refRect.bottom
            },
            left: {
                width: refRect.left - boundaries.left,
                height: boundaries.height
            }
        };
        /** @type {!Array<?>} */
        var storedKeys = Object.keys(rects).map(function (i) {
            return _extends({
                key: i
            }, rects[i], {
                area: getArea(rects[i])
            });
        }).sort(function (a, b) {
            return b.area - a.area;
        });
        /** @type {!Array<?>} */
        var keys_and_values = storedKeys.filter(function (bef) {
            var width = bef.width;
            var height = bef.height;
            return width >= popper.clientWidth && height >= popper.clientHeight;
        });
        var menuentry = 0 < keys_and_values.length ? keys_and_values[0].key : storedKeys[0].key;
        var id = placement.split("-")[1];
        return menuentry + (id ? "-" + id : "");
    }
    /**
     * @param {?} state
     * @param {!Element} popper
     * @param {!HTMLDocument} reference
     * @return {?}
     */
    function getReferenceOffsets(state, popper, reference) {
        var value = 3 < arguments.length && void 0 !== arguments[3] ? arguments[3] : null;
        var ctor = value ? get(popper) : findCommonOffsetParent(popper, compare(reference));
        return getOffsetRectRelativeToArbitraryNode(reference, ctor, value);
    }
    /**
     * @param {!Object} element
     * @return {?}
     */
    function init(element) {
        var window = element.ownerDocument.defaultView;
        var size = window.getComputedStyle(element);
        /** @type {number} */
        var x = parseFloat(size.marginTop || 0) + parseFloat(size.marginBottom || 0);
        /** @type {number} */
        var y = parseFloat(size.marginLeft || 0) + parseFloat(size.marginRight || 0);
        var result = {
            width: element.offsetWidth + y,
            height: element.offsetHeight + x
        };
        return result;
    }
    /**
     * @param {string} placement
     * @return {?}
     */
    function getOppositePlacement(placement) {
        var gap = {
            left: "right",
            right: "left",
            bottom: "top",
            top: "bottom"
        };
        return placement.replace(/left|right|bottom|top/g, function (attempts) {
            return gap[attempts];
        });
    }
    /**
     * @param {undefined} popper
     * @param {undefined} referenceOffsets
     * @param {string} placement
     * @return {?}
     */
    function getPopperOffsets(popper, referenceOffsets, placement) {
        placement = placement.split("-")[0];
        var popperRect = init(popper);
        var popperOffsets = {
            width: popperRect.width,
            height: popperRect.height
        };
        /** @type {boolean} */
        var isHoriz = -1 !== ["right", "left"].indexOf(placement);
        /** @type {string} */
        var mainSide = isHoriz ? "top" : "left";
        /** @type {string} */
        var secondarySide = isHoriz ? "left" : "top";
        /** @type {string} */
        var measurement = isHoriz ? "height" : "width";
        /** @type {string} */
        var secondaryMeasurement = isHoriz ? "width" : "height";
        return popperOffsets[mainSide] = referenceOffsets[mainSide] + referenceOffsets[measurement] / 2 - popperRect[measurement] / 2, popperOffsets[secondarySide] = placement === secondarySide ? referenceOffsets[secondarySide] - popperRect[secondaryMeasurement] : referenceOffsets[getOppositePlacement(secondarySide)], popperOffsets;
    }
    /**
     * @param {!Object} arr
     * @param {!Function} check
     * @return {?}
     */
    function find$1(arr, check) {
        return Array.prototype.find ? arr.find(check) : arr.filter(check)[0];
    }
    /**
     * @param {?} list
     * @param {string} name
     * @param {?} value
     * @return {?}
     */
    function findIndex(list, name, value) {
        if (Array.prototype.findIndex) {
            return list.findIndex(function (enm) {
                return enm[name] === value;
            });
        }
        var match = find$1(list, function (enm) {
            return enm[name] === value;
        });
        return list.indexOf(match);
    }
    /**
     * @param {string} modifiers
     * @param {!Object} data
     * @param {?} ends
     * @return {?}
     */
    function runModifiers(modifiers, data, ends) {
        var modifiersToRun = void 0 === ends ? modifiers : modifiers.slice(0, findIndex(modifiers, "name", ends));
        return modifiersToRun.forEach(function (opts) {
            if (opts["function"]) {
                console.warn("`modifier.function` is deprecated, use `modifier.fn`!");
            }
            var fn = opts["function"] || opts.fn;
            if (opts.enabled && isFunction(fn)) {
                data.offsets.popper = getClientRect(data.offsets.popper);
                data.offsets.reference = getClientRect(data.offsets.reference);
                data = fn(data, opts);
            }
        }), data;
    }
    /**
     * @return {undefined}
     */
    function update() {
        if (!this.state.isDestroyed) {
            var data = {
                instance: this,
                styles: {},
                arrowStyles: {},
                attributes: {},
                flipped: false,
                offsets: {}
            };
            data.offsets.reference = getReferenceOffsets(this.state, this.popper, this.reference, this.options.positionFixed);
            data.placement = computeAutoPlacement(this.options.placement, data.offsets.reference, this.popper, this.reference, this.options.modifiers.flip.boundariesElement, this.options.modifiers.flip.padding);
            data.originalPlacement = data.placement;
            data.positionFixed = this.options.positionFixed;
            data.offsets.popper = getPopperOffsets(this.popper, data.offsets.reference, data.placement);
            /** @type {string} */
            data.offsets.popper.position = this.options.positionFixed ? "fixed" : "absolute";
            data = runModifiers(this.modifiers, data);
            if (this.state.isCreated) {
                this.options.onUpdate(data);
            } else {
                /** @type {boolean} */
                this.state.isCreated = true;
                this.options.onCreate(data);
            }
        }
    }
    /**
     * @param {!Array} modifiers
     * @param {string} modifierName
     * @return {?}
     */
    function isModifierEnabled(modifiers, modifierName) {
        return modifiers.some(function (layer) {
            var name = layer.name;
            var enabled = layer.enabled;
            return enabled && name === modifierName;
        });
    }
    /**
     * @param {string} property
     * @return {?}
     */
    function getSupportedPropertyName(property) {
        /** @type {!Array} */
        var prefixes = [false, "ms", "Webkit", "Moz", "O"];
        var id = property.charAt(0).toUpperCase() + property.slice(1);
        /** @type {number} */
        var i = 0;
        for (; i < prefixes.length; i++) {
            var prefix = prefixes[i];
            var name = prefix ? "" + prefix + id : property;
            if ("undefined" != typeof document.body.style[name]) {
                return name;
            }
        }
        return null;
    }
    /**
     * @return {?}
     */
    function destroy() {
        return this.state.isDestroyed = true, isModifierEnabled(this.modifiers, "applyStyle") && (this.popper.removeAttribute("x-placement"), this.popper.style.position = "", this.popper.style.top = "", this.popper.style.left = "", this.popper.style.right = "", this.popper.style.bottom = "", this.popper.style.willChange = "", this.popper.style[getSupportedPropertyName("transform")] = ""), this.disableEventListeners(), this.options.removeOnDestroy && this.popper.parentNode.removeChild(this.popper), this;
    }
    /**
     * @param {!Object} o
     * @return {?}
     */
    function $(o) {
        var node = o.ownerDocument;
        return node ? node.defaultView : window;
    }
    /**
     * @param {!Object} node
     * @param {string} event
     * @param {?} callback
     * @param {!Array} scrollParents
     * @return {undefined}
     */
    function attachToScrollParents(node, event, callback, scrollParents) {
        /** @type {boolean} */
        var list = "BODY" === node.nodeName;
        var target = list ? node.ownerDocument.defaultView : node;
        target.addEventListener(event, callback, {
            passive: true
        });
        if (!list) {
            attachToScrollParents(getScrollParent(target.parentNode), event, callback, scrollParents);
        }
        scrollParents.push(target);
    }
    /**
     * @param {undefined} reference
     * @param {?} options
     * @param {?} state
     * @param {!AudioNode} updateBound
     * @return {?}
     */
    function setupEventListeners(reference, options, state, updateBound) {
        /** @type {!AudioNode} */
        state.updateBound = updateBound;
        $(reference).addEventListener("resize", state.updateBound, {
            passive: true
        });
        var scrollElement = getScrollParent(reference);
        return attachToScrollParents(scrollElement, "scroll", state.updateBound, state.scrollParents), state.scrollElement = scrollElement, state.eventsEnabled = true, state;
    }
    /**
     * @return {undefined}
     */
    function enableEventListeners() {
        if (!this.state.eventsEnabled) {
            this.state = setupEventListeners(this.reference, this.options, this.state, this.scheduleUpdate);
        }
    }
    /**
     * @param {undefined} element
     * @param {?} state
     * @return {?}
     */
    function removeEventListeners(element, state) {
        return $(element).removeEventListener("resize", state.updateBound), state.scrollParents.forEach(function (target) {
            target.removeEventListener("scroll", state.updateBound);
        }), state.updateBound = null, state.scrollParents = [], state.scrollElement = null, state.eventsEnabled = false, state;
    }
    /**
     * @return {undefined}
     */
    function disableEventListeners() {
        if (this.state.eventsEnabled) {
            cancelAnimationFrame(this.scheduleUpdate);
            this.state = removeEventListeners(this.reference, this.state);
        }
    }
    /**
     * @param {string} value
     * @return {?}
     */
    function isNumeric(value) {
        return "" !== value && !isNaN(parseFloat(value)) && isFinite(value);
    }
    /**
     * @param {!Element} element
     * @param {!Object} keys
     * @return {undefined}
     */
    function setStyles(element, keys) {
        Object.keys(keys).forEach(function (i) {
            /** @type {string} */
            var value = "";
            if (-1 !== ["width", "height", "top", "right", "bottom", "left"].indexOf(i) && isNumeric(keys[i])) {
                /** @type {string} */
                value = "px";
            }
            element.style[i] = keys[i] + value;
        });
    }
    /**
     * @param {!Element} el
     * @param {!Object} attrs
     * @return {undefined}
     */
    function setAttributes(el, attrs) {
        Object.keys(attrs).forEach(function (att) {
            var val = attrs[att];
            if (false === val) {
                el.removeAttribute(att);
            } else {
                el.setAttribute(att, attrs[att]);
            }
        });
    }
    /**
     * @param {!Object} data
     * @param {boolean} t
     * @return {?}
     */
    function render(data, t) {
        var _data$offsets = data.offsets;
        var changes = _data$offsets.popper;
        var reference = _data$offsets.reference;
        /** @type {function(?): number} */
        var n = round;
        /**
         * @param {number} a
         * @return {?}
         */
        var color = function (a) {
            return a;
        };
        /** @type {number} */
        var square = n(reference.width);
        /** @type {number} */
        var target = n(changes.width);
        /** @type {boolean} */
        var a = -1 !== ["left", "right"].indexOf(data.placement);
        /** @type {boolean} */
        var b = -1 !== data.placement.indexOf("-");
        /** @type {!Function} */
        var f = t ? a || b || square % 2 == target % 2 ? n : $ceil : color;
        /** @type {!Function} */
        var max = t ? n : color;
        return {
            left: f(1 == square % 2 && 1 == target % 2 && !b && t ? changes.left - 1 : changes.left),
            top: max(changes.top),
            bottom: max(changes.bottom),
            right: f(changes.right)
        };
    }
    /**
     * @param {!Object} modifiers
     * @param {string} requestingName
     * @param {string} requestedName
     * @return {?}
     */
    function isModifierRequired(modifiers, requestingName, requestedName) {
        var requesting = find$1(modifiers, function (_ref33) {
            var name = _ref33.name;
            return name === requestingName;
        });
        var isRequired = !!requesting && modifiers.some(function (modifier) {
            return modifier.name === requestedName && modifier.enabled && modifier.order < requesting.order;
        });
        if (!isRequired) {
            /** @type {string} */
            var r = "`" + requestingName + "`";
            console.warn("`" + requestedName + "`" + " modifier is required by " + r + " modifier in order to work, be sure to include it before " + r + "!");
        }
        return isRequired;
    }
    /**
     * @param {string} end
     * @return {?}
     */
    function getEndDate(end) {
        return "end" === end ? "start" : "start" === end ? "end" : end;
    }
    /**
     * @param {?} val
     * @return {?}
     */
    function clockwise(val) {
        var hasExternalScreen = 1 < arguments.length && void 0 !== arguments[1] && arguments[1];
        /** @type {number} */
        var index = s.indexOf(val);
        /** @type {!Array<?>} */
        var y = s.slice(index + 1).concat(s.slice(0, index));
        return hasExternalScreen ? y.reverse() : y;
    }
    /**
     * @param {string} str
     * @param {string} measurement
     * @param {number} popperOffsets
     * @param {number} referenceOffsets
     * @return {?}
     */
    function toValue(str, measurement, popperOffsets, referenceOffsets) {
        var imageSz = str.match(/((?:\-|\+)?\d*\.?\d*)(.*)/);
        /** @type {number} */
        var new_width = +imageSz[1];
        var w = imageSz[2];
        if (!new_width) {
            return str;
        }
        if (0 === w.indexOf("%")) {
            var element;
            switch (w) {
                case "%p":
                    /** @type {number} */
                    element = popperOffsets;
                    break;
                case "%":
                case "%r":
                default:
                    /** @type {number} */
                    element = referenceOffsets;
            }
            var rect = getClientRect(element);
            return rect[measurement] / 100 * new_width;
        }
        if ("vh" === w || "vw" === w) {
            var img_original_height;
            return img_original_height = "vh" === w ? max(document.documentElement.clientHeight, window.innerHeight || 0) : max(document.documentElement.clientWidth, window.innerWidth || 0), img_original_height / 100 * new_width;
        }
        return new_width;
    }
    /**
     * @param {string} offset
     * @param {undefined} popperOffsets
     * @param {undefined} referenceOffsets
     * @param {?} basePlacement
     * @return {?}
     */
    function parseOffset(offset, popperOffsets, referenceOffsets, basePlacement) {
        /** @type {!Array} */
        var ssq = [0, 0];
        /** @type {boolean} */
        var expanded = -1 !== ["right", "left"].indexOf(basePlacement);
        var fragments = offset.split(/(\+|\-)/).map(function (commentToCheck) {
            return commentToCheck.trim();
        });
        var divider = fragments.indexOf(find$1(fragments, function (YoutubeService) {
            return -1 !== YoutubeService.search(/,|\s/);
        }));
        if (fragments[divider] && -1 === fragments[divider].indexOf(",")) {
            console.warn("Offsets separated by white space(s) are deprecated, use a comma (,) instead.");
        }
        /** @type {!RegExp} */
        var parameterv = /\s*,\s*|\s+/;
        /** @type {!Array} */
        var MSG_TYPES = -1 === divider ? [fragments] : [fragments.slice(0, divider).concat([fragments[divider].split(parameterv)[0]]), [fragments[divider].split(parameterv)[1]].concat(fragments.slice(divider + 1))];
        return MSG_TYPES = MSG_TYPES.map(function (metapakModulesSequence, summaryElement) {
            /** @type {string} */
            var measurement = (1 === summaryElement ? !expanded : expanded) ? "height" : "width";
            /** @type {boolean} */
            var after = false;
            return metapakModulesSequence.reduce(function (arr, node) {
                return "" === arr[arr.length - 1] && -1 !== ["+", "-"].indexOf(node) ? (arr[arr.length - 1] = node, after = true, arr) : after ? (arr[arr.length - 1] += node, after = false, arr) : arr.concat(node);
            }, []).map(function (data) {
                return toValue(data, measurement, popperOffsets, referenceOffsets);
            });
        }), MSG_TYPES.forEach(function (groups, idx) {
            groups.forEach(function (v, i) {
                if (isNumeric(v)) {
                    ssq[idx] += v * ("-" === groups[i - 1] ? -1 : 1);
                }
            });
        }), ssq;
    }
    /**
     * @param {!Object} data
     * @param {!Object} options
     * @return {?}
     */
    function offset(data, options) {
        var offsets;
        var offset = options.offset;
        var placement = data.placement;
        var _data$offsets = data.offsets;
        var popper = _data$offsets.popper;
        var reference = _data$offsets.reference;
        var align = placement.split("-")[0];
        return offsets = isNumeric(+offset) ? [+offset, 0] : parseOffset(offset, popper, reference, align), "left" === align ? (popper.top += offsets[0], popper.left -= offsets[1]) : "right" === align ? (popper.top += offsets[0], popper.left += offsets[1]) : "top" === align ? (popper.left += offsets[0], popper.top -= offsets[1]) : "bottom" === align && (popper.left += offsets[0], popper.top += offsets[1]), data.popper = popper, data;
    }
    /** @type {function(...?): number} */
    var min = Math.min;
    /** @type {function(?): number} */
    var $ceil = Math.floor;
    /** @type {function(?): number} */
    var round = Math.round;
    /** @type {function(...?): number} */
    var max = Math.max;
    /** @type {boolean} */
    var context = "undefined" != typeof window && "undefined" != typeof document && "undefined" != typeof navigator;
    var ngiScroll_timeout = function () {
        /** @type {!Array} */
        var clues = ["Edge", "Trident", "Firefox"];
        /** @type {number} */
        var i = 0;
        for (; i < clues.length; i = i + 1) {
            if (context && 0 <= navigator.userAgent.indexOf(clues[i])) {
                return 1;
            }
        }
        return 0;
    }();
    var precision = context && window.Promise;
    /** @type {function(?): ?} */
    var debounce = precision ? function (saveNotifs) {
        /** @type {boolean} */
        var t = false;
        return function () {
            if (!t) {
                /** @type {boolean} */
                t = true;
                window.Promise.resolve().then(function () {
                    /** @type {boolean} */
                    t = false;
                    saveNotifs();
                });
            }
        };
    } : function (saveNotifs) {
        /** @type {boolean} */
        var t = false;
        return function () {
            if (!t) {
                /** @type {boolean} */
                t = true;
                setTimeout(function () {
                    /** @type {boolean} */
                    t = false;
                    saveNotifs();
                }, ngiScroll_timeout);
            }
        };
    };
    /** @type {boolean} */
    var value = context && !!(window.MSInputMethodContext && document.documentMode);
    /** @type {boolean} */
    var text = context && /MSIE 10/.test(navigator.userAgent);
    /**
     * @param {!AudioNode} instance
     * @param {!Function} Constructor
     * @return {undefined}
     */
    var classCallCheck = function (instance, Constructor) {
        if (!(instance instanceof Constructor)) {
            throw new TypeError("Cannot call a class as a function");
        }
    };
    var createClass = function () {
        /**
         * @param {!Function} d
         * @param {string} props
         * @return {undefined}
         */
        function e(d, props) {
            var descriptor;
            /** @type {number} */
            var i = 0;
            for (; i < props.length; i++) {
                descriptor = props[i];
                descriptor.enumerable = descriptor.enumerable || false;
                /** @type {boolean} */
                descriptor.configurable = true;
                if ("value" in descriptor) {
                    /** @type {boolean} */
                    descriptor.writable = true;
                }
                Object.defineProperty(d, descriptor.key, descriptor);
            }
        }
        return function (t, n, a) {
            return n && e(t.prototype, n), a && e(t, a), t;
        };
    }();
    /**
     * @param {!Object} obj
     * @param {string} key
     * @param {?} value
     * @return {?}
     */
    var defineProperty = function (obj, key, value) {
        return key in obj ? Object.defineProperty(obj, key, {
            value: value,
            enumerable: true,
            configurable: true,
            writable: true
        }) : obj[key] = value, obj;
    };
    /** @type {function(!Object, ...(Object|null)): !Object} */
    var _extends = Object.assign || function (headers) {
        var obj;
        /** @type {number} */
        var arg = 1;
        for (; arg < arguments.length; arg++) {
            var key;
            for (key in obj = arguments[arg], obj) {
                if (Object.prototype.hasOwnProperty.call(obj, key)) {
                    headers[key] = obj[key];
                }
            }
        }
        return headers;
    };
    /** @type {boolean} */
    var typeName = context && /Firefox/i.test(navigator.userAgent);
    /** @type {!Array} */
    var placements = ["auto-start", "auto", "auto-end", "top-start", "top", "top-end", "right-start", "right", "right-end", "bottom-end", "bottom", "bottom-start", "left-end", "left", "left-start"];
    /** @type {!Array<?>} */
    var s = placements.slice(3);
    var BEHAVIORS = {
        FLIP: "flip",
        CLOCKWISE: "clockwise",
        COUNTERCLOCKWISE: "counterclockwise"
    };
    var Popper = function () {
        /**
         * @param {!Object} elem
         * @param {!Object} options
         * @return {undefined}
         */
        function Popper(elem, options) {
            var _this = this;
            var opts = 2 < arguments.length && void 0 !== arguments[2] ? arguments[2] : {};
            classCallCheck(this, Popper);
            /**
             * @return {?}
             */
            this.scheduleUpdate = function () {
                return requestAnimationFrame(_this.update);
            };
            this.update = debounce(this.update.bind(this));
            /** @type {!Object} */
            this.options = _extends({}, Popper.Defaults, opts);
            this.state = {
                isDestroyed: false,
                isCreated: false,
                scrollParents: []
            };
            this.reference = elem && elem.jquery ? elem[0] : elem;
            this.popper = options && options.jquery ? options[0] : options;
            this.options.modifiers = {};
            Object.keys(_extends({}, Popper.Defaults.modifiers, opts.modifiers)).forEach(function (name) {
                /** @type {!Object} */
                _this.options.modifiers[name] = _extends({}, Popper.Defaults.modifiers[name] || {}, opts.modifiers ? opts.modifiers[name] : {});
            });
            /** @type {!Array<?>} */
            this.modifiers = Object.keys(this.options.modifiers).map(function (name) {
                return _extends({
                    name: name
                }, _this.options.modifiers[name]);
            }).sort(function (a, b) {
                return a.order - b.order;
            });
            this.modifiers.forEach(function (modifierOptions) {
                if (modifierOptions.enabled && isFunction(modifierOptions.onLoad)) {
                    modifierOptions.onLoad(_this.reference, _this.popper, _this.options, modifierOptions, _this.state);
                }
            });
            this.update();
            var eventsEnabled = this.options.eventsEnabled;
            if (eventsEnabled) {
                this.enableEventListeners();
            }
            this.state.eventsEnabled = eventsEnabled;
        }
        return createClass(Popper, [{
            key: "update",
            value: function () {
                return update.call(this);
            }
        }, {
            key: "destroy",
            value: function () {
                return destroy.call(this);
            }
        }, {
            key: "enableEventListeners",
            value: function () {
                return enableEventListeners.call(this);
            }
        }, {
            key: "disableEventListeners",
            value: function () {
                return disableEventListeners.call(this);
            }
        }]), Popper;
    }();
    return Popper.Utils = ("undefined" == typeof window ? global : window).PopperUtils, Popper.placements = placements, Popper.Defaults = {
        placement: "bottom",
        positionFixed: false,
        eventsEnabled: true,
        removeOnDestroy: false,
        onCreate: function () {
        },
        onUpdate: function () {
        },
        modifiers: {
            shift: {
                order: 100,
                enabled: true,
                fn: function (data) {
                    var placement = data.placement;
                    var sceneUid = placement.split("-")[0];
                    var shiftvariation = placement.split("-")[1];
                    if (shiftvariation) {
                        var _data$offsets = data.offsets;
                        var reference = _data$offsets.reference;
                        var popper = _data$offsets.popper;
                        /** @type {boolean} */
                        var isVertical = -1 !== ["bottom", "top"].indexOf(sceneUid);
                        /** @type {string} */
                        var side = isVertical ? "left" : "top";
                        /** @type {string} */
                        var measurement = isVertical ? "width" : "height";
                        var shiftOffsets = {
                            start: defineProperty({}, side, reference[side]),
                            end: defineProperty({}, side, reference[side] + reference[measurement] - popper[measurement])
                        };
                        /** @type {!Object} */
                        data.offsets.popper = _extends({}, popper, shiftOffsets[shiftvariation]);
                    }
                    return data;
                }
            },
            offset: {
                order: 200,
                enabled: true,
                fn: offset,
                offset: 0
            },
            preventOverflow: {
                order: 300,
                enabled: true,
                fn: function (data, options) {
                    var el = options.boundariesElement || getOffsetParent(data.instance.popper);
                    if (data.instance.reference === el) {
                        el = getOffsetParent(el);
                    }
                    var prop = getSupportedPropertyName("transform");
                    var style = data.instance.popper.style;
                    var top = style.top;
                    var left = style.left;
                    var val = style[prop];
                    /** @type {string} */
                    style.top = "";
                    /** @type {string} */
                    style.left = "";
                    /** @type {string} */
                    style[prop] = "";
                    var boundaries = getBoundaries(data.instance.popper, data.instance.reference, options.padding, el, data.positionFixed);
                    style.top = top;
                    style.left = left;
                    style[prop] = val;
                    options.boundaries = boundaries;
                    var order = options.priority;
                    var popper = data.offsets.popper;
                    var defaults = {
                        primary: function (placement) {
                            var value = popper[placement];
                            return popper[placement] < boundaries[placement] && !options.escapeWithReference && (value = max(popper[placement], boundaries[placement])), defineProperty({}, placement, value);
                        },
                        secondary: function (placement) {
                            /** @type {string} */
                            var mainSide = "right" === placement ? "left" : "top";
                            var value = popper[mainSide];
                            return popper[placement] > boundaries[placement] && !options.escapeWithReference && (value = min(popper[mainSide], boundaries[placement] - ("right" === placement ? popper.width : popper.height))), defineProperty({}, mainSide, value);
                        }
                    };
                    return order.forEach(function (placement) {
                        /** @type {string} */
                        var order = -1 === ["left", "top"].indexOf(placement) ? "secondary" : "primary";
                        /** @type {!Object} */
                        popper = _extends({}, popper, defaults[order](placement));
                    }), data.offsets.popper = popper, data;
                },
                priority: ["left", "right", "top", "bottom"],
                padding: 5,
                boundariesElement: "scrollParent"
            },
            keepTogether: {
                order: 400,
                enabled: true,
                fn: function (data) {
                    var _data$offsets = data.offsets;
                    var popper = _data$offsets.popper;
                    var reference = _data$offsets.reference;
                    var sceneUid = data.placement.split("-")[0];
                    /** @type {function(?): number} */
                    var floor = $ceil;
                    /** @type {boolean} */
                    var isVertical = -1 !== ["top", "bottom"].indexOf(sceneUid);
                    /** @type {string} */
                    var side = isVertical ? "right" : "bottom";
                    /** @type {string} */
                    var opSide = isVertical ? "left" : "top";
                    /** @type {string} */
                    var measurement = isVertical ? "width" : "height";
                    return popper[side] < floor(reference[opSide]) && (data.offsets.popper[opSide] = floor(reference[opSide]) - popper[measurement]), popper[opSide] > floor(reference[side]) && (data.offsets.popper[opSide] = floor(reference[side])), data;
                }
            },
            arrow: {
                order: 500,
                enabled: true,
                fn: function (data, left) {
                    var _typeMap;
                    if (!isModifierRequired(data.instance.modifiers, "arrow", "keepTogether")) {
                        return data;
                    }
                    var a = left.element;
                    if ("string" == typeof a) {
                        if (a = data.instance.popper.querySelector(a), !a) {
                            return data;
                        }
                    } else {
                        if (!data.instance.popper.contains(a)) {
                            return console.warn("WARNING: `arrow.element` must be child of its popper element!"), data;
                        }
                    }
                    var sceneUid = data.placement.split("-")[0];
                    var _data$offsets = data.offsets;
                    var popper = _data$offsets.popper;
                    var reference = _data$offsets.reference;
                    /** @type {boolean} */
                    var vert = -1 !== ["left", "right"].indexOf(sceneUid);
                    /** @type {string} */
                    var len = vert ? "height" : "width";
                    /** @type {string} */
                    var dir = vert ? "Top" : "Left";
                    /** @type {string} */
                    var side = dir.toLowerCase();
                    /** @type {string} */
                    var prop = vert ? "left" : "top";
                    /** @type {string} */
                    var opSide = vert ? "bottom" : "right";
                    var arrowElementSize = init(a)[len];
                    if (reference[opSide] - arrowElementSize < popper[side]) {
                        data.offsets.popper[side] -= popper[side] - (reference[opSide] - arrowElementSize);
                    }
                    if (reference[side] + arrowElementSize > popper[opSide]) {
                        data.offsets.popper[side] += reference[side] + arrowElementSize - popper[opSide];
                    }
                    data.offsets.popper = getClientRect(data.offsets.popper);
                    /** @type {number} */
                    var center = reference[side] + reference[len] / 2 - arrowElementSize / 2;
                    var computedStyle = getComputedStyle(data.instance.popper);
                    /** @type {number} */
                    var height = parseFloat(computedStyle["margin" + dir], 10);
                    /** @type {number} */
                    var offset = parseFloat(computedStyle["border" + dir + "Width"], 10);
                    /** @type {number} */
                    var length = center - data.offsets.popper[side] - height - offset;
                    return length = max(min(popper[len] - arrowElementSize, length), 0), data.arrowElement = a, data.offsets.arrow = (_typeMap = {}, defineProperty(_typeMap, side, round(length)), defineProperty(_typeMap, prop, ""), _typeMap), data;
                },
                element: "[x-arrow]"
            },
            flip: {
                order: 600,
                enabled: true,
                fn: function (data, options) {
                    if (isModifierEnabled(data.instance.modifiers, "inner")) {
                        return data;
                    }
                    if (data.flipped && data.placement === data.originalPlacement) {
                        return data;
                    }
                    var boundaries = getBoundaries(data.instance.popper, data.instance.reference, options.padding, options.boundariesElement, data.positionFixed);
                    var placement = data.placement.split("-")[0];
                    var placementOpposite = getOppositePlacement(placement);
                    var end = data.placement.split("-")[1] || "";
                    /** @type {!Array} */
                    var flipOrder = [];
                    switch (options.behavior) {
                        case BEHAVIORS.FLIP:
                            /** @type {!Array} */
                            flipOrder = [placement, placementOpposite];
                            break;
                        case BEHAVIORS.CLOCKWISE:
                            flipOrder = clockwise(placement);
                            break;
                        case BEHAVIORS.COUNTERCLOCKWISE:
                            flipOrder = clockwise(placement, true);
                            break;
                        default:
                            flipOrder = options.behavior;
                    }
                    return flipOrder.forEach(function (inside, index) {
                        if (placement !== inside || flipOrder.length === index + 1) {
                            return data;
                        }
                        placement = data.placement.split("-")[0];
                        placementOpposite = getOppositePlacement(placement);
                        var popper = data.offsets.popper;
                        var refOffsets = data.offsets.reference;
                        /** @type {function(?): number} */
                        var floor = $ceil;
                        /** @type {boolean} */
                        var m = "left" === placement && floor(popper.right) > floor(refOffsets.left) || "right" === placement && floor(popper.left) < floor(refOffsets.right) || "top" === placement && floor(popper.bottom) > floor(refOffsets.top) || "bottom" === placement && floor(popper.top) < floor(refOffsets.bottom);
                        /** @type {boolean} */
                        var isSwipingLeft = floor(popper.left) < floor(boundaries.left);
                        /** @type {boolean} */
                        var isSwipingRight = floor(popper.right) > floor(boundaries.right);
                        /** @type {boolean} */
                        var g = floor(popper.top) < floor(boundaries.top);
                        /** @type {boolean} */
                        var u = floor(popper.bottom) > floor(boundaries.bottom);
                        /** @type {boolean} */
                        var message = "left" === placement && isSwipingLeft || "right" === placement && isSwipingRight || "top" === placement && g || "bottom" === placement && u;
                        /** @type {boolean} */
                        var forward = -1 !== ["top", "bottom"].indexOf(placement);
                        /** @type {boolean} */
                        var x = !!options.flipVariations && (forward && "start" === end && isSwipingLeft || forward && "end" === end && isSwipingRight || !forward && "start" === end && g || !forward && "end" === end && u);
                        /** @type {boolean} */
                        var y = !!options.flipVariationsByContent && (forward && "start" === end && isSwipingRight || forward && "end" === end && isSwipingLeft || !forward && "start" === end && u || !forward && "end" === end && g);
                        /** @type {boolean} */
                        var bayeuxError = x || y;
                        if (m || message || bayeuxError) {
                            /** @type {boolean} */
                            data.flipped = true;
                            if (m || message) {
                                placement = flipOrder[index + 1];
                            }
                            if (bayeuxError) {
                                end = getEndDate(end);
                            }
                            /** @type {string} */
                            data.placement = placement + (end ? "-" + end : "");
                            /** @type {!Object} */
                            data.offsets.popper = _extends({}, data.offsets.popper, getPopperOffsets(data.instance.popper, data.offsets.reference, data.placement));
                            data = runModifiers(data.instance.modifiers, data, "flip");
                        }
                    }), data;
                },
                behavior: "flip",
                padding: 5,
                boundariesElement: "viewport",
                flipVariations: false,
                flipVariationsByContent: false
            },
            inner: {
                order: 700,
                enabled: false,
                fn: function (data) {
                    var placement = data.placement;
                    var nodeId = placement.split("-")[0];
                    var _data$offsets = data.offsets;
                    var popper = _data$offsets.popper;
                    var reference = _data$offsets.reference;
                    /** @type {boolean} */
                    var isHoriz = -1 !== ["left", "right"].indexOf(nodeId);
                    /** @type {boolean} */
                    var subtractLength = -1 === ["top", "left"].indexOf(nodeId);
                    return popper[isHoriz ? "left" : "top"] = reference[nodeId] - (subtractLength ? popper[isHoriz ? "width" : "height"] : 0), data.placement = getOppositePlacement(placement), data.offsets.popper = getClientRect(popper), data;
                }
            },
            hide: {
                order: 800,
                enabled: true,
                fn: function (data) {
                    if (!isModifierRequired(data.instance.modifiers, "hide", "preventOverflow")) {
                        return data;
                    }
                    var itsGeom = data.offsets.reference;
                    var pgdGeom = find$1(data.instance.modifiers, function (engineDiscovery) {
                        return "preventOverflow" === engineDiscovery.name;
                    }).boundaries;
                    if (itsGeom.bottom < pgdGeom.top || itsGeom.left > pgdGeom.right || itsGeom.top > pgdGeom.bottom || itsGeom.right < pgdGeom.left) {
                        if (true === data.hide) {
                            return data;
                        }
                        /** @type {boolean} */
                        data.hide = true;
                        /** @type {string} */
                        data.attributes["x-out-of-boundaries"] = "";
                    } else {
                        if (false === data.hide) {
                            return data;
                        }
                        /** @type {boolean} */
                        data.hide = false;
                        /** @type {boolean} */
                        data.attributes["x-out-of-boundaries"] = false;
                    }
                    return data;
                }
            },
            computeStyle: {
                order: 850,
                enabled: true,
                fn: function (data, options) {
                    var side = options.x;
                    var left = options.y;
                    var newAuthorship = data.offsets.popper;
                    var undefined = find$1(data.instance.modifiers, function (engineDiscovery) {
                        return "applyStyle" === engineDiscovery.name;
                    }).gpuAcceleration;
                    if (void 0 !== undefined) {
                        console.warn("WARNING: `gpuAcceleration` option moved to `computeStyle` modifier and will not be supported in future versions of Popper.js!");
                    }
                    var s;
                    var c;
                    var groupStatus = void 0 === undefined ? options.gpuAcceleration : undefined;
                    var parent = getOffsetParent(data.instance.popper);
                    var parentRect = getBoundingClientRect(parent);
                    var style = {
                        position: newAuthorship.position
                    };
                    var pos = render(data, 2 > window.devicePixelRatio || !typeName);
                    /** @type {string} */
                    var position = "bottom" === side ? "top" : "bottom";
                    /** @type {string} */
                    var key = "right" === left ? "left" : "right";
                    var prefixedProperty = getSupportedPropertyName("transform");
                    if (c = "bottom" == position ? "HTML" === parent.nodeName ? -parent.clientHeight + pos.bottom : -parentRect.height + pos.bottom : pos.top, s = "right" == key ? "HTML" === parent.nodeName ? -parent.clientWidth + pos.right : -parentRect.width + pos.right : pos.left, groupStatus && prefixedProperty) {
                        /** @type {string} */
                        style[prefixedProperty] = "translate3d(" + s + "px, " + c + "px, 0)";
                        /** @type {number} */
                        style[position] = 0;
                        /** @type {number} */
                        style[key] = 0;
                        /** @type {string} */
                        style.willChange = "transform";
                    } else {
                        /** @type {number} */
                        var x = "bottom" == position ? -1 : 1;
                        /** @type {number} */
                        var value = "right" == key ? -1 : 1;
                        /** @type {number} */
                        style[position] = c * x;
                        /** @type {number} */
                        style[key] = s * value;
                        /** @type {string} */
                        style.willChange = position + ", " + key;
                    }
                    var attributes = {
                        "x-placement": data.placement
                    };
                    return data.attributes = _extends({}, attributes, data.attributes), data.styles = _extends({}, style, data.styles), data.arrowStyles = _extends({}, data.offsets.arrow, data.arrowStyles), data;
                },
                gpuAcceleration: true,
                x: "bottom",
                y: "right"
            },
            applyStyle: {
                order: 900,
                enabled: true,
                fn: function (data) {
                    return setStyles(data.instance.popper, data.styles), setAttributes(data.instance.popper, data.attributes), data.arrowElement && Object.keys(data.arrowStyles).length && setStyles(data.arrowElement, data.arrowStyles), data;
                },
                onLoad: function (reference, popper, options, callback, state) {
                    var referenceOffsets = getReferenceOffsets(state, popper, reference, options.positionFixed);
                    var placement = computeAutoPlacement(options.placement, referenceOffsets, popper, reference, options.modifiers.flip.boundariesElement, options.modifiers.flip.padding);
                    return popper.setAttribute("x-placement", placement), setStyles(popper, {
                        position: options.positionFixed ? "fixed" : "absolute"
                    }), options;
                },
                gpuAcceleration: void 0
            }
        }
    }, Popper;
});
