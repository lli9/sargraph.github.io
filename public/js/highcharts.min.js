'use strict';
(function (global, factory) {
    if ("object" === typeof module && module.exports) {
        /** @type {function(!HTMLElement): ?} */
        factory["default"] = factory;
        module.exports = global.document ? factory(global) : factory;
    } else {
        if ("function" === typeof define && define.amd) {
            define("highcharts/highcharts", function () {
                return factory(global);
            });
        } else {
            if (global.Highcharts) {
                global.Highcharts.error(16, true);
            }
            global.Highcharts = factory(global);
        }
    }
})("undefined" !== typeof window ? window : this, function (global) {
    /**
     * @param {!Object} d
     * @param {string} i
     * @param {!Array} a
     * @param {!Function} f
     * @return {undefined}
     */
    function set(d, i, a, f) {
        if (!d.hasOwnProperty(i)) {
            d[i] = f.apply(null, a);
        }
    }
    var x1 = {};
    set(x1, "parts/Globals.js", [], function () {
        var win = "undefined" !== typeof global ? global : "undefined" !== typeof window ? window : {};
        var doc = win.document;
        var userAgent = win.navigator && win.navigator.userAgent || "";
        var svgNamespace = doc && doc.createElementNS && !!doc.createElementNS("http://www.w3.org/2000/svg", "svg").createSVGRect;
        /** @type {boolean} */
        var isMS = /(edge|msie|trident)/i.test(userAgent) && !win.opera;
        /** @type {boolean} */
        var isFirefox = -1 !== userAgent.indexOf("Firefox");
        /** @type {boolean} */
        var isChrome = -1 !== userAgent.indexOf("Chrome");
        /** @type {boolean} */
        var hasBidiBug = isFirefox && 4 > parseInt(userAgent.split("Firefox/")[1], 10);
        return {
            product: "Highcharts",
            version: "8.0.0",
            deg2rad: 2 * Math.PI / 360,
            doc: doc,
            hasBidiBug: hasBidiBug,
            hasTouch: !!win.TouchEvent,
            isMS: isMS,
            isWebKit: -1 !== userAgent.indexOf("AppleWebKit"),
            isFirefox: isFirefox,
            isChrome: isChrome,
            isSafari: !isChrome && -1 !== userAgent.indexOf("Safari"),
            isTouchDevice: /(Mobile|Android|Windows Phone)/.test(userAgent),
            SVG_NS: "http://www.w3.org/2000/svg",
            chartCount: 0,
            seriesTypes: {},
            symbolSizes: {},
            svg: svgNamespace,
            win: win,
            marginNames: ["plotTop", "marginRight", "marginBottom", "plotLeft"],
            noop: function () {
            },
            charts: [],
            dateFormats: {}
        };
    });
    set(x1, "parts/Utilities.js", [x1["parts/Globals.js"]], function (self) {
        /**
         * @param {!Object} str
         * @param {number} base
         * @return {?}
         */
        function replace(str, base) {
            return parseInt(str, base || 10);
        }
        /**
         * @param {!Object} type
         * @return {?}
         */
        function isString(type) {
            return "string" === typeof type;
        }
        /**
         * @param {!Object} obj
         * @return {?}
         */
        function isArray(obj) {
            /** @type {string} */
            obj = Object.prototype.toString.call(obj);
            return "[object Array]" === obj || "[object Array Iterator]" === obj;
        }
        /**
         * @param {!Object} a
         * @param {boolean} obj
         * @return {?}
         */
        function isObject(a, obj) {
            return !!a && "object" === typeof a && (!obj || !isArray(a));
        }
        /**
         * @param {!Object} b
         * @return {?}
         */
        function typeOf(b) {
            return isObject(b) && "number" === typeof b.nodeType;
        }
        /**
         * @param {!Object} obj
         * @return {?}
         */
        function validate(obj) {
            var info = obj && obj.constructor;
            return !(!isObject(obj, true) || typeOf(obj) || !info || !info.name || "Object" === info.name);
        }
        /**
         * @param {number} value
         * @return {?}
         */
        function callback(value) {
            return "number" === typeof value && !isNaN(value) && Infinity > value && -Infinity < value;
        }
        /**
         * @param {!Object} x
         * @return {?}
         */
        function defined(x) {
            return "undefined" !== typeof x && null !== x;
        }
        /**
         * @param {!Object} value
         * @param {string} name
         * @param {string} a
         * @return {?}
         */
        function attr(value, name, a) {
            var res;
            if (isString(name)) {
                if (defined(a)) {
                    value.setAttribute(name, a);
                } else {
                    if (value && value.getAttribute) {
                        if (!((res = value.getAttribute(name)) || "class" !== name)) {
                            res = value.getAttribute(name + "Name");
                        }
                    }
                }
            } else {
                each(name, function (i, oldModelPath) {
                    value.setAttribute(oldModelPath, i);
                });
            }
            return res;
        }
        /**
         * @param {!Object} value
         * @param {!Object} object
         * @return {?}
         */
        function extend(value, object) {
            var property;
            if (!value) {
                value = {};
            }
            for (property in object) {
                value[property] = object[property];
            }
            return value;
        }
        /**
         * @return {?}
         */
        function get() {
            /** @type {!Arguments} */
            var options = arguments;
            /** @type {number} */
            var rowsCount = options.length;
            /** @type {number} */
            var i = 0;
            for (; i < rowsCount; i++) {
                var value = options[i];
                if ("undefined" !== typeof value && null !== value) {
                    return value;
                }
            }
        }
        /**
         * @param {?} parent
         * @param {!Object} obj
         * @return {?}
         */
        function extendClass(parent, obj) {
            /**
             * @return {undefined}
             */
            var Class = function () {
            };
            Class.prototype = new parent;
            extend(Class.prototype, obj);
            return Class;
        }
        /**
         * @param {number} num
         * @param {number} prec
         * @return {?}
         */
        function round(num, prec) {
            return parseFloat(num.toPrecision(prec || 14));
        }
        /**
         * @param {number} name
         * @param {number} n
         * @param {?} key
         * @param {string} type
         * @return {?}
         */
        function init(name, n, key, type) {
            /** @type {number} */
            name = +name || 0;
            /** @type {number} */
            n = +n;
            var lang = self.defaultOptions.lang;
            /** @type {number} */
            var c = (name.toString().split(".")[1] || "").split("e")[0].length;
            /** @type {!Array<string>} */
            var m = name.toString().split("e");
            if (-1 === n) {
                /** @type {number} */
                n = Math.min(c, 20);
            } else {
                if (!callback(n)) {
                    /** @type {number} */
                    n = 2;
                } else {
                    if (n && m[1] && 0 > m[1]) {
                        /** @type {number} */
                        var i = n + +m[1];
                        if (0 <= i) {
                            /** @type {string} */
                            m[0] = (+m[0]).toExponential(i).split("e")[0];
                            /** @type {number} */
                            n = i;
                        } else {
                            /** @type {(number|string)} */
                            m[0] = m[0].split(".")[0] || 0;
                            /** @type {(number|string)} */
                            name = 20 > n ? (m[0] * Math.pow(10, m[1])).toFixed(n) : 0;
                            /** @type {number} */
                            m[1] = 0;
                        }
                    }
                }
            }
            /** @type {string} */
            var s = (Math.abs(m[1] ? m[0] : name) + Math.pow(10, -Math.max(n, c) - 1)).toFixed(n);
            /** @type {string} */
            c = String(replace(s));
            /** @type {number} */
            i = 3 < c.length ? c.length % 3 : 0;
            key = get(key, lang.decimalPoint);
            type = get(type, lang.thousandsSep);
            /** @type {string} */
            name = (0 > name ? "-" : "") + (i ? c.substr(0, i) + type : "");
            /** @type {string} */
            name = name + c.substr(i).replace(/(\d{3})(?=\d)/g, "$1" + type);
            if (n) {
                /** @type {string} */
                name = name + (key + s.slice(-n));
            }
            if (m[1] && 0 !== +name) {
                /** @type {string} */
                name = name + ("e" + m[1]);
            }
            return name;
        }
        /**
         * @param {!Object} obj
         * @param {!Function} fn
         * @param {?} scope
         * @return {undefined}
         */
        function each(obj, fn, scope) {
            var i;
            for (i in obj) {
                if (Object.hasOwnProperty.call(obj, i)) {
                    fn.call(scope || obj[i], obj[i], i, obj);
                }
            }
        }
        /** @type {!Array} */
        self.timers = [];
        var charts = self.charts;
        var doc = self.doc;
        var win = self.win;
        /**
         * @param {number} id
         * @param {string} storage
         * @param {!Object} name
         * @param {!Object} options
         * @return {undefined}
         */
        self.error = function (id, storage, name, options) {
            var val = callback(id);
            var result = val ? "Highcharts error #" + id + ": www.highcharts.com/errors/" + id + "/" : id.toString();
            /**
             * @return {undefined}
             */
            var error = function () {
                if (storage) {
                    throw Error(result);
                }
                if (win.console) {
                    console.log(result);
                }
            };
            if ("undefined" !== typeof options) {
                /** @type {string} */
                var term = "";
                if (val) {
                    result = result + "?";
                }
                self.objectEach(options, function (x, fileToDownload) {
                    term = term + ("\n" + fileToDownload + ": " + x);
                    if (val) {
                        result = result + (encodeURI(fileToDownload) + "=" + encodeURI(x));
                    }
                });
                result = result + term;
            }
            if (name) {
                self.fireEvent(name, "displayError", {
                    code: id,
                    message: result,
                    params: options
                }, error);
            } else {
                error();
            }
        };
        /**
         * @param {string} elem
         * @param {!Object} options
         * @param {string} prop
         * @return {undefined}
         */
        self.Fx = function (elem, options, prop) {
            /** @type {!Object} */
            this.options = options;
            /** @type {string} */
            this.elem = elem;
            /** @type {string} */
            this.prop = prop;
        };
        self.Fx.prototype = {
            dSetter: function () {
                var path = this.paths[0];
                var d = this.paths[1];
                /** @type {!Array} */
                var ret = [];
                var now = this.now;
                var i = path.length;
                if (1 === now) {
                    ret = this.toD;
                } else {
                    if (i === d.length && 1 > now) {
                        for (; i--;) {
                            /** @type {number} */
                            var start = parseFloat(path[i]);
                            ret[i] = isNaN(start) || "A" === d[i - 4] || "A" === d[i - 5] ? d[i] : now * parseFloat("" + (d[i] - start)) + start;
                        }
                    } else {
                        ret = d;
                    }
                }
                this.elem.attr("d", ret, null, true);
            },
            update: function () {
                var elem = this.elem;
                var prop = this.prop;
                var now = this.now;
                var step = this.options.step;
                if (this[prop + "Setter"]) {
                    this[prop + "Setter"]();
                } else {
                    if (elem.attr) {
                        if (elem.element) {
                            elem.attr(prop, now, null, true);
                        }
                    } else {
                        elem.style[prop] = now + this.unit;
                    }
                }
                if (step) {
                    step.call(elem, now, this);
                }
            },
            run: function (end, start, s) {
                var api = this;
                var options = api.options;
                /**
                 * @param {undefined} i
                 * @return {?}
                 */
                var timer = function (i) {
                    return timer.stopped ? false : api.step(i);
                };
                var format = win.requestAnimationFrame || function (callback) {
                    setTimeout(callback, 13);
                };
                /**
                 * @return {undefined}
                 */
                var finish = function () {
                    /** @type {number} */
                    var i = 0;
                    for (; i < self.timers.length; i++) {
                        if (!self.timers[i]()) {
                            self.timers.splice(i--, 1);
                        }
                    }
                    if (self.timers.length) {
                        format(finish);
                    }
                };
                if (end !== start || this.elem["forceAnimate:" + this.prop]) {
                    /** @type {number} */
                    this.startTime = +new Date;
                    /** @type {!Object} */
                    this.start = end;
                    /** @type {!Object} */
                    this.end = start;
                    /** @type {string} */
                    this.unit = s;
                    this.now = this.start;
                    /** @type {number} */
                    this.pos = 0;
                    timer.elem = this.elem;
                    timer.prop = this.prop;
                    if (timer() && 1 === self.timers.push(timer)) {
                        format(finish);
                    }
                } else {
                    delete options.curAnim[this.prop];
                    if (options.complete && 0 === Object.keys(options.curAnim).length) {
                        options.complete.call(this.elem);
                    }
                }
            },
            step: function (key) {
                /** @type {number} */
                var t = +new Date;
                var options = this.options;
                var elem = this.elem;
                var complete = options.complete;
                var duration = options.duration;
                var curAnim = options.curAnim;
                if (elem.attr && !elem.element) {
                    /** @type {boolean} */
                    key = false;
                } else {
                    if (key || t >= duration + this.startTime) {
                        this.now = this.end;
                        /** @type {number} */
                        this.pos = 1;
                        this.update();
                        /** @type {boolean} */
                        var tmp = curAnim[this.prop] = true;
                        each(curAnim, function (canCreateDiscussions) {
                            if (true !== canCreateDiscussions) {
                                /** @type {boolean} */
                                tmp = false;
                            }
                        });
                        if (tmp && complete) {
                            complete.call(elem);
                        }
                        /** @type {boolean} */
                        key = false;
                    } else {
                        this.pos = options.easing((t - this.startTime) / duration);
                        this.now = this.start + (this.end - this.start) * this.pos;
                        this.update();
                        /** @type {boolean} */
                        key = true;
                    }
                }
                return key;
            },
            initPath: function (elem, start, end) {
                /**
                 * @param {!Object} arr
                 * @return {undefined}
                 */
                function sixify(arr) {
                    i = arr.length;
                    for (; i--;) {
                        /** @type {boolean} */
                        var a = "M" === arr[i] || "L" === arr[i];
                        /** @type {boolean} */
                        var b = /[a-zA-Z]/.test(arr[i + 3]);
                        if (a && b) {
                            arr.splice(i + 1, 0, arr[i + 1], arr[i + 2], arr[i + 1], arr[i + 2]);
                        }
                    }
                }
                /**
                 * @param {!Object} arr
                 * @param {!Object} other
                 * @return {undefined}
                 */
                function prepend(arr, other) {
                    for (; arr.length < fullLength;) {
                        arr[0] = other[fullLength - arr.length];
                        var newNodeLists = arr.slice(0, numParams);
                        [].splice.apply(arr, [0, 0].concat(newNodeLists));
                        if (isArea) {
                            newNodeLists = arr.slice(arr.length - numParams);
                            [].splice.apply(arr, [arr.length, 0].concat(newNodeLists));
                            i--;
                        }
                    }
                    /** @type {string} */
                    arr[0] = "M";
                }
                /**
                 * @param {!Object} arr
                 * @param {!Object} type
                 * @return {undefined}
                 */
                function append(arr, type) {
                    /** @type {number} */
                    var i = (fullLength - arr.length) / numParams;
                    for (; 0 < i && i--;) {
                        args = arr.slice().splice(arr.length / positionFactor - numParams, numParams * positionFactor);
                        args[0] = type[fullLength - numParams - i * numParams];
                        if (bezier) {
                            args[numParams - 6] = args[numParams - 2];
                            args[numParams - 5] = args[numParams - 1];
                        }
                        [].splice.apply(arr, [arr.length / positionFactor, 0].concat(args));
                        if (isArea) {
                            i--;
                        }
                    }
                }
                start = start || "";
                var s = elem.startX;
                var e = elem.endX;
                /** @type {boolean} */
                var bezier = -1 < start.indexOf("C");
                /** @type {number} */
                var numParams = bezier ? 7 : 3;
                var args;
                var i;
                start = start.split(" ");
                end = end.slice();
                var isArea = elem.isArea;
                /** @type {number} */
                var positionFactor = isArea ? 2 : 1;
                if (bezier) {
                    sixify(start);
                    sixify(end);
                }
                if (s && e) {
                    /** @type {number} */
                    i = 0;
                    for (; i < s.length; i++) {
                        if (s[i] === e[0]) {
                            var shift = i;
                            break;
                        } else {
                            if (s[0] === e[e.length - s.length + i]) {
                                shift = i;
                                /** @type {boolean} */
                                var A = true;
                                break;
                            } else {
                                if (s[s.length - 1] === e[e.length - s.length + i]) {
                                    /** @type {number} */
                                    shift = s.length - i;
                                    break;
                                }
                            }
                        }
                    }
                    if ("undefined" === typeof shift) {
                        /** @type {!Array} */
                        start = [];
                    }
                }
                if (start.length && callback(shift)) {
                    var fullLength = end.length + shift * positionFactor * numParams;
                    if (A) {
                        prepend(start, end);
                        append(end, start);
                    } else {
                        prepend(end, start);
                        append(start, end);
                    }
                }
                return [start, end];
            },
            fillSetter: function () {
                self.Fx.prototype.strokeSetter.apply(this, arguments);
            },
            strokeSetter: function () {
                this.elem.attr(this.prop, self.color(this.start).tweenTo(self.color(this.end), this.pos), null, true);
            }
        };
        /**
         * @return {?}
         */
        self.merge = function () {
            var i;
            /** @type {!Arguments} */
            var data = arguments;
            var result = {};
            /**
             * @param {number} data
             * @param {!Object} obj
             * @return {?}
             */
            var filter = function (data, obj) {
                if ("object" !== typeof data) {
                    data = {};
                }
                each(obj, function (b, i) {
                    if (!isObject(b, true) || validate(b) || typeOf(b)) {
                        data[i] = obj[i];
                    } else {
                        data[i] = filter(data[i] || {}, b);
                    }
                });
                return data;
            };
            if (true === data[0]) {
                result = data[1];
                /** @type {!Array<?>} */
                data = Array.prototype.slice.call(data, 2);
            }
            /** @type {number} */
            var tldCount = data.length;
            /** @type {number} */
            i = 0;
            for (; i < tldCount; i++) {
                result = filter(result, data[i]);
            }
            return result;
        };
        /**
         * @param {!Object} timer
         * @return {undefined}
         */
        self.clearTimeout = function (timer) {
            if (defined(timer)) {
                clearTimeout(timer);
            }
        };
        /**
         * @param {!Object} value
         * @param {!Object} data
         * @return {undefined}
         */
        self.css = function (value, data) {
            if (self.isMS && !self.svg && data && "undefined" !== typeof data.opacity) {
                /** @type {string} */
                data.filter = "alpha(opacity=" + 100 * data.opacity + ")";
            }
            extend(value.style, data);
        };
        /**
         * @param {string} el
         * @param {!Object} fn
         * @param {!Object} type
         * @param {!Object} obj
         * @param {boolean} attribs
         * @return {?}
         */
        self.createElement = function (el, fn, type, obj, attribs) {
            el = doc.createElement(el);
            /** @type {function(!Object, !Object): undefined} */
            var css = self.css;
            if (fn) {
                extend(el, fn);
            }
            if (attribs) {
                css(el, {
                    padding: "0",
                    border: "none",
                    margin: "0"
                });
            }
            if (type) {
                css(el, type);
            }
            if (obj) {
                obj.appendChild(el);
            }
            return el;
        };
        /**
         * @param {!Object} diff
         * @return {undefined}
         */
        self.datePropsToTimestamps = function (diff) {
            each(diff, function (val, aKey) {
                if (isObject(val) && "function" === typeof val.getTime) {
                    diff[aKey] = val.getTime();
                } else {
                    if (isObject(val) || isArray(val)) {
                        self.datePropsToTimestamps(val);
                    }
                }
            });
        };
        /**
         * @param {string} format
         * @param {?} value
         * @param {!Object} func
         * @return {?}
         */
        self.formatSingle = function (format, value, func) {
            /** @type {!RegExp} */
            var d = /\.([0-9])/;
            var lang = self.defaultOptions.lang;
            var field = func && func.time || self.time;
            func = func && func.numberFormatter || init;
            if (/f$/.test(format)) {
                d = (d = format.match(d)) ? d[1] : -1;
                if (null !== value) {
                    value = func(value, d, lang.decimalPoint, -1 < format.indexOf(",") ? lang.thousandsSep : "");
                }
            } else {
                value = field.dateFormat(format, value);
            }
            return value;
        };
        /**
         * @param {?} key
         * @param {?} obj
         * @param {?} type
         * @return {?}
         */
        self.format = function (key, obj, type) {
            /** @type {string} */
            var i = "{";
            /** @type {boolean} */
            var b = false;
            var part;
            var bKeys;
            var i_2;
            var intNextIndex;
            /** @type {!Array} */
            var ret = [];
            var val;
            for (; key;) {
                i = key.indexOf(i);
                if (-1 === i) {
                    break;
                }
                part = key.slice(0, i);
                if (b) {
                    part = part.split(":");
                    bKeys = part.shift().split(".");
                    intNextIndex = bKeys.length;
                    val = obj;
                    /** @type {number} */
                    i_2 = 0;
                    for (; i_2 < intNextIndex; i_2++) {
                        if (val) {
                            val = val[bKeys[i_2]];
                        }
                    }
                    if (part.length) {
                        val = self.formatSingle(part.join(":"), val, type);
                    }
                    ret.push(val);
                } else {
                    ret.push(part);
                }
                key = key.slice(i + 1);
                /** @type {string} */
                i = (b = !b) ? "}" : "{";
            }
            ret.push(key);
            return ret.join("");
        };
        /**
         * @param {number} num
         * @return {?}
         */
        self.getMagnitude = function (num) {
            return Math.pow(10, Math.floor(Math.log(num) / Math.LN10));
        };
        /**
         * @param {number} value
         * @param {!Object} a
         * @param {number} width
         * @param {!Object} i
         * @param {string} n
         * @return {?}
         */
        self.normalizeTickInterval = function (value, a, width, i, n) {
            /** @type {number} */
            var x = value;
            width = get(width, 1);
            /** @type {number} */
            var scale = value / width;
            if (!a) {
                /** @type {!Array} */
                a = n ? [1, 1.2, 1.5, 2, 2.5, 3, 4, 5, 6, 8, 10] : [1, 2, 2.5, 5, 10];
                if (false === i) {
                    if (1 === width) {
                        /** @type {!Array<?>} */
                        a = a.filter(function (canCreateDiscussions) {
                            return 0 === canCreateDiscussions % 1;
                        });
                    } else {
                        if (.1 >= width) {
                            /** @type {!Array} */
                            a = [1 / width];
                        }
                    }
                }
            }
            /** @type {number} */
            i = 0;
            for (; i < a.length && !(x = a[i], n && x * width >= value || !n && scale <= (a[i] + (a[i + 1] || a[i])) / 2); i++) {
            }
            return x = round(x * width, -Math.round(Math.log(.001) / Math.LN10));
        };
        /**
         * @param {!Object} arr
         * @param {!Function} sortFunction
         * @return {undefined}
         */
        self.stableSort = function (arr, sortFunction) {
            var arr_length = arr.length;
            var result;
            var i;
            /** @type {number} */
            i = 0;
            for (; i < arr_length; i++) {
                /** @type {number} */
                arr[i].safeI = i;
            }
            arr.sort(function (a, b) {
                result = sortFunction(a, b);
                return 0 === result ? a.safeI - b.safeI : result;
            });
            /** @type {number} */
            i = 0;
            for (; i < arr_length; i++) {
                delete arr[i].safeI;
            }
        };
        self.timeUnits = {
            millisecond: 1,
            second: 1E3,
            minute: 6E4,
            hour: 36E5,
            day: 864E5,
            week: 6048E5,
            month: 24192E5,
            year: 314496E5
        };
        /**
         * @param {!Object} value
         * @return {?}
         */
        Math.easeInOutSine = function (value) {
            return -.5 * (Math.cos(Math.PI * value) - 1);
        };
        /**
         * @param {!Object} node
         * @param {string} key
         * @param {string} i
         * @return {?}
         */
        self.getStyle = function (node, key, i) {
            if ("width" === key) {
                return key = Math.min(node.offsetWidth, node.scrollWidth), i = node.getBoundingClientRect && node.getBoundingClientRect().width, i < key && i >= key - 1 && (key = Math.floor(i)), Math.max(0, key - self.getStyle(node, "padding-left") - self.getStyle(node, "padding-right"));
            }
            if ("height" === key) {
                return Math.max(0, Math.min(node.offsetHeight, node.scrollHeight) - self.getStyle(node, "padding-top") - self.getStyle(node, "padding-bottom"));
            }
            if (!win.getComputedStyle) {
                self.error(27, true);
            }
            if (node = win.getComputedStyle(node, void 0)) {
                node = node.getPropertyValue(key);
                if (get(i, "opacity" !== key)) {
                    node = replace(node);
                }
            }
            return node;
        };
        /**
         * @param {string} a
         * @param {string} b
         * @param {?} i
         * @return {?}
         */
        self.inArray = function (a, b, i) {
            return b.indexOf(a, i);
        };
        /** @type {function(string, !Function): ?} */
        self.find = Array.prototype.find ? function (b, a) {
            return b.find(a);
        } : function (i, c) {
            var j;
            var n = i.length;
            /** @type {number} */
            j = 0;
            for (; j < n; j++) {
                if (c(i[j], j)) {
                    return i[j];
                }
            }
        };
        /** @type {function(!Object): !Array<string>} */
        self.keys = Object.keys;
        /**
         * @param {!Object} object
         * @param {string} type
         * @return {undefined}
         */
        self.stop = function (object, type) {
            var i = self.timers.length;
            for (; i--;) {
                if (!(self.timers[i].elem !== object || type && type !== self.timers[i].prop)) {
                    /** @type {boolean} */
                    self.timers[i].stopped = true;
                }
            }
        };
        each({
            map: "map",
            each: "forEach",
            grep: "filter",
            reduce: "reduce",
            some: "some"
        }, function (name, theFunctionName) {
            /**
             * @param {?} nextBuilder
             * @return {?}
             */
            self[theFunctionName] = function (nextBuilder) {
                return Array.prototype[name].apply(nextBuilder, [].slice.call(arguments, 1));
            };
        });
        /**
         * @param {!Object} obj
         * @param {string} event
         * @param {!Function} callback
         * @param {number} options
         * @return {?}
         */
        self.addEvent = function (obj, event, callback, options) {
            if (void 0 === options) {
                options = {};
            }
            var Lettuce = obj.addEventListener || self.addEventListenerPolyfill;
            var eventsByPlugin = "function" === typeof obj && obj.prototype ? obj.prototype.protoEvents = obj.prototype.protoEvents || {} : obj.hcEvents = obj.hcEvents || {};
            if (self.Point && obj instanceof self.Point && obj.series && obj.series.chart) {
                /** @type {boolean} */
                obj.series.chart.runTrackerClick = true;
            }
            if (Lettuce) {
                Lettuce.call(obj, event, callback, false);
            }
            if (!eventsByPlugin[event]) {
                /** @type {!Array} */
                eventsByPlugin[event] = [];
            }
            eventsByPlugin[event].push({
                fn: callback,
                order: "number" === typeof options.order ? options.order : Infinity
            });
            eventsByPlugin[event].sort(function (f1, f2) {
                return f1.order - f2.order;
            });
            return function () {
                self.removeEvent(obj, event, callback);
            };
        };
        /**
         * @param {!Object} obj
         * @param {string} name
         * @param {!Function} callback
         * @return {undefined}
         */
        self.removeEvent = function (obj, name, callback) {
            /**
             * @param {string} event
             * @param {!Function} callback
             * @return {undefined}
             */
            function fn(event, callback) {
                var Lettuce = obj.removeEventListener || self.removeEventListenerPolyfill;
                if (Lettuce) {
                    Lettuce.call(obj, event, callback, false);
                }
            }
            /**
             * @param {!Object} data
             * @return {undefined}
             */
            function get(data) {
                var key;
                if (obj.nodeName) {
                    if (name) {
                        var extraCheckers = {};
                        /** @type {boolean} */
                        extraCheckers[name] = true;
                    } else {
                        /** @type {!Object} */
                        extraCheckers = data;
                    }
                    each(extraCheckers, function (canCreateDiscussions, state) {
                        if (data[state]) {
                            key = data[state].length;
                            for (; key--;) {
                                fn(state, data[state][key].fn);
                            }
                        }
                    });
                }
            }
            var eCfgEl;
            ["protoEvents", "hcEvents"].forEach(function (id, s) {
                var l = (s = s ? obj : obj.prototype) && s[id];
                if (l) {
                    if (name) {
                        eCfgEl = l[name] || [];
                        if (callback) {
                            l[name] = eCfgEl.filter(function (handler) {
                                return callback !== handler.fn;
                            });
                            fn(name, callback);
                        } else {
                            get(l);
                            /** @type {!Array} */
                            l[name] = [];
                        }
                    } else {
                        get(l);
                        s[id] = {};
                    }
                }
            });
        };
        /**
         * @param {!Object} obj
         * @param {string} name
         * @param {!Object} e
         * @param {!Function} type
         * @return {undefined}
         */
        self.fireEvent = function (obj, name, e, type) {
            var d;
            e = e || {};
            if (doc.createEvent && (obj.dispatchEvent || obj.fireEvent)) {
                var event = doc.createEvent("Events");
                event.initEvent(name, true, true);
                extend(event, e);
                if (obj.dispatchEvent) {
                    obj.dispatchEvent(event);
                } else {
                    obj.fireEvent(name, event);
                }
            } else {
                if (!e.target) {
                    extend(e, {
                        preventDefault: function () {
                            /** @type {boolean} */
                            e.defaultPrevented = true;
                        },
                        target: obj,
                        type: name
                    });
                }
                (function (data, options) {
                    if (void 0 === data) {
                        /** @type {!Array} */
                        data = [];
                    }
                    if (void 0 === options) {
                        /** @type {!Array} */
                        options = [];
                    }
                    /** @type {number} */
                    var i = 0;
                    /** @type {number} */
                    var k = 0;
                    var dLn = data.length + options.length;
                    /** @type {number} */
                    d = 0;
                    for (; d < dLn; d++) {
                        if (false === (data[i] ? options[k] ? data[i].order <= options[k].order ? data[i++] : options[k++] : data[i++] : options[k++]).fn.call(obj, e)) {
                            e.preventDefault();
                        }
                    }
                })(obj.protoEvents && obj.protoEvents[name], obj.hcEvents && obj.hcEvents[name]);
            }
            if (type && !e.defaultPrevented) {
                type.call(obj, e);
            }
        };
        /**
         * @param {!Object} el
         * @param {!Object} params
         * @param {!Object} opt
         * @return {undefined}
         */
        self.animate = function (el, params, opt) {
            var n;
            /** @type {string} */
            var unit = "";
            var end;
            var fx;
            if (!isObject(opt)) {
                /** @type {!Arguments} */
                var args = arguments;
                opt = {
                    duration: args[2],
                    easing: args[3],
                    complete: args[4]
                };
            }
            if (!callback(opt.duration)) {
                /** @type {number} */
                opt.duration = 400;
            }
            opt.easing = "function" === typeof opt.easing ? opt.easing : Math[opt.easing] || Math.easeInOutSine;
            opt.curAnim = self.merge(params);
            each(params, function (orig_end, prop) {
                self.stop(el, prop);
                fx = new self.Fx(el, opt, prop);
                /** @type {null} */
                end = null;
                if ("d" === prop) {
                    fx.paths = fx.initPath(el, el.d, params.d);
                    fx.toD = params.d;
                    /** @type {number} */
                    n = 0;
                    /** @type {number} */
                    end = 1;
                } else {
                    if (el.attr) {
                        n = el.attr(prop);
                    } else {
                        /** @type {number} */
                        n = parseFloat(self.getStyle(el, prop)) || 0;
                        if ("opacity" !== prop) {
                            /** @type {string} */
                            unit = "px";
                        }
                    }
                }
                if (!end) {
                    /** @type {string} */
                    end = orig_end;
                }
                if (end && end.match && end.match("px")) {
                    end = end.replace(/px/g, "");
                }
                fx.run(n, end, unit);
            });
        };
        /**
         * @param {string} type
         * @param {string} parent
         * @param {!Object} options
         * @param {!Object} props
         * @param {!Object} body
         * @return {?}
         */
        self.seriesType = function (type, parent, options, props, body) {
            var defaultOptions = self.getOptions();
            var seriesTypes = self.seriesTypes;
            defaultOptions.plotOptions[type] = self.merge(defaultOptions.plotOptions[parent], options);
            seriesTypes[type] = extendClass(seriesTypes[parent] || function () {
            }, props);
            /** @type {string} */
            seriesTypes[type].prototype.type = type;
            if (body) {
                seriesTypes[type].prototype.pointClass = extendClass(self.Point, body);
            }
            return seriesTypes[type];
        };
        self.uniqueKey = function () {
            /** @type {string} */
            var uniqueKeyHash = Math.random().toString(36).substring(2, 9);
            /** @type {number} */
            var widgetUniqueIDIndex = 0;
            return function () {
                return "highcharts-" + uniqueKeyHash + "-" + widgetUniqueIDIndex++;
            };
        }();
        /**
         * @param {!Function} obj
         * @return {?}
         */
        self.isFunction = function (obj) {
            return "function" === typeof obj;
        };
        if (win.jQuery) {
            /**
             * @return {?}
             */
            win.jQuery.fn.highcharts = function () {
                /** @type {!Array<?>} */
                var args = [].slice.call(arguments);
                if (this[0]) {
                    return args[0] ? (new (self[isString(args[0]) ? args.shift() : "Chart"])(this[0], args[0], args[1]), this) : charts[attr(this[0], "data-highcharts-chart")];
                }
            };
        }
        return {
            animObject: function (animation) {
                return isObject(animation) ? self.merge(animation) : {
                    duration: animation ? 500 : 0
                };
            },
            arrayMax: function (array) {
                var i = array.length;
                var result = array[0];
                for (; i--;) {
                    if (array[i] > result) {
                        result = array[i];
                    }
                }
                return result;
            },
            arrayMin: function (array) {
                var i = array.length;
                var min = array[0];
                for (; i--;) {
                    if (array[i] < min) {
                        min = array[i];
                    }
                }
                return min;
            },
            attr: attr,
            clamp: function (a, b, c) {
                return a > b ? a < c ? a : c : b;
            },
            correctFloat: round,
            defined: defined,
            destroyObjectProperties: function (obj, except) {
                each(obj, function (val, sourcePropKey) {
                    if (val && val !== except && val.destroy) {
                        val.destroy();
                    }
                    delete obj[sourcePropKey];
                });
            },
            discardElement: function (element) {
                var garbageBin = self.garbageBin;
                if (!garbageBin) {
                    garbageBin = self.createElement("div");
                }
                if (element) {
                    garbageBin.appendChild(element);
                }
                /** @type {string} */
                garbageBin.innerHTML = "";
            },
            erase: function (array, name) {
                var i = array.length;
                for (; i--;) {
                    if (array[i] === name) {
                        array.splice(i, 1);
                        break;
                    }
                }
            },
            extend: extend,
            extendClass: extendClass,
            isArray: isArray,
            isClass: validate,
            isDOMElement: typeOf,
            isNumber: callback,
            isObject: isObject,
            isString: isString,
            numberFormat: init,
            objectEach: each,
            offset: function (obj) {
                var docElem = doc.documentElement;
                obj = obj.parentElement || obj.parentNode ? obj.getBoundingClientRect() : {
                    top: 0,
                    left: 0
                };
                return {
                    top: obj.top + (win.pageYOffset || docElem.scrollTop) - (docElem.clientTop || 0),
                    left: obj.left + (win.pageXOffset || docElem.scrollLeft) - (docElem.clientLeft || 0)
                };
            },
            pad: function (val, ch, s) {
                return Array((ch || 2) + 1 - String(val).replace("-", "").length).join(s || "0") + val;
            },
            pick: get,
            pInt: replace,
            relativeLength: function (value, base, useAria) {
                return /%$/.test(value) ? base * parseFloat(value) / 100 + (useAria || 0) : parseFloat(value);
            },
            setAnimation: function (options, chart) {
                chart.renderer.globalAnimation = get(options, chart.options.chart.animation, true);
            },
            splat: function (obj) {
                return isArray(obj) ? obj : [obj];
            },
            syncTimeout: function (fn, delay, context) {
                if (0 < delay) {
                    return setTimeout(fn, delay, context);
                }
                fn.call(0, context);
                return -1;
            },
            wrap: function (object, method, func) {
                var fn = object[method];
                /**
                 * @return {?}
                 */
                object[method] = function () {
                    /** @type {!Array<?>} */
                    var params = Array.prototype.slice.call(arguments);
                    /** @type {!Arguments} */
                    var args = arguments;
                    var that = this;
                    /**
                     * @return {undefined}
                     */
                    that.proceed = function () {
                        fn.apply(that, arguments.length ? arguments : args);
                    };
                    params.unshift(fn);
                    params = func.apply(this, params);
                    /** @type {null} */
                    that.proceed = null;
                    return params;
                };
            }
        };
    });
    set(x1, "parts/Color.js", [x1["parts/Globals.js"], x1["parts/Utilities.js"]], function (exports, H) {
        var isNumber = H.isNumber;
        var pInt = H.pInt;
        var parse = exports.merge;
        /**
         * @param {!Object} obj
         * @return {?}
         */
        exports.Color = function (obj) {
            if (!(this instanceof exports.Color)) {
                return new exports.Color(obj);
            }
            this.init(obj);
        };
        exports.Color.prototype = {
            parsers: [{
                regex: /rgba\(\s*([0-9]{1,3})\s*,\s*([0-9]{1,3})\s*,\s*([0-9]{1,3})\s*,\s*([0-9]?(?:\.[0-9]+)?)\s*\)/,
                parse: function (value) {
                    return [pInt(value[1]), pInt(value[2]), pInt(value[3]), parseFloat(value[4], 10)];
                }
            }, {
                regex: /rgb\(\s*([0-9]{1,3})\s*,\s*([0-9]{1,3})\s*,\s*([0-9]{1,3})\s*\)/,
                parse: function (value) {
                    return [pInt(value[1]), pInt(value[2]), pInt(value[3]), 1];
                }
            }],
            names: {
                white: "#ffffff",
                black: "#000000"
            },
            init: function (value) {
                var rgba;
                var i;
                if ((this.input = value = this.names[value && value.toLowerCase ? value.toLowerCase() : ""] || value) && value.stops) {
                    this.stops = value.stops.map(function (objBackup) {
                        return new exports.Color(objBackup[1]);
                    });
                } else {
                    if (value && value.charAt && "#" === value.charAt()) {
                        var result = value.length;
                        /** @type {number} */
                        value = parseInt(value.substr(1), 16);
                        if (7 === result) {
                            /** @type {!Array} */
                            rgba = [(value & 16711680) >> 16, (value & 65280) >> 8, value & 255, 1];
                        } else {
                            if (4 === result) {
                                /** @type {!Array} */
                                rgba = [(value & 3840) >> 4 | (value & 3840) >> 8, (value & 240) >> 4 | value & 240, (value & 15) << 4 | value & 15, 1];
                            }
                        }
                    }
                    if (!rgba) {
                        i = this.parsers.length;
                        for (; i-- && !rgba;) {
                            var parser = this.parsers[i];
                            if (result = parser.regex.exec(value)) {
                                rgba = parser.parse(result);
                            }
                        }
                    }
                }
                this.rgba = rgba || [];
            },
            get: function (name) {
                var str = this.input;
                var rgba = this.rgba;
                if (this.stops) {
                    var res = parse(str);
                    /** @type {!Array<?>} */
                    res.stops = [].concat(res.stops);
                    this.stops.forEach(function (propertyThresholdsMap, i) {
                        /** @type {!Array} */
                        res.stops[i] = [res.stops[i][0], propertyThresholdsMap.get(name)];
                    });
                } else {
                    res = rgba && isNumber(rgba[0]) ? "rgb" === name || !name && 1 === rgba[3] ? "rgb(" + rgba[0] + "," + rgba[1] + "," + rgba[2] + ")" : "a" === name ? rgba[3] : "rgba(" + rgba.join(",") + ")" : str;
                }
                return res;
            },
            brighten: function (alpha) {
                var i;
                var rgba = this.rgba;
                if (this.stops) {
                    this.stops.forEach(function (color) {
                        color.brighten(alpha);
                    });
                } else {
                    if (isNumber(alpha) && 0 !== alpha) {
                        /** @type {number} */
                        i = 0;
                        for (; 3 > i; i++) {
                            rgba[i] += pInt(255 * alpha);
                            if (0 > rgba[i]) {
                                /** @type {number} */
                                rgba[i] = 0;
                            }
                            if (255 < rgba[i]) {
                                /** @type {number} */
                                rgba[i] = 255;
                            }
                        }
                    }
                }
                return this;
            },
            setOpacity: function (alpha) {
                /** @type {number} */
                this.rgba[3] = alpha;
                return this;
            },
            tweenTo: function (to, type) {
                var typedCmds = this.rgba;
                var toText = to.rgba;
                if (toText.length && typedCmds && typedCmds.length) {
                    /** @type {boolean} */
                    to = 1 !== toText[3] || 1 !== typedCmds[3];
                    /** @type {string} */
                    type = (to ? "rgba(" : "rgb(") + Math.round(toText[0] + (typedCmds[0] - toText[0]) * (1 - type)) + "," + Math.round(toText[1] + (typedCmds[1] - toText[1]) * (1 - type)) + "," + Math.round(toText[2] + (typedCmds[2] - toText[2]) * (1 - type)) + (to ? "," + (toText[3] + (typedCmds[3] - toText[3]) * (1 - type)) : "") + ")";
                } else {
                    type = to.input || "none";
                }
                return type;
            }
        };
        /**
         * @param {?} key
         * @return {?}
         */
        exports.color = function (key) {
            return new exports.Color(key);
        };
    });
    set(x1, "parts/SvgRenderer.js", [x1["parts/Globals.js"], x1["parts/Utilities.js"]], function (H, $) {
        var map = $.animObject;
        var attr = $.attr;
        var defined = $.defined;
        var destroyObjectProperties = $.destroyObjectProperties;
        var erase = $.erase;
        var extend = $.extend;
        var fn = $.isArray;
        var isNaN = $.isNumber;
        var isObject = $.isObject;
        var isString = $.isString;
        var isArray = $.objectEach;
        var pick = $.pick;
        var pInt = $.pInt;
        var isFunction = $.splat;
        var addEvent = H.addEvent;
        var animate = H.animate;
        var charts = H.charts;
        var out = H.color;
        var css = H.css;
        var createElement = H.createElement;
        var deg2rad = H.deg2rad;
        var doc = H.doc;
        var hasTouch = H.hasTouch;
        var isFirefox = H.isFirefox;
        var isMS = H.isMS;
        var isWebKit = H.isWebKit;
        var merge = H.merge;
        var noop = H.noop;
        var removeEvent = H.removeEvent;
        var stop = H.stop;
        var svg = H.svg;
        var SVG_NS = H.SVG_NS;
        var symbolSizes = H.symbolSizes;
        var win = H.win;
        /** @type {function(): ?} */
        var SVGElement = H.SVGElement = function () {
            return this;
        };
        extend(SVGElement.prototype, {
            opacity: 1,
            SVG_NS: SVG_NS,
            textProps: "direction fontSize fontWeight fontFamily fontStyle color lineHeight width textAlign textDecoration textOverflow textOutline cursor".split(" "),
            init: function (opts, name) {
                this.element = "span" === name ? createElement(name) : doc.createElementNS(this.SVG_NS, name);
                /** @type {!Object} */
                this.renderer = opts;
                H.fireEvent(this, "afterInit");
            },
            animate: function (a, id, c) {
                var ctx = map(pick(id, this.renderer.globalAnimation, true));
                if (pick(doc.hidden, doc.msHidden, doc.webkitHidden, false)) {
                    /** @type {number} */
                    ctx.duration = 0;
                }
                if (0 !== ctx.duration) {
                    if (c) {
                        /** @type {!Function} */
                        ctx.complete = c;
                    }
                    animate(this, a, ctx);
                } else {
                    this.attr(a, void 0, c);
                    isArray(a, function (p1__3354_SHARP_, array) {
                        if (ctx.step) {
                            ctx.step.call(this, p1__3354_SHARP_, {
                                prop: array,
                                pos: 1
                            });
                        }
                    }, this);
                }
                return this;
            },
            complexColor: function (color, data, elem) {
                var renderer = this.renderer;
                var jQuery;
                var gradName;
                var gradAttr;
                var radAttr;
                var gradients;
                var gradientObject;
                var a;
                var color;
                var stopOpacity;
                var radialReference;
                var id;
                /** @type {!Array} */
                var key = [];
                var display;
                H.fireEvent(this.renderer, "complexColor", {
                    args: arguments
                }, function () {
                    if (color.radialGradient) {
                        /** @type {string} */
                        gradName = "radialGradient";
                    } else {
                        if (color.linearGradient) {
                            /** @type {string} */
                            gradName = "linearGradient";
                        }
                    }
                    if (gradName) {
                        gradAttr = color[gradName];
                        gradients = renderer.gradients;
                        a = color.stops;
                        radialReference = elem.radialReference;
                        if (fn(gradAttr)) {
                            color[gradName] = gradAttr = {
                                x1: gradAttr[0],
                                y1: gradAttr[1],
                                x2: gradAttr[2],
                                y2: gradAttr[3],
                                gradientUnits: "userSpaceOnUse"
                            };
                        }
                        if ("radialGradient" === gradName && radialReference && !defined(gradAttr.gradientUnits)) {
                            radAttr = gradAttr;
                            gradAttr = merge(gradAttr, renderer.getRadialAttr(radialReference, radAttr), {
                                gradientUnits: "userSpaceOnUse"
                            });
                        }
                        isArray(gradAttr, function (index2, background) {
                            if ("id" !== background) {
                                key.push(background, index2);
                            }
                        });
                        isArray(a, function (partialTag) {
                            key.push(partialTag);
                        });
                        key = key.join(",");
                        if (gradients[key]) {
                            id = gradients[key].attr("id");
                        } else {
                            gradAttr.id = id = H.uniqueKey();
                            gradients[key] = gradientObject = renderer.createElement(gradName).attr(gradAttr).add(renderer.defs);
                            gradientObject.radAttr = radAttr;
                            /** @type {!Array} */
                            gradientObject.stops = [];
                            a.forEach(function (args) {
                                if (0 === args[1].indexOf("rgba")) {
                                    jQuery = H.color(args[1]);
                                    color = jQuery.get("rgb");
                                    stopOpacity = jQuery.get("a");
                                } else {
                                    color = args[1];
                                    /** @type {number} */
                                    stopOpacity = 1;
                                }
                                args = renderer.createElement("stop").attr({
                                    offset: args[0],
                                    "stop-color": color,
                                    "stop-opacity": stopOpacity
                                }).add(gradientObject);
                                gradientObject.stops.push(args);
                            });
                        }
                        /** @type {string} */
                        display = "url(" + renderer.url + "#" + id + ")";
                        elem.setAttribute(data, display);
                        elem.gradient = key;
                        /**
                         * @return {?}
                         */
                        color.toString = function () {
                            return display;
                        };
                    }
                });
            },
            applyTextOutline: function (key) {
                var el = this.element;
                var size;
                if (-1 !== key.indexOf("contrast")) {
                    key = key.replace(/contrast/g, this.renderer.getContrast(el.style.fill));
                }
                key = key.split(" ");
                var color = key[key.length - 1];
                if ((size = key[0]) && "none" !== size && H.svg) {
                    /** @type {boolean} */
                    this.fakeTS = true;
                    /** @type {!Array<?>} */
                    key = [].slice.call(el.getElementsByTagName("tspan"));
                    this.ySetter = this.xSetter;
                    size = size.replace(/(^[\d\.]+)(.*?)$/g, function (a, i, phase1) {
                        return 2 * i + phase1;
                    });
                    this.removeTextOutline(key);
                    var drop = el.firstChild;
                    key.forEach(function (content, height) {
                        if (0 === height) {
                            content.setAttribute("x", el.getAttribute("x"));
                            height = el.getAttribute("y");
                            content.setAttribute("y", height || 0);
                            if (null === height) {
                                el.setAttribute("y", 0);
                            }
                        }
                        content = content.cloneNode(1);
                        attr(content, {
                            "class": "highcharts-text-outline",
                            fill: color,
                            stroke: color,
                            "stroke-width": size,
                            "stroke-linejoin": "round"
                        });
                        el.insertBefore(content, drop);
                    });
                }
            },
            removeTextOutline: function (arrays) {
                var i = arrays.length;
                var value;
                for (; i--;) {
                    value = arrays[i];
                    if ("highcharts-text-outline" === value.getAttribute("class")) {
                        erase(arrays, this.element.removeChild(value));
                    }
                }
            },
            symbolCustomAttribs: "x y width height r start end innerR anchorX anchorY rounded".split(" "),
            attr: function (name, val, a, b) {
                var element = this.element;
                var K;
                var ret = this;
                var f;
                var setter;
                var members = this.symbolCustomAttribs;
                if ("string" === typeof name && "undefined" !== typeof val) {
                    /** @type {!Object} */
                    var part = name;
                    name = {};
                    /** @type {!Object} */
                    name[part] = val;
                }
                if ("string" === typeof name) {
                    ret = (this[name + "Getter"] || this._defaultGetter).call(this, name, element);
                } else {
                    isArray(name, function (val, key) {
                        /** @type {boolean} */
                        f = false;
                        if (!b) {
                            stop(this, key);
                        }
                        if (this.symbolName && -1 !== H.inArray(key, members)) {
                            if (!K) {
                                this.symbolAttr(name);
                                /** @type {boolean} */
                                K = true;
                            }
                            /** @type {boolean} */
                            f = true;
                        }
                        if (!(!this.rotation || "x" !== key && "y" !== key)) {
                            /** @type {boolean} */
                            this.doTransform = true;
                        }
                        if (!f) {
                            setter = this[key + "Setter"] || this._defaultSetter;
                            setter.call(this, val, key, element);
                            if (!this.styledMode && this.shadows && /^(width|height|visibility|x|y|d|transform|cx|cy|r)$/.test(key)) {
                                this.updateShadows(key, val, setter);
                            }
                        }
                    }, this);
                    this.afterSetters();
                }
                if (a) {
                    a.call(this);
                }
                return ret;
            },
            afterSetters: function () {
                if (this.doTransform) {
                    this.updateTransform();
                    /** @type {boolean} */
                    this.doTransform = false;
                }
            },
            updateShadows: function (key, value, setter) {
                var shadows = this.shadows;
                var i = shadows.length;
                for (; i--;) {
                    setter.call(shadows[i], "height" === key ? Math.max(value - (shadows[i].cutHeight || 0), 0) : "d" === key ? this.d : value, key, shadows[i]);
                }
            },
            addClass: function (className, value) {
                var name = value ? "" : this.attr("class") || "";
                className = (className || "").split(/ /g).reduce(function (results, b) {
                    if (-1 === name.indexOf(b)) {
                        results.push(b);
                    }
                    return results;
                }, name ? [name] : []).join(" ");
                if (className !== name) {
                    this.attr("class", className);
                }
                return this;
            },
            hasClass: function (className) {
                return -1 !== (this.attr("class") || "").split(" ").indexOf(className);
            },
            removeClass: function (obj) {
                return this.attr("class", (this.attr("class") || "").replace(isString(obj) ? new RegExp(" ?" + obj + " ?") : obj, ""));
            },
            symbolAttr: function (hash) {
                var wrapper = this;
                "x y r start end width height innerR anchorX anchorY clockwise".split(" ").forEach(function (key) {
                    wrapper[key] = pick(hash[key], wrapper[key]);
                });
                wrapper.attr({
                    d: wrapper.renderer.symbols[wrapper.symbolName](wrapper.x, wrapper.y, wrapper.width, wrapper.height, wrapper)
                });
            },
            clip: function (key) {
                return this.attr("clip-path", key ? "url(" + this.renderer.url + "#" + key.id + ")" : "none");
            },
            crisp: function (options, width) {
                width = width || options.strokeWidth || 0;
                /** @type {number} */
                var BOTTOM_LEFT_OFFSET = Math.round(width) % 2 / 2;
                /** @type {number} */
                options.x = Math.floor(options.x || this.x || 0) + BOTTOM_LEFT_OFFSET;
                /** @type {number} */
                options.y = Math.floor(options.y || this.y || 0) + BOTTOM_LEFT_OFFSET;
                /** @type {number} */
                options.width = Math.floor((options.width || this.width || 0) - 2 * BOTTOM_LEFT_OFFSET);
                /** @type {number} */
                options.height = Math.floor((options.height || this.height || 0) - 2 * BOTTOM_LEFT_OFFSET);
                if (defined(options.strokeWidth)) {
                    /** @type {number} */
                    options.strokeWidth = width;
                }
                return options;
            },
            css: function (options) {
                var obj = this.styles;
                var d = {};
                var element = this.element;
                /** @type {string} */
                var author = "";
                /** @type {boolean} */
                var isNew = !obj;
                /** @type {!Array} */
                var knownProps = ["textOutline", "textOverflow", "width"];
                if (options && options.color) {
                    options.fill = options.color;
                }
                if (obj) {
                    isArray(options, function (val, key) {
                        if (val !== obj[key]) {
                            d[key] = val;
                            /** @type {boolean} */
                            isNew = true;
                        }
                    });
                }
                if (isNew) {
                    if (obj) {
                        options = extend(obj, d);
                    }
                    if (options) {
                        if (null === options.width || "auto" === options.width) {
                            delete this.textWidth;
                        } else {
                            if ("text" === element.nodeName.toLowerCase() && options.width) {
                                var isMS = this.textWidth = pInt(options.width);
                            }
                        }
                    }
                    /** @type {!Object} */
                    this.styles = options;
                    if (isMS && !svg && this.renderer.forExport) {
                        delete options.width;
                    }
                    if (element.namespaceURI === this.SVG_NS) {
                        /**
                         * @param {?} store
                         * @param {string} s
                         * @return {?}
                         */
                        var close = function (store, s) {
                            return "-" + s.toLowerCase();
                        };
                        isArray(options, function (a, name) {
                            if (-1 === knownProps.indexOf(name)) {
                                author = author + (name.replace(/([A-Z])/g, close) + ":" + a + ";");
                            }
                        });
                        if (author) {
                            attr(element, "style", author);
                        }
                    } else {
                        css(element, options);
                    }
                    if (this.added) {
                        if ("text" === this.element.nodeName) {
                            this.renderer.buildText(this);
                        }
                        if (options && options.textOutline) {
                            this.applyTextOutline(options.textOutline);
                        }
                    }
                }
                return this;
            },
            getStyle: function (node) {
                return win.getComputedStyle(this.element || this, "").getPropertyValue(node);
            },
            strokeWidth: function () {
                if (!this.renderer.styledMode) {
                    return this["stroke-width"] || 0;
                }
                var val = this.getStyle("stroke-width");
                /** @type {number} */
                var ret = 0;
                if (val.indexOf("px") === val.length - 2) {
                    ret = pInt(val);
                } else {
                    if ("" !== val) {
                        var box = doc.createElementNS(SVG_NS, "rect");
                        attr(box, {
                            width: val,
                            "stroke-width": 0
                        });
                        this.element.parentNode.appendChild(box);
                        ret = box.getBBox().width;
                        box.parentNode.removeChild(box);
                    }
                }
                return ret;
            },
            on: function (eventType, fn) {
                var svgElement = this;
                var element = svgElement.element;
                if (hasTouch && "click" === eventType) {
                    /**
                     * @param {!Event} event
                     * @return {undefined}
                     */
                    element.ontouchstart = function (event) {
                        /** @type {number} */
                        svgElement.touchEventFired = Date.now();
                        event.preventDefault();
                        fn.call(element, event);
                    };
                    /**
                     * @param {?} event
                     * @return {undefined}
                     */
                    element.onclick = function (event) {
                        if (-1 === win.navigator.userAgent.indexOf("Android") || 1100 < Date.now() - (svgElement.touchEventFired || 0)) {
                            fn.call(element, event);
                        }
                    };
                } else {
                    /** @type {!Function} */
                    element["on" + eventType] = fn;
                }
                return this;
            },
            setRadialReference: function (coordinates) {
                var existingGradient = this.renderer.gradients[this.element.gradient];
                /** @type {!Array} */
                this.element.radialReference = coordinates;
                if (existingGradient && existingGradient.radAttr) {
                    existingGradient.animate(this.renderer.getRadialAttr(coordinates, existingGradient.radAttr));
                }
                return this;
            },
            translate: function (x, top) {
                return this.attr({
                    translateX: x,
                    translateY: top
                });
            },
            invert: function (inverted) {
                /** @type {boolean} */
                this.inverted = inverted;
                this.updateTransform();
                return this;
            },
            updateTransform: function () {
                var tw = this.translateX || 0;
                var top = this.translateY || 0;
                var scaleX = this.scaleX;
                var scaleY = this.scaleY;
                var inverted = this.inverted;
                var mat = this.rotation;
                var transform = this.matrix;
                var element = this.element;
                if (inverted) {
                    tw = tw + this.width;
                    top = top + this.height;
                }
                /** @type {!Array} */
                tw = ["translate(" + tw + "," + top + ")"];
                if (defined(transform)) {
                    tw.push("matrix(" + transform.join(",") + ")");
                }
                if (inverted) {
                    tw.push("rotate(90) scale(-1,1)");
                } else {
                    if (mat) {
                        tw.push("rotate(" + mat + " " + pick(this.rotationOriginX, element.getAttribute("x"), 0) + " " + pick(this.rotationOriginY, element.getAttribute("y") || 0) + ")");
                    }
                }
                if (defined(scaleX) || defined(scaleY)) {
                    tw.push("scale(" + pick(scaleX, 1) + " " + pick(scaleY, 1) + ")");
                }
                if (tw.length) {
                    element.setAttribute("transform", tw.join(" "));
                }
            },
            toFront: function () {
                var e = this.element;
                e.parentNode.appendChild(e);
                return this;
            },
            align: function (obj, x, value) {
                var alignTo;
                var attribs = {};
                var target = this.renderer;
                var y = target.alignedObjects;
                var num;
                var sampleRate;
                if (obj) {
                    if (this.alignOptions = obj, this.alignByTranslate = x, !value || isString(value)) {
                        this.alignTo = alignTo = value || "renderer";
                        erase(y, this);
                        y.push(this);
                        /** @type {null} */
                        value = null;
                    }
                } else {
                    obj = this.alignOptions;
                    x = this.alignByTranslate;
                    alignTo = this.alignTo;
                }
                value = pick(value, target[alignTo], target);
                alignTo = obj.align;
                target = obj.verticalAlign;
                y = (value.x || 0) + (obj.x || 0);
                var w = (value.y || 0) + (obj.y || 0);
                if ("right" === alignTo) {
                    /** @type {number} */
                    num = 1;
                } else {
                    if ("center" === alignTo) {
                        /** @type {number} */
                        num = 2;
                    }
                }
                if (num) {
                    y = y + (value.width - (obj.width || 0)) / num;
                }
                /** @type {number} */
                attribs[x ? "translateX" : "x"] = Math.round(y);
                if ("bottom" === target) {
                    /** @type {number} */
                    sampleRate = 1;
                } else {
                    if ("middle" === target) {
                        /** @type {number} */
                        sampleRate = 2;
                    }
                }
                if (sampleRate) {
                    w = w + (value.height - (obj.height || 0)) / sampleRate;
                }
                /** @type {number} */
                attribs[x ? "translateY" : "y"] = Math.round(w);
                this[this.placed ? "animate" : "attr"](attribs);
                /** @type {boolean} */
                this.placed = true;
                this.alignAttr = attribs;
                return this;
            },
            getBBox: function (height, rotation) {
                var data;
                var r = this.renderer;
                var element = this.element;
                var e = this.styles;
                var Xutm = this.textStr;
                var toggleTextShadowShim;
                var o = r.cache;
                var p = r.cacheKeys;
                /** @type {boolean} */
                var atVersion = element.namespaceURI === this.SVG_NS;
                rotation = pick(rotation, this.rotation, 0);
                var CredentialScope = r.styledMode ? element && SVGElement.prototype.getStyle.call(element, "font-size") : e && e.fontSize;
                if (defined(Xutm)) {
                    var name = Xutm.toString();
                    if (-1 === name.indexOf("<")) {
                        name = name.replace(/[0-9]/g, "0");
                    }
                    /** @type {string} */
                    name = name + ["", rotation, CredentialScope, this.textWidth, e && e.textOverflow].join();
                }
                if (name && !height) {
                    data = o[name];
                }
                if (!data) {
                    if (atVersion || r.forExport) {
                        try {
                            if (toggleTextShadowShim = this.fakeTS && function (val) {
                                [].forEach.call(element.querySelectorAll(".highcharts-text-outline"), function (builderID) {
                                    /** @type {string} */
                                    builderID.style.display = val;
                                });
                            }) {
                                toggleTextShadowShim("none");
                            }
                            data = element.getBBox ? extend({}, element.getBBox()) : {
                                width: element.offsetWidth,
                                height: element.offsetHeight
                            };
                            if (toggleTextShadowShim) {
                                toggleTextShadowShim("");
                            }
                        } catch (ca) {
                            "";
                        }
                        if (!data || 0 > data.width) {
                            data = {
                                width: 0,
                                height: 0
                            };
                        }
                    } else {
                        data = this.htmlGetBBox();
                    }
                    if (r.isSVG) {
                        height = data.width;
                        r = data.height;
                        if (atVersion) {
                            data.height = r = {
                                "11px,17": 14,
                                "13px,20": 16
                            }[e && e.fontSize + "," + Math.round(r)] || r;
                        }
                        if (rotation) {
                            /** @type {number} */
                            e = rotation * deg2rad;
                            /** @type {number} */
                            data.width = Math.abs(r * Math.sin(e)) + Math.abs(height * Math.cos(e));
                            /** @type {number} */
                            data.height = Math.abs(r * Math.cos(e)) + Math.abs(height * Math.sin(e));
                        }
                    }
                    if (name && 0 < data.height) {
                        for (; 250 < p.length;) {
                            delete o[p.shift()];
                        }
                        if (!o[name]) {
                            p.push(name);
                        }
                        o[name] = data;
                    }
                }
                return data;
            },
            show: function (inherit) {
                return this.attr({
                    visibility: inherit ? "inherit" : "visible"
                });
            },
            hide: function (delay) {
                if (delay) {
                    this.attr({
                        y: -9999
                    });
                } else {
                    this.attr({
                        visibility: "hidden"
                    });
                }
                return this;
            },
            fadeOut: function (duration) {
                var el = this;
                el.animate({
                    opacity: 0
                }, {
                    duration: duration || 150,
                    complete: function () {
                        el.attr({
                            y: -9999
                        });
                    }
                });
            },
            add: function (parent) {
                var renderer = this.renderer;
                var buttongroup = this.element;
                if (parent) {
                    /** @type {!Object} */
                    this.parentGroup = parent;
                }
                this.parentInverted = parent && parent.inverted;
                if ("undefined" !== typeof this.textStr) {
                    renderer.buildText(this);
                }
                /** @type {boolean} */
                this.added = true;
                if (!parent || parent.handleZ || this.zIndex) {
                    var n = this.zIndexSetter();
                }
                if (!n) {
                    (parent ? parent.element : renderer.box).appendChild(buttongroup);
                }
                if (this.onAdd) {
                    this.onAdd();
                }
                return this;
            },
            safeRemoveChild: function (element) {
                var paren = element.parentNode;
                if (paren) {
                    paren.removeChild(element);
                }
            },
            destroy: function () {
                var wrapper = this;
                var element = wrapper.element || {};
                var renderer = wrapper.renderer;
                var parentToClean = renderer.isSVG && "SPAN" === element.nodeName && wrapper.parentGroup;
                var i = element.ownerSVGElement;
                var e = wrapper.clipPath;
                /** @type {null} */
                element.onclick = element.onmouseout = element.onmouseover = element.onmousemove = element.point = null;
                stop(wrapper);
                if (e && i) {
                    [].forEach.call(i.querySelectorAll("[clip-path],[CLIP-PATH]"), function (s) {
                        if (-1 < s.getAttribute("clip-path").indexOf(e.element.id)) {
                            s.removeAttribute("clip-path");
                        }
                    });
                    wrapper.clipPath = e.destroy();
                }
                if (wrapper.stops) {
                    /** @type {number} */
                    i = 0;
                    for (; i < wrapper.stops.length; i++) {
                        wrapper.stops[i] = wrapper.stops[i].destroy();
                    }
                    /** @type {null} */
                    wrapper.stops = null;
                }
                wrapper.safeRemoveChild(element);
                if (!renderer.styledMode) {
                    wrapper.destroyShadows();
                }
                for (; parentToClean && parentToClean.div && 0 === parentToClean.div.childNodes.length;) {
                    element = parentToClean.parentGroup;
                    wrapper.safeRemoveChild(parentToClean.div);
                    delete parentToClean.div;
                    parentToClean = element;
                }
                if (wrapper.alignTo) {
                    erase(renderer.alignedObjects, wrapper);
                }
                isArray(wrapper, function (b, i) {
                    if (wrapper[i] && wrapper[i].parentGroup === wrapper && wrapper[i].destroy) {
                        wrapper[i].destroy();
                    }
                    delete wrapper[i];
                });
            },
            shadow: function (options, group, cutOff) {
                /** @type {!Array} */
                var shadows = [];
                var i;
                var table = this.element;
                if (!options) {
                    this.destroyShadows();
                } else {
                    if (!this.shadows) {
                        var newMax = pick(options.width, 3);
                        /** @type {number} */
                        var shadowElementOpacity = (options.opacity || .15) / newMax;
                        /** @type {string} */
                        var transform = this.parentInverted ? "(-1,-1)" : "(" + pick(options.offsetX, 1) + ", " + pick(options.offsetY, 1) + ")";
                        /** @type {number} */
                        i = 1;
                        for (; i <= newMax; i++) {
                            var shadow = table.cloneNode(0);
                            /** @type {number} */
                            var strokeWidth = 2 * newMax + 1 - 2 * i;
                            attr(shadow, {
                                stroke: options.color || "#000000",
                                "stroke-opacity": shadowElementOpacity * i,
                                "stroke-width": strokeWidth,
                                transform: "translate" + transform,
                                fill: "none"
                            });
                            shadow.setAttribute("class", (shadow.getAttribute("class") || "") + " highcharts-shadow");
                            if (cutOff) {
                                attr(shadow, "height", Math.max(attr(shadow, "height") - strokeWidth, 0));
                                /** @type {number} */
                                shadow.cutHeight = strokeWidth;
                            }
                            if (group) {
                                group.element.appendChild(shadow);
                            } else {
                                if (table.parentNode) {
                                    table.parentNode.insertBefore(shadow, table);
                                }
                            }
                            shadows.push(shadow);
                        }
                        /** @type {!Array} */
                        this.shadows = shadows;
                    }
                }
                return this;
            },
            destroyShadows: function () {
                (this.shadows || []).forEach(function (shadow) {
                    this.safeRemoveChild(shadow);
                }, this);
                this.shadows = void 0;
            },
            xGetter: function (key) {
                if ("circle" === this.element.nodeName) {
                    if ("x" === key) {
                        /** @type {string} */
                        key = "cx";
                    } else {
                        if ("y" === key) {
                            /** @type {string} */
                            key = "cy";
                        }
                    }
                }
                return this._defaultGetter(key);
            },
            _defaultGetter: function (key) {
                key = pick(this[key + "Value"], this[key], this.element ? this.element.getAttribute(key) : null, 0);
                if (/^[\-0-9\.]+$/.test(key)) {
                    /** @type {number} */
                    key = parseFloat(key);
                }
                return key;
            },
            dSetter: function (value, key, element) {
                if (value && value.join) {
                    value = value.join(" ");
                }
                if (/(NaN| {2}|^$)/.test(value)) {
                    /** @type {string} */
                    value = "M 0 0";
                }
                if (this[key] !== value) {
                    element.setAttribute(key, value);
                    /** @type {string} */
                    this[key] = value;
                }
            },
            dashstyleSetter: function (value) {
                var i;
                var strokeWidth = this["stroke-width"];
                if ("inherit" === strokeWidth) {
                    /** @type {number} */
                    strokeWidth = 1;
                }
                if (value = value && value.toLowerCase()) {
                    value = value.replace("shortdashdotdot", "3,1,1,1,1,1,").replace("shortdashdot", "3,1,1,1").replace("shortdot", "1,1,").replace("shortdash", "3,1,").replace("longdash", "8,3,").replace(/dot/g, "1,3,").replace("dash", "4,3,").replace(/,$/, "").split(",");
                    i = value.length;
                    for (; i--;) {
                        /** @type {number} */
                        value[i] = pInt(value[i]) * strokeWidth;
                    }
                    value = value.join(",").replace(/NaN/g, "none");
                    this.element.setAttribute("stroke-dasharray", value);
                }
            },
            alignSetter: function (value) {
                var convert = {
                    left: "start",
                    center: "middle",
                    right: "end"
                };
                if (convert[value]) {
                    this.alignValue = value;
                    this.element.setAttribute("text-anchor", convert[value]);
                }
            },
            opacitySetter: function (value, element, key) {
                this[element] = value;
                key.setAttribute(element, value);
            },
            titleSetter: function (value) {
                var titleNode = this.element.getElementsByTagName("title")[0];
                if (!titleNode) {
                    titleNode = doc.createElementNS(this.SVG_NS, "title");
                    this.element.appendChild(titleNode);
                }
                if (titleNode.firstChild) {
                    titleNode.removeChild(titleNode.firstChild);
                }
                titleNode.appendChild(doc.createTextNode(String(pick(value, "")).replace(/<[^>]*>/g, "").replace(/&lt;/g, "<").replace(/&gt;/g, ">")));
            },
            textSetter: function (value) {
                if (value !== this.textStr) {
                    delete this.bBox;
                    delete this.textPxLength;
                    /** @type {string} */
                    this.textStr = value;
                    if (this.added) {
                        this.renderer.buildText(this);
                    }
                }
            },
            setTextPath: function (options, val) {
                var element = this.element;
                var attrToProp = {
                    textAnchor: "text-anchor"
                };
                /** @type {boolean} */
                var g = false;
                var data = this.textPathWrapper;
                /** @type {boolean} */
                var offer = !data;
                val = merge(true, {
                    enabled: true,
                    attributes: {
                        dy: -5,
                        startOffset: "50%",
                        textAnchor: "middle"
                    }
                }, val);
                var args = val.attributes;
                if (options && val && val.enabled) {
                    if (data && null === data.element.parentNode) {
                        /** @type {boolean} */
                        offer = true;
                        data = data.destroy();
                    } else {
                        if (data) {
                            this.removeTextOutline.call(data.parentGroup, [].slice.call(element.getElementsByTagName("tspan")));
                        }
                    }
                    if (this.options && this.options.padding) {
                        /** @type {number} */
                        args.dx = -this.options.padding;
                    }
                    if (!data) {
                        this.textPathWrapper = data = this.renderer.createElement("textPath");
                        /** @type {boolean} */
                        g = true;
                    }
                    var el = data.element;
                    if (!(val = options.element.getAttribute("id"))) {
                        options.element.setAttribute("id", val = H.uniqueKey());
                    }
                    if (offer) {
                        options = element.getElementsByTagName("tspan");
                        for (; options.length;) {
                            options[0].setAttribute("y", 0);
                            if (isNaN(args.dx)) {
                                options[0].setAttribute("x", -args.dx);
                            }
                            el.appendChild(options[0]);
                        }
                    }
                    if (g) {
                        data.add({
                            element: this.text ? this.text.element : element
                        });
                    }
                    el.setAttributeNS("http://www.w3.org/1999/xlink", "href", this.renderer.url + "#" + val);
                    if (defined(args.dy)) {
                        el.parentNode.setAttribute("dy", args.dy);
                        delete args.dy;
                    }
                    if (defined(args.dx)) {
                        el.parentNode.setAttribute("dx", args.dx);
                        delete args.dx;
                    }
                    isArray(args, function (uniqueClassId, name) {
                        el.setAttribute(attrToProp[name] || name, uniqueClassId);
                    });
                    element.removeAttribute("transform");
                    this.removeTextOutline.call(data, [].slice.call(element.getElementsByTagName("tspan")));
                    if (this.text && !this.renderer.styledMode) {
                        this.attr({
                            fill: "none",
                            "stroke-width": 0
                        });
                    }
                    this.applyTextOutline = this.updateTransform = noop;
                } else {
                    if (data) {
                        delete this.updateTransform;
                        delete this.applyTextOutline;
                        this.destroyTextPath(element, options);
                        this.updateTransform();
                        if (this.options.rotation) {
                            this.applyTextOutline(this.options.style.textOutline);
                        }
                    }
                }
                return this;
            },
            destroyTextPath: function (child, canvas) {
                var node = child.getElementsByTagName("text")[0];
                if (node) {
                    if (node.removeAttribute("dx"), node.removeAttribute("dy"), canvas.element.setAttribute("id", ""), node.getElementsByTagName("textPath").length) {
                        child = this.textPathWrapper.element.childNodes;
                        for (; child.length;) {
                            node.appendChild(child[0]);
                        }
                        node.removeChild(this.textPathWrapper.element);
                    }
                } else {
                    if (child.getAttribute("dx") || child.getAttribute("dy")) {
                        child.removeAttribute("dx");
                        child.removeAttribute("dy");
                    }
                }
                this.textPathWrapper = this.textPathWrapper.destroy();
            },
            fillSetter: function (value, element, color) {
                if ("string" === typeof value) {
                    color.setAttribute(element, value);
                } else {
                    if (value) {
                        this.complexColor(value, element, color);
                    }
                }
            },
            visibilitySetter: function (value, key, element) {
                if ("inherit" === value) {
                    element.removeAttribute(key);
                } else {
                    if (this[key] !== value) {
                        element.setAttribute(key, value);
                    }
                }
                /** @type {string} */
                this[key] = value;
            },
            zIndexSetter: function (value, a) {
                var renderer = this.renderer;
                var parent = this.parentGroup;
                var element = (parent || renderer).element || renderer.box;
                var div = this.element;
                /** @type {boolean} */
                var inserted = false;
                /** @type {boolean} */
                renderer = element === renderer.box;
                var radius = this.added;
                var i;
                if (defined(value)) {
                    div.setAttribute("data-z-index", value);
                    /** @type {number} */
                    value = +value;
                    if (this[a] === value) {
                        /** @type {boolean} */
                        radius = false;
                    }
                } else {
                    if (defined(this[a])) {
                        div.removeAttribute("data-z-index");
                    }
                }
                /** @type {number} */
                this[a] = value;
                if (radius) {
                    if ((value = this.zIndex) && parent) {
                        /** @type {boolean} */
                        parent.handleZ = true;
                    }
                    a = element.childNodes;
                    /** @type {number} */
                    i = a.length - 1;
                    for (; 0 <= i && !inserted; i--) {
                        parent = a[i];
                        radius = parent.getAttribute("data-z-index");
                        /** @type {boolean} */
                        var _powerSaveEnabled = !defined(radius);
                        if (parent !== div) {
                            if (0 > value && _powerSaveEnabled && !renderer && !i) {
                                element.insertBefore(div, a[i]);
                                /** @type {boolean} */
                                inserted = true;
                            } else {
                                if (pInt(radius) <= value || _powerSaveEnabled && (!defined(value) || 0 <= value)) {
                                    element.insertBefore(div, a[i + 1] || null);
                                    /** @type {boolean} */
                                    inserted = true;
                                }
                            }
                        }
                    }
                    if (!inserted) {
                        element.insertBefore(div, a[renderer ? 3 : 0] || null);
                        /** @type {boolean} */
                        inserted = true;
                    }
                }
                return inserted;
            },
            _defaultSetter: function (key, element, value) {
                value.setAttribute(element, key);
            }
        });
        SVGElement.prototype.yGetter = SVGElement.prototype.xGetter;
        /** @type {function(?, ?): undefined} */
        SVGElement.prototype.translateXSetter = SVGElement.prototype.translateYSetter = SVGElement.prototype.rotationSetter = SVGElement.prototype.verticalAlignSetter = SVGElement.prototype.rotationOriginXSetter = SVGElement.prototype.rotationOriginYSetter = SVGElement.prototype.scaleXSetter = SVGElement.prototype.scaleYSetter = SVGElement.prototype.matrixSetter = function (originalItem, i) {
            this[i] = originalItem;
            /** @type {boolean} */
            this.doTransform = true;
        };
        /** @type {function(number, string, !Element): undefined} */
        SVGElement.prototype["stroke-widthSetter"] = SVGElement.prototype.strokeSetter = function (key, value, element) {
            /** @type {number} */
            this[value] = key;
            if (this.stroke && this["stroke-width"]) {
                SVGElement.prototype.fillSetter.call(this, this.stroke, "stroke", element);
                element.setAttribute("stroke-width", this["stroke-width"]);
                /** @type {boolean} */
                this.hasStroke = true;
            } else {
                if ("stroke-width" === value && 0 === key && this.hasStroke) {
                    element.removeAttribute("stroke");
                    /** @type {boolean} */
                    this.hasStroke = false;
                } else {
                    if (this.renderer.styledMode && this["stroke-width"]) {
                        element.setAttribute("stroke-width", this["stroke-width"]);
                        /** @type {boolean} */
                        this.hasStroke = true;
                    }
                }
            }
        };
        /** @type {function(): undefined} */
        $ = H.SVGRenderer = function () {
            this.init.apply(this, arguments);
        };
        extend($.prototype, {
            Element: SVGElement,
            SVG_NS: SVG_NS,
            init: function (el, callback, size, element, options, state, sprites) {
                var result = this.createElement("svg").attr({
                    version: "1.1",
                    "class": "highcharts-root"
                });
                if (!sprites) {
                    result.css(this.getStyle(element));
                }
                element = result.element;
                el.appendChild(element);
                attr(el, "dir", "ltr");
                if (-1 === el.innerHTML.indexOf("xmlns")) {
                    attr(element, "xmlns", this.SVG_NS);
                }
                /** @type {boolean} */
                this.isSVG = true;
                /** @type {string} */
                this.box = element;
                this.boxWrapper = result;
                /** @type {!Array} */
                this.alignedObjects = [];
                this.url = (isFirefox || isWebKit) && doc.getElementsByTagName("base").length ? win.location.href.split("#")[0].replace(/<[^>]*>/g, "").replace(/([\('\)])/g, "\\$1").replace(/ /g, "%20") : "";
                this.createElement("desc").add().element.appendChild(doc.createTextNode("Created with Highcharts 8.0.0"));
                this.defs = this.createElement("defs").add();
                /** @type {boolean} */
                this.allowHTML = state;
                this.forExport = options;
                this.styledMode = sprites;
                this.gradients = {};
                this.cache = {};
                /** @type {!Array} */
                this.cacheKeys = [];
                /** @type {number} */
                this.imgCount = 0;
                this.setSize(callback, size, false);
                var $activeCellOffset;
                if (isFirefox && el.getBoundingClientRect) {
                    /**
                     * @return {undefined}
                     */
                    callback = function () {
                        css(el, {
                            left: 0,
                            top: 0
                        });
                        $activeCellOffset = el.getBoundingClientRect();
                        css(el, {
                            left: Math.ceil($activeCellOffset.left) - $activeCellOffset.left + "px",
                            top: Math.ceil($activeCellOffset.top) - $activeCellOffset.top + "px"
                        });
                    };
                    callback();
                    this.unSubPixelFix = addEvent(win, "resize", callback);
                }
            },
            definition: function (callback) {
                /**
                 * @param {!Object} fn
                 * @param {string} parent
                 * @return {?}
                 */
                function recurse(fn, parent) {
                    var text;
                    isFunction(fn).forEach(function (item) {
                        var node = ren.createElement(item.tagName);
                        var data = {};
                        isArray(item, function (template, input) {
                            if ("tagName" !== input && "children" !== input && "textContent" !== input) {
                                data[input] = template;
                            }
                        });
                        node.attr(data);
                        node.add(parent || ren.defs);
                        if (item.textContent) {
                            node.element.appendChild(doc.createTextNode(item.textContent));
                        }
                        recurse(item.children || [], node);
                        text = node;
                    });
                    return text;
                }
                var ren = this;
                return recurse(callback);
            },
            getStyle: function (style) {
                return this.style = extend({
                    fontFamily: '"Lucida Grande", "Lucida Sans Unicode", Arial, Helvetica, sans-serif',
                    fontSize: "12px"
                }, style);
            },
            setStyle: function (style) {
                this.boxWrapper.css(this.getStyle(style));
            },
            isHidden: function () {
                return !this.boxWrapper.getBBox().width;
            },
            destroy: function () {
                var defs = this.defs;
                /** @type {null} */
                this.box = null;
                this.boxWrapper = this.boxWrapper.destroy();
                destroyObjectProperties(this.gradients || {});
                /** @type {null} */
                this.gradients = null;
                if (defs) {
                    this.defs = defs.destroy();
                }
                if (this.unSubPixelFix) {
                    this.unSubPixelFix();
                }
                return this.alignedObjects = null;
            },
            createElement: function (name) {
                var wrapper = new this.Element;
                wrapper.init(this, name);
                return wrapper;
            },
            draw: noop,
            getRadialAttr: function (radialReference, gradAttr) {
                return {
                    cx: radialReference[0] - radialReference[2] / 2 + gradAttr.cx * radialReference[2],
                    cy: radialReference[1] - radialReference[2] / 2 + gradAttr.cy * radialReference[2],
                    r: gradAttr.r * radialReference[2]
                };
            },
            truncate: function (target, item, root, obj, i, value, $) {
                var renderer = this;
                var rotation = target.rotation;
                var p;
                /** @type {number} */
                var name = obj ? 1 : 0;
                var n = (root || obj).length;
                var c = n;
                /** @type {!Array} */
                var exports = [];
                /**
                 * @param {string} message
                 * @return {undefined}
                 */
                var assert = function (message) {
                    if (item.firstChild) {
                        item.removeChild(item.firstChild);
                    }
                    if (message) {
                        item.appendChild(doc.createTextNode(message));
                    }
                };
                /**
                 * @param {number} input
                 * @param {number} key
                 * @return {?}
                 */
                var error = function (input, key) {
                    key = key || input;
                    if ("undefined" === typeof exports[key]) {
                        if (item.getSubStringLength) {
                            try {
                                exports[key] = i + item.getSubStringLength(0, obj ? key + 1 : key);
                            } catch (ea) {
                                "";
                            }
                        } else {
                            if (renderer.getSpanWidth) {
                                assert($(root || obj, input));
                                exports[key] = i + renderer.getSpanWidth(target, item);
                            }
                        }
                    }
                    return exports[key];
                };
                var isBigger;
                /** @type {number} */
                target.rotation = 0;
                var result = error(item.textContent.length);
                if (isBigger = i + result > value) {
                    for (; name <= n;) {
                        /** @type {number} */
                        c = Math.ceil((name + n) / 2);
                        if (obj) {
                            p = $(obj, c);
                        }
                        result = error(c, p && p.length - 1);
                        if (name === n) {
                            name = n + 1;
                        } else {
                            if (result > value) {
                                /** @type {number} */
                                n = c - 1;
                            } else {
                                /** @type {number} */
                                name = c;
                            }
                        }
                    }
                    if (0 === n) {
                        assert("");
                    } else {
                        if (!(root && n === root.length - 1)) {
                            assert(p || $(root || obj, c));
                        }
                    }
                }
                if (obj) {
                    obj.splice(0, c);
                }
                target.actualWidth = result;
                target.rotation = rotation;
                return isBigger;
            },
            escapes: {
                "&": "&amp;",
                "<": "&lt;",
                ">": "&gt;",
                "'": "&#39;",
                '"': "&quot;"
            },
            buildText: function (wrapper) {
                var textNode = wrapper.element;
                var renderer = this;
                var forExport = renderer.forExport;
                var value = pick(wrapper.textStr, "").toString();
                /** @type {boolean} */
                var condition = -1 !== value.indexOf("<");
                var childNodes = textNode.childNodes;
                var results;
                var parentX = attr(textNode, "x");
                var textStyles = wrapper.styles;
                var width = wrapper.textWidth;
                var textLineHeight = textStyles && textStyles.lineHeight;
                var a = textStyles && textStyles.textOutline;
                var ellipsis = textStyles && "ellipsis" === textStyles.textOverflow;
                var noWrap = textStyles && "nowrap" === textStyles.whiteSpace;
                var fontSize = textStyles && textStyles.fontSize;
                var lastIndex;
                var i = childNodes.length;
                textStyles = width && !wrapper.added && this.box;
                /**
                 * @param {!Object} tspan
                 * @return {?}
                 */
                var getLineHeight = function (tspan) {
                    var fontSizeStyle;
                    if (!renderer.styledMode) {
                        fontSizeStyle = /(px|em)$/.test(tspan && tspan.style.fontSize) ? tspan.style.fontSize : fontSize || renderer.style.fontSize || 12;
                    }
                    return textLineHeight ? pInt(textLineHeight) : renderer.fontMetrics(fontSizeStyle, tspan.getAttribute("style") ? tspan : textNode).h;
                };
                /**
                 * @param {?} template
                 * @param {!Object} dict
                 * @return {?}
                 */
                var substitute = function (template, dict) {
                    isArray(renderer.escapes, function (keyword, toc) {
                        if (!(dict && -1 !== dict.indexOf(keyword))) {
                            template = template.toString().replace(new RegExp(keyword, "g"), toc);
                        }
                    });
                    return template;
                };
                /**
                 * @param {string} args
                 * @param {string} name
                 * @return {?}
                 */
                var format = function (args, name) {
                    var i = args.indexOf("<");
                    args = args.substring(i, args.indexOf(">") - i);
                    i = args.indexOf(name + "=");
                    if (-1 !== i && (i = i + name.length + 1, name = args.charAt(i), '"' === name || "'" === name)) {
                        return args = args.substring(i + 1), args.substring(0, args.indexOf(name));
                    }
                };
                /** @type {!RegExp} */
                var T = /<br.*?>/g;
                /** @type {string} */
                var textCache = [value, ellipsis, noWrap, textLineHeight, a, fontSize, width].join();
                if (textCache !== wrapper.textCache) {
                    /** @type {string} */
                    wrapper.textCache = textCache;
                    for (; i--;) {
                        textNode.removeChild(childNodes[i]);
                    }
                    if (condition || a || ellipsis || width || -1 !== value.indexOf(" ") && (!noWrap || T.test(value))) {
                        if (textStyles) {
                            textStyles.appendChild(textNode);
                        }
                        if (condition) {
                            value = renderer.styledMode ? value.replace(/<(b|strong)>/g, '<span class="highcharts-strong">').replace(/<(i|em)>/g, '<span class="highcharts-emphasized">') : value.replace(/<(b|strong)>/g, '<span style="font-weight:bold">').replace(/<(i|em)>/g, '<span style="font-style:italic">');
                            value = value.replace(/<a/g, "<span").replace(/<\/(b|strong|i|em|a)>/g, "</span>").split(T);
                        } else {
                            /** @type {!Array} */
                            value = [value];
                        }
                        value = value.filter(function (value) {
                            return "" !== value;
                        });
                        value.forEach(function (morpheme, boardManager) {
                            /** @type {number} */
                            var isMatchesSelector = 0;
                            /** @type {number} */
                            var left = 0;
                            morpheme = morpheme.replace(/^\s+|\s+$/g, "").replace(/<span/g, "|||<span").replace(/<\/span>/g, "</span>|||");
                            var deprecatedStylingMethods = morpheme.split("|||");
                            deprecatedStylingMethods.forEach(function (i) {
                                if ("" !== i || 1 === deprecatedStylingMethods.length) {
                                    var attributes = {};
                                    var node = doc.createElementNS(renderer.SVG_NS, "tspan");
                                    var name;
                                    var path;
                                    if (name = format(i, "class")) {
                                        attr(node, "class", name);
                                    }
                                    if (name = format(i, "style")) {
                                        name = name.replace(/(;| |^)color([ :])/, "$1fill$2");
                                        attr(node, "style", name);
                                    }
                                    if ((path = format(i, "href")) && !forExport) {
                                        attr(node, "onclick", 'location.href="' + path + '"');
                                        attr(node, "class", "highcharts-anchor");
                                        if (!renderer.styledMode) {
                                            css(node, {
                                                cursor: "pointer"
                                            });
                                        }
                                    }
                                    i = substitute(i.replace(/<[a-zA-Z\/](.|\n)*?>/g, "") || " ");
                                    if (" " !== i) {
                                        node.appendChild(doc.createTextNode(i));
                                        if (isMatchesSelector) {
                                            /** @type {number} */
                                            attributes.dx = 0;
                                        } else {
                                            if (boardManager && null !== parentX) {
                                                attributes.x = parentX;
                                            }
                                        }
                                        attr(node, attributes);
                                        textNode.appendChild(node);
                                        if (!isMatchesSelector && lastIndex) {
                                            if (!svg && forExport) {
                                                css(node, {
                                                    display: "block"
                                                });
                                            }
                                            attr(node, "dy", getLineHeight(node));
                                        }
                                        if (width) {
                                            var data = i.replace(/([^\^])-/g, "$1- ").split(" ");
                                            attributes = !noWrap && (1 < deprecatedStylingMethods.length || boardManager || 1 < data.length);
                                            /** @type {number} */
                                            path = 0;
                                            var dy = getLineHeight(node);
                                            if (ellipsis) {
                                                results = renderer.truncate(wrapper, node, i, void 0, 0, Math.max(0, width - parseInt(fontSize || 12, 10)), function (a, b) {
                                                    return a.substring(0, b) + "\u2026";
                                                });
                                            } else {
                                                if (attributes) {
                                                    for (; data.length;) {
                                                        if (data.length && !noWrap && 0 < path) {
                                                            node = doc.createElementNS(SVG_NS, "tspan");
                                                            attr(node, {
                                                                dy: dy,
                                                                x: parentX
                                                            });
                                                            if (name) {
                                                                attr(node, "style", name);
                                                            }
                                                            node.appendChild(doc.createTextNode(data.join(" ").replace(/- /g, "-")));
                                                            textNode.appendChild(node);
                                                        }
                                                        renderer.truncate(wrapper, node, null, data, 0 === path ? left : 0, width, function (a, b) {
                                                            return data.slice(0, b).join(" ").replace(/- /g, "-");
                                                        });
                                                        left = wrapper.actualWidth;
                                                        path++;
                                                    }
                                                }
                                            }
                                        }
                                        isMatchesSelector++;
                                    }
                                }
                            });
                            lastIndex = lastIndex || textNode.childNodes.length;
                        });
                        if (ellipsis && results) {
                            wrapper.attr("title", substitute(wrapper.textStr, ["&lt;", "&gt;"]));
                        }
                        if (textStyles) {
                            textStyles.removeChild(textNode);
                        }
                        if (a && wrapper.applyTextOutline) {
                            wrapper.applyTextOutline(a);
                        }
                    } else {
                        textNode.appendChild(doc.createTextNode(substitute(value)));
                    }
                }
            },
            getContrast: function (color) {
                color = out(color).rgba;
                color[0] *= 1;
                color[1] *= 1.2;
                color[2] *= .5;
                return 459 < color[0] + color[1] + color[2] ? "#000000" : "#FFFFFF";
            },
            button: function (name, x, y, callback, normalState, hoverState, pressedState, disabledState, shape, text) {
                var label = this.label(name, x, y, shape, null, null, text, null, "button");
                /** @type {number} */
                var curState = 0;
                var N = this.styledMode;
                label.attr(merge({
                    padding: 8,
                    r: 2
                }, normalState));
                if (!N) {
                    normalState = merge({
                        fill: "#f7f7f7",
                        stroke: "#cccccc",
                        "stroke-width": 1,
                        style: {
                            color: "#333333",
                            cursor: "pointer",
                            fontWeight: "normal"
                        }
                    }, normalState);
                    var styles = normalState.style;
                    delete normalState.style;
                    hoverState = merge(normalState, {
                        fill: "#e6e6e6"
                    }, hoverState);
                    var hover = hoverState.style;
                    delete hoverState.style;
                    pressedState = merge(normalState, {
                        fill: "#e6ebf5",
                        style: {
                            color: "#000000",
                            fontWeight: "bold"
                        }
                    }, pressedState);
                    var pressed = pressedState.style;
                    delete pressedState.style;
                    disabledState = merge(normalState, {
                        style: {
                            color: "#cccccc"
                        }
                    }, disabledState);
                    var disabled = disabledState.style;
                    delete disabledState.style;
                }
                addEvent(label.element, isMS ? "mouseover" : "mouseenter", function () {
                    if (3 !== curState) {
                        label.setState(1);
                    }
                });
                addEvent(label.element, isMS ? "mouseout" : "mouseleave", function () {
                    if (3 !== curState) {
                        label.setState(curState);
                    }
                });
                /**
                 * @param {string} state
                 * @return {undefined}
                 */
                label.setState = function (state) {
                    if (1 !== state) {
                        label.state = curState = state;
                    }
                    label.removeClass(/highcharts-button-(normal|hover|pressed|disabled)/).addClass("highcharts-button-" + ["normal", "hover", "pressed", "disabled"][state || 0]);
                    if (!N) {
                        label.attr([normalState, hoverState, pressedState, disabledState][state || 0]).css([styles, hover, pressed, disabled][state || 0]);
                    }
                };
                if (!N) {
                    label.attr(normalState).css(extend({
                        cursor: "default"
                    }, styles));
                }
                return label.on("click", function (localMediaStream) {
                    if (3 !== curState) {
                        callback.call(label, localMediaStream);
                    }
                });
            },
            crispLine: function (points, width) {
                if (points[1] === points[4]) {
                    /** @type {number} */
                    points[1] = points[4] = Math.round(points[1]) - width % 2 / 2;
                }
                if (points[2] === points[5]) {
                    /** @type {number} */
                    points[2] = points[5] = Math.round(points[2]) + width % 2 / 2;
                }
                return points;
            },
            path: function (v) {
                /** @type {({fill: string}|{})} */
                var value = this.styledMode ? {} : {
                    fill: "none"
                };
                if (fn(v)) {
                    /** @type {!Object} */
                    value.d = v;
                } else {
                    if (isObject(v)) {
                        extend(value, v);
                    }
                }
                return this.createElement("path").attr(value);
            },
            circle: function (value, node, x) {
                value = isObject(value) ? value : "undefined" === typeof value ? {} : {
                    x: value,
                    y: node,
                    r: x
                };
                node = this.createElement("circle");
                /** @type {function(?, number, ?): undefined} */
                node.xSetter = node.ySetter = function (key, name, str) {
                    str.setAttribute("c" + name, key);
                };
                return node.attr(value);
            },
            arc: function (x, y, r, options, elem, scale) {
                if (isObject(x)) {
                    /** @type {!Object} */
                    options = x;
                    y = options.y;
                    r = options.r;
                    x = options.x;
                } else {
                    options = {
                        innerR: options,
                        start: elem,
                        end: scale
                    };
                }
                x = this.symbol("arc", x, y, r, r, options);
                /** @type {!Object} */
                x.r = r;
                return x;
            },
            rect: function (x, y, w, d, r, value) {
                r = isObject(x) ? x.r : r;
                var wrapper = this.createElement("rect");
                x = isObject(x) ? x : "undefined" === typeof x ? {} : {
                    x: x,
                    y: y,
                    width: Math.max(w, 0),
                    height: Math.max(d, 0)
                };
                if (!this.styledMode) {
                    if ("undefined" !== typeof value) {
                        /** @type {number} */
                        x.strokeWidth = value;
                        x = wrapper.crisp(x);
                    }
                    /** @type {string} */
                    x.fill = "none";
                }
                if (r) {
                    /** @type {!Object} */
                    x.r = r;
                }
                /**
                 * @param {number} value
                 * @param {?} element
                 * @param {undefined} key
                 * @return {undefined}
                 */
                wrapper.rSetter = function (value, element, key) {
                    /** @type {number} */
                    wrapper.r = value;
                    attr(key, {
                        rx: value,
                        ry: value
                    });
                };
                /**
                 * @return {?}
                 */
                wrapper.rGetter = function () {
                    return wrapper.r;
                };
                return wrapper.attr(x);
            },
            setSize: function (width, height, val) {
                var children = this.alignedObjects;
                var i = children.length;
                /** @type {string} */
                this.width = width;
                /** @type {number} */
                this.height = height;
                this.boxWrapper.animate({
                    width: width,
                    height: height
                }, {
                    step: function () {
                        this.attr({
                            viewBox: "0 0 " + this.attr("width") + " " + this.attr("height")
                        });
                    },
                    duration: pick(val, true) ? void 0 : 0
                });
                for (; i--;) {
                    children[i].align();
                }
            },
            g: function (name) {
                var elem = this.createElement("g");
                return name ? elem.attr({
                    "class": "highcharts-" + name
                }) : elem;
            },
            image: function (data, title, d, x, y, parent) {
                var attribs = {
                    preserveAspectRatio: "none"
                };
                /**
                 * @param {!Element} s
                 * @param {string} d
                 * @return {undefined}
                 */
                var $ = function (s, d) {
                    if (s.setAttributeNS) {
                        s.setAttributeNS("http://www.w3.org/1999/xlink", "href", d);
                    } else {
                        s.setAttribute("hc-svg-href", d);
                    }
                };
                /**
                 * @param {?} error
                 * @return {undefined}
                 */
                var cb = function (error) {
                    $(node.element, data);
                    parent.call(node, error);
                };
                if (1 < arguments.length) {
                    extend(attribs, {
                        x: title,
                        y: d,
                        width: x,
                        height: y
                    });
                }
                var node = this.createElement("image").attr(attribs);
                if (parent) {
                    $(node.element, "data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==");
                    attribs = new win.Image;
                    addEvent(attribs, "load", cb);
                    /** @type {string} */
                    attribs.src = data;
                    if (attribs.complete) {
                        cb({});
                    }
                } else {
                    $(node.element, data);
                }
                return node;
            },
            symbol: function (key, x, i, width, height, options) {
                var renderer = this;
                /** @type {!RegExp} */
                var l = /^url\((.*?)\)$/;
                /** @type {boolean} */
                var isImage = l.test(key);
                var sym = !isImage && (this.symbols[key] ? key : "circle");
                var symbolFn = sym && this.symbols[sym];
                var p = defined(x) && symbolFn && symbolFn.call(this.symbols, Math.round(x), Math.round(i), width, height, options);
                if (symbolFn) {
                    var obj = this.path(p);
                    if (!renderer.styledMode) {
                        obj.attr("fill", "none");
                    }
                    extend(obj, {
                        symbolName: sym,
                        x: x,
                        y: i,
                        width: width,
                        height: height
                    });
                    if (options) {
                        extend(obj, options);
                    }
                } else {
                    if (isImage) {
                        var imageSrc = key.match(l)[1];
                        obj = this.image(imageSrc);
                        obj.imgwidth = pick(symbolSizes[imageSrc] && symbolSizes[imageSrc].width, options && options.width);
                        obj.imgheight = pick(symbolSizes[imageSrc] && symbolSizes[imageSrc].height, options && options.height);
                        /**
                         * @return {undefined}
                         */
                        var centerImage = function () {
                            obj.attr({
                                width: obj.width,
                                height: obj.height
                            });
                        };
                        ["width", "height"].forEach(function (key) {
                            /**
                             * @param {?} loadedPlugin
                             * @param {string} name
                             * @return {undefined}
                             */
                            obj[key + "Setter"] = function (loadedPlugin, name) {
                                var attrs = {};
                                var newPosition = this["img" + name];
                                /** @type {string} */
                                var transform = "width" === name ? "translateX" : "translateY";
                                this[name] = loadedPlugin;
                                if (defined(newPosition)) {
                                    if (options && "within" === options.backgroundSize && this.width && this.height) {
                                        /** @type {number} */
                                        newPosition = Math.round(newPosition * Math.min(this.width / this.imgwidth, this.height / this.imgheight));
                                    }
                                    if (this.element) {
                                        this.element.setAttribute(name, newPosition);
                                    }
                                    if (!this.alignByTranslate) {
                                        /** @type {number} */
                                        attrs[transform] = ((this[name] || 0) - newPosition) / 2;
                                        this.attr(attrs);
                                    }
                                }
                            };
                        });
                        if (defined(x)) {
                            obj.attr({
                                x: x,
                                y: i
                            });
                        }
                        /** @type {boolean} */
                        obj.isImg = true;
                        if (defined(obj.imgwidth) && defined(obj.imgheight)) {
                            centerImage();
                        } else {
                            obj.attr({
                                width: 0,
                                height: 0
                            });
                            createElement("img", {
                                onload: function () {
                                    var chart = charts[renderer.chartIndex];
                                    if (0 === this.width) {
                                        css(this, {
                                            position: "absolute",
                                            top: "-999em"
                                        });
                                        doc.body.appendChild(this);
                                    }
                                    symbolSizes[imageSrc] = {
                                        width: this.width,
                                        height: this.height
                                    };
                                    obj.imgwidth = this.width;
                                    obj.imgheight = this.height;
                                    if (obj.element) {
                                        centerImage();
                                    }
                                    if (this.parentNode) {
                                        this.parentNode.removeChild(this);
                                    }
                                    renderer.imgCount--;
                                    if (!renderer.imgCount && chart && chart.onload) {
                                        chart.onload();
                                    }
                                },
                                src: imageSrc
                            });
                            this.imgCount++;
                        }
                    }
                }
                return obj;
            },
            symbols: {
                circle: function (x, y, w, h) {
                    return this.arc(x + w / 2, y + h / 2, w / 2, h / 2, {
                        start: .5 * Math.PI,
                        end: 2.5 * Math.PI,
                        open: false
                    });
                },
                square: function (status, data, chunk, val) {
                    return ["M", status, data, "L", status + chunk, data, status + chunk, data + val, status, data + val, "Z"];
                },
                triangle: function (x, height, width, length) {
                    return ["M", x + width / 2, height, "L", x + width, height + length, x, height + length, "Z"];
                },
                "triangle-down": function (y, w, h, x) {
                    return ["M", y, w, "L", y + h, w, y + h / 2, w + x, "Z"];
                },
                diamond: function (y, width, depth, height) {
                    return ["M", y + depth / 2, width, "L", y + depth, width + height / 2, y + depth / 2, width + height, y, width + height / 2, "Z"];
                },
                arc: function (x, y, width, open, options) {
                    var start = options.start;
                    var arc = options.r || width;
                    var height = options.r || open || width;
                    /** @type {number} */
                    var value = options.end - .001;
                    width = options.innerR;
                    open = pick(options.open, .001 > Math.abs(options.end - options.start - 2 * Math.PI));
                    /** @type {number} */
                    var i = Math.cos(start);
                    /** @type {number} */
                    var b = Math.sin(start);
                    /** @type {number} */
                    var cols = Math.cos(value);
                    /** @type {number} */
                    value = Math.sin(value);
                    start = pick(options.longArc, .001 > options.end - start - Math.PI ? 0 : 1);
                    /** @type {!Array} */
                    arc = ["M", x + arc * i, y + height * b, "A", arc, height, 0, start, pick(options.clockwise, 1), x + arc * cols, y + height * value];
                    if (defined(width)) {
                        arc.push(open ? "M" : "L", x + width * cols, y + width * value, "A", width, width, 0, start, defined(options.clockwise) ? 1 - options.clockwise : 0, x + width * i, y + width * b);
                    }
                    arc.push(open ? "" : "Z");
                    return arc;
                },
                callout: function (x, y, w, h, anchorY) {
                    /** @type {number} */
                    var r = Math.min(anchorY && anchorY.r || 0, w, h);
                    /** @type {number} */
                    var safeDistance = r + 6;
                    var anchorX = anchorY && anchorY.anchorX;
                    anchorY = anchorY && anchorY.anchorY;
                    /** @type {!Array} */
                    var path = ["M", x + r, y, "L", x + w - r, y, "C", x + w, y, x + w, y, x + w, y + r, "L", x + w, y + h - r, "C", x + w, y + h, x + w, y + h, x + w - r, y + h, "L", x + r, y + h, "C", x, y + h, x, y + h, x, y + h - r, "L", x, y + r, "C", x, y, x, y, x + r, y];
                    if (anchorX && anchorX > w) {
                        if (anchorY > y + safeDistance && anchorY < y + h - safeDistance) {
                            path.splice(13, 3, "L", x + w, anchorY - 6, x + w + 6, anchorY, x + w, anchorY + 6, x + w, y + h - r);
                        } else {
                            path.splice(13, 3, "L", x + w, h / 2, anchorX, anchorY, x + w, h / 2, x + w, y + h - r);
                        }
                    } else {
                        if (anchorX && 0 > anchorX) {
                            if (anchorY > y + safeDistance && anchorY < y + h - safeDistance) {
                                path.splice(33, 3, "L", x, anchorY + 6, x - 6, anchorY, x, anchorY - 6, x, y + r);
                            } else {
                                path.splice(33, 3, "L", x, h / 2, anchorX, anchorY, x, h / 2, x, y + r);
                            }
                        } else {
                            if (anchorY && anchorY > h && anchorX > x + safeDistance && anchorX < x + w - safeDistance) {
                                path.splice(23, 3, "L", anchorX + 6, y + h, anchorX, y + h + 6, anchorX - 6, y + h, x + r, y + h);
                            } else {
                                if (anchorY && 0 > anchorY && anchorX > x + safeDistance && anchorX < x + w - safeDistance) {
                                    path.splice(3, 3, "L", anchorX - 6, y, anchorX, y - 6, anchorX + 6, y, w - r, y);
                                }
                            }
                        }
                    }
                    return path;
                }
            },
            clipRect: function (x, y, width, height) {
                var list_id = H.uniqueKey() + "-";
                var clipPath = this.createElement("clipPath").attr({
                    id: list_id
                }).add(this.defs);
                x = this.rect(x, y, width, height, 0).add(clipPath);
                x.id = list_id;
                x.clipPath = clipPath;
                /** @type {number} */
                x.count = 0;
                return x;
            },
            text: function (key, x, obj, val) {
                var o = {};
                if (val && (this.allowHTML || !this.forExport)) {
                    return this.html(key, x, obj);
                }
                /** @type {number} */
                o.x = Math.round(x || 0);
                if (obj) {
                    /** @type {number} */
                    o.y = Math.round(obj);
                }
                if (defined(key)) {
                    /** @type {!Object} */
                    o.text = key;
                }
                key = this.createElement("text").attr(o);
                if (!val) {
                    /**
                     * @param {?} key
                     * @param {?} element
                     * @param {!Object} node
                     * @return {undefined}
                     */
                    key.xSetter = function (key, element, node) {
                        var encrypted_fields = node.getElementsByTagName("tspan");
                        var tn = node.getAttribute(element);
                        var i;
                        /** @type {number} */
                        i = 0;
                        for (; i < encrypted_fields.length; i++) {
                            var field = encrypted_fields[i];
                            if (field.getAttribute(element) === tn) {
                                field.setAttribute(element, key);
                            }
                        }
                        node.setAttribute(element, key);
                    };
                }
                return key;
            },
            fontMetrics: function (fontSize, elem) {
                fontSize = !this.styledMode && /px/.test(fontSize) || !win.getComputedStyle ? fontSize || elem && elem.style && elem.style.fontSize || this.style && this.style.fontSize : elem && SVGElement.prototype.getStyle.call(elem, "font-size");
                fontSize = /px/.test(fontSize) ? pInt(fontSize) : 12;
                elem = 24 > fontSize ? fontSize + 3 : Math.round(1.2 * fontSize);
                return {
                    h: elem,
                    b: Math.round(.8 * elem),
                    f: fontSize
                };
            },
            rotCorr: function (baseline, rotation, alterY) {
                var y = baseline;
                if (rotation && alterY) {
                    /** @type {number} */
                    y = Math.max(y * Math.cos(rotation * deg2rad), 4);
                }
                return {
                    x: -baseline / 3 * Math.sin(rotation * deg2rad),
                    y: y
                };
            },
            label: function (value, key, val, type, obj, content, data, fn, className) {
                var renderer = this;
                var ext = renderer.styledMode;
                var wrapper = renderer.g("button" !== className && "label");
                var text = wrapper.text = renderer.text("", 0, 0, data).attr({
                    zIndex: 1
                });
                var box;
                var bBox;
                /** @type {number} */
                var regions = 0;
                /** @type {number} */
                var padding = 3;
                /** @type {number} */
                var paddingLeft = 0;
                var width;
                var height;
                var a;
                var center;
                var textAlign;
                var deferredAttr = {};
                var c;
                var val;
                /** @type {boolean} */
                var js = /^url\((.*?)\)$/.test(type);
                var extension = ext || js;
                /**
                 * @return {?}
                 */
                var getCrispAdjust = function () {
                    return ext ? box.strokeWidth() % 2 / 2 : (c ? parseInt(c, 10) : 0) % 2 / 2;
                };
                if (className) {
                    wrapper.addClass("highcharts-" + className);
                }
                /**
                 * @return {undefined}
                 */
                var updateBoxSize = function () {
                    var style = text.element.style;
                    var p = {};
                    bBox = ("undefined" === typeof width || "undefined" === typeof height || textAlign) && defined(text.textStr) && text.getBBox();
                    wrapper.width = (width || bBox.width || 0) + 2 * padding + paddingLeft;
                    wrapper.height = (height || bBox.height || 0) + 2 * padding;
                    val = padding + Math.min(renderer.fontMetrics(style && style.fontSize, text).b, bBox ? bBox.height : Infinity);
                    if (extension) {
                        if (!box) {
                            wrapper.box = box = renderer.symbols[type] || js ? renderer.symbol(type) : renderer.rect();
                            box.addClass(("button" === className ? "" : "highcharts-label-box") + (className ? " highcharts-" + className + "-box" : ""));
                            box.add(wrapper);
                            style = getCrispAdjust();
                            p.x = style;
                            p.y = (fn ? -val : 0) + style;
                        }
                        /** @type {number} */
                        p.width = Math.round(wrapper.width);
                        /** @type {number} */
                        p.height = Math.round(wrapper.height);
                        box.attr(extend(p, deferredAttr));
                        deferredAttr = {};
                    }
                };
                /**
                 * @return {undefined}
                 */
                var updateTextPadding = function () {
                    var textX = paddingLeft + padding;
                    var value = fn ? 0 : val;
                    if (defined(width) && bBox && ("center" === textAlign || "right" === textAlign)) {
                        textX = textX + {
                            center: .5,
                            right: 1
                        }[textAlign] * (width - bBox.width);
                    }
                    if (textX !== text.x || value !== text.y) {
                        text.attr("x", textX);
                        if (text.hasBoxWidthChanged) {
                            bBox = text.getBBox(true);
                            updateBoxSize();
                        }
                        if ("undefined" !== typeof value) {
                            text.attr("y", value);
                        }
                    }
                    text.x = textX;
                    text.y = value;
                };
                /**
                 * @param {string} key
                 * @param {!Object} value
                 * @return {undefined}
                 */
                var boxAttr = function (key, value) {
                    if (box) {
                        box.attr(key, value);
                    } else {
                        /** @type {!Object} */
                        deferredAttr[key] = value;
                    }
                };
                /**
                 * @return {undefined}
                 */
                wrapper.onAdd = function () {
                    text.add(wrapper);
                    wrapper.attr({
                        text: value || 0 === value ? value : "",
                        x: key,
                        y: val
                    });
                    if (box && defined(obj)) {
                        wrapper.attr({
                            anchorX: obj,
                            anchorY: content
                        });
                    }
                };
                /**
                 * @param {number} value
                 * @return {undefined}
                 */
                wrapper.widthSetter = function (value) {
                    width = isNaN(value) ? value : null;
                };
                /**
                 * @param {?} value
                 * @return {undefined}
                 */
                wrapper.heightSetter = function (value) {
                    height = value;
                };
                /**
                 * @param {string} left
                 * @return {undefined}
                 */
                wrapper["text-alignSetter"] = function (left) {
                    /** @type {string} */
                    textAlign = left;
                };
                /**
                 * @param {!Object} value
                 * @return {undefined}
                 */
                wrapper.paddingSetter = function (value) {
                    if (defined(value) && value !== padding) {
                        padding = wrapper.padding = value;
                        updateTextPadding();
                    }
                };
                /**
                 * @param {?} value
                 * @return {undefined}
                 */
                wrapper.paddingLeftSetter = function (value) {
                    if (defined(value) && value !== paddingLeft) {
                        paddingLeft = value;
                        updateTextPadding();
                    }
                };
                /**
                 * @param {number} value
                 * @return {undefined}
                 */
                wrapper.alignSetter = function (value) {
                    value = {
                        left: 0,
                        center: .5,
                        right: 1
                    }[value];
                    if (value !== regions) {
                        /** @type {number} */
                        regions = value;
                        if (bBox) {
                            wrapper.attr({
                                x: a
                            });
                        }
                    }
                };
                /**
                 * @param {string} value
                 * @return {undefined}
                 */
                wrapper.textSetter = function (value) {
                    if ("undefined" !== typeof value) {
                        text.attr({
                            text: value
                        });
                    }
                    updateBoxSize();
                    updateTextPadding();
                };
                /**
                 * @param {!Object} value
                 * @param {string} key
                 * @return {undefined}
                 */
                wrapper["stroke-widthSetter"] = function (value, key) {
                    if (value) {
                        /** @type {boolean} */
                        extension = true;
                    }
                    c = this["stroke-width"] = value;
                    boxAttr(key, value);
                };
                if (ext) {
                    /**
                     * @param {!Object} value
                     * @param {string} key
                     * @return {undefined}
                     */
                    wrapper.rSetter = function (value, key) {
                        boxAttr(key, value);
                    };
                } else {
                    /** @type {function(!Object, string): undefined} */
                    wrapper.strokeSetter = wrapper.fillSetter = wrapper.rSetter = function (value, key) {
                        if ("r" !== key) {
                            if ("fill" === key && value) {
                                /** @type {boolean} */
                                extension = true;
                            }
                            /** @type {!Object} */
                            wrapper[key] = value;
                        }
                        boxAttr(key, value);
                    };
                }
                /**
                 * @param {?} value
                 * @param {string} key
                 * @return {undefined}
                 */
                wrapper.anchorXSetter = function (value, key) {
                    obj = wrapper.anchorX = value;
                    boxAttr(key, Math.round(value) - getCrispAdjust() - a);
                };
                /**
                 * @param {?} value
                 * @param {string} key
                 * @return {undefined}
                 */
                wrapper.anchorYSetter = function (value, key) {
                    content = wrapper.anchorY = value;
                    boxAttr(key, value - center);
                };
                /**
                 * @param {string} key
                 * @return {undefined}
                 */
                wrapper.xSetter = function (key) {
                    /** @type {string} */
                    wrapper.x = key;
                    if (regions) {
                        /** @type {number} */
                        key = key - regions * ((width || bBox.width) + 2 * padding);
                        /** @type {boolean} */
                        wrapper["forceAnimate:x"] = true;
                    }
                    /** @type {number} */
                    a = Math.round(key);
                    wrapper.attr("translateX", a);
                };
                /**
                 * @param {?} value
                 * @return {undefined}
                 */
                wrapper.ySetter = function (value) {
                    /** @type {number} */
                    center = wrapper.y = Math.round(value);
                    wrapper.attr("translateY", center);
                };
                var baseCss = wrapper.css;
                data = {
                    css: function (data) {
                        if (data) {
                            var options = {};
                            data = merge(data);
                            wrapper.textProps.forEach(function (k) {
                                if ("undefined" !== typeof data[k]) {
                                    options[k] = data[k];
                                    delete data[k];
                                }
                            });
                            text.css(options);
                            if ("width" in options) {
                                updateBoxSize();
                            }
                            if ("fontSize" in options) {
                                updateBoxSize();
                                updateTextPadding();
                            }
                        }
                        return baseCss.call(wrapper, data);
                    },
                    getBBox: function () {
                        return {
                            width: bBox.width + 2 * padding,
                            height: bBox.height + 2 * padding,
                            x: bBox.x - padding,
                            y: bBox.y - padding
                        };
                    },
                    destroy: function () {
                        removeEvent(wrapper.element, "mouseenter");
                        removeEvent(wrapper.element, "mouseleave");
                        if (text) {
                            text = text.destroy();
                        }
                        if (box) {
                            box = box.destroy();
                        }
                        SVGElement.prototype.destroy.call(wrapper);
                        /** @type {null} */
                        wrapper = renderer = updateBoxSize = updateTextPadding = boxAttr = null;
                    }
                };
                if (!ext) {
                    /**
                     * @param {!Object} value
                     * @return {?}
                     */
                    data.shadow = function (value) {
                        if (value) {
                            updateBoxSize();
                            if (box) {
                                box.shadow(value);
                            }
                        }
                        return wrapper;
                    };
                }
                return extend(wrapper, data);
            }
        });
        /** @type {!Object} */
        H.Renderer = $;
    });
    set(x1, "parts/Html.js", [x1["parts/Globals.js"], x1["parts/Utilities.js"]], function (H, data) {
        var attr = data.attr;
        var defined = data.defined;
        var extend = data.extend;
        var generate = data.pick;
        var pInt = data.pInt;
        var createElement = H.createElement;
        var css = H.css;
        var isFirefox = H.isFirefox;
        var isMS = H.isMS;
        var isWebKit = H.isWebKit;
        var SVGElement = H.SVGElement;
        data = H.SVGRenderer;
        var win = H.win;
        extend(SVGElement.prototype, {
            htmlCss: function (obj) {
                var m = "SPAN" === this.element.tagName && obj && "width" in obj;
                var width = generate(m && obj.width, void 0);
                if (m) {
                    delete obj.width;
                    this.textWidth = width;
                    /** @type {boolean} */
                    var b = true;
                }
                if (obj && "ellipsis" === obj.textOverflow) {
                    /** @type {string} */
                    obj.whiteSpace = "nowrap";
                    /** @type {string} */
                    obj.overflow = "hidden";
                }
                this.styles = extend(this.styles, obj);
                css(this.element, obj);
                if (b) {
                    this.htmlUpdateTransform();
                }
                return this;
            },
            htmlGetBBox: function () {
                var tmp = this.element;
                return {
                    x: tmp.offsetLeft,
                    y: tmp.offsetTop,
                    width: tmp.offsetWidth,
                    height: tmp.offsetHeight
                };
            },
            htmlUpdateTransform: function () {
                if (this.added) {
                    var renderer = this.renderer;
                    var element = this.element;
                    var left = this.translateX || 0;
                    var origHtmlMargin = this.translateY || 0;
                    var x = this.x || 0;
                    var y = this.y || 0;
                    var align = this.textAlign || "left";
                    var alignCorrection = {
                        left: 0,
                        center: .5,
                        right: 1
                    }[align];
                    var styles = this.styles;
                    var whiteSpace = styles && styles.whiteSpace;
                    css(element, {
                        marginLeft: left,
                        marginTop: origHtmlMargin
                    });
                    if (!renderer.styledMode && this.shadows) {
                        this.shadows.forEach(function (result) {
                            css(result, {
                                marginLeft: left + 1,
                                marginTop: origHtmlMargin + 1
                            });
                        });
                    }
                    if (this.inverted) {
                        [].forEach.call(element.childNodes, function (child) {
                            renderer.invertChild(child, element);
                        });
                    }
                    if ("SPAN" === element.tagName) {
                        styles = this.rotation;
                        var b = this.textWidth && pInt(this.textWidth);
                        /** @type {string} */
                        var g = [styles, align, element.innerHTML, this.textWidth, this.textAlign].join();
                        var a;
                        if ((a = b !== this.oldTextWidth) && !(a = b > this.oldTextWidth)) {
                            if (!(a = this.textPxLength)) {
                                css(element, {
                                    width: "",
                                    whiteSpace: whiteSpace || "nowrap"
                                });
                                a = element.offsetWidth;
                            }
                            /** @type {boolean} */
                            a = a > b;
                        }
                        if (a && (/[ \-]/.test(element.textContent || element.innerText) || "ellipsis" === element.style.textOverflow)) {
                            css(element, {
                                width: b + "px",
                                display: "block",
                                whiteSpace: whiteSpace || "normal"
                            });
                            this.oldTextWidth = b;
                            /** @type {boolean} */
                            this.hasBoxWidthChanged = true;
                        } else {
                            /** @type {boolean} */
                            this.hasBoxWidthChanged = false;
                        }
                        if (g !== this.cTT) {
                            whiteSpace = renderer.fontMetrics(element.style.fontSize, element).b;
                            if (!(!defined(styles) || styles === (this.oldRotation || 0) && align === this.oldAlign)) {
                                this.setSpanRotation(styles, alignCorrection, whiteSpace);
                            }
                            this.getSpanCorrection(!defined(styles) && this.textPxLength || element.offsetWidth, whiteSpace, alignCorrection, styles, align);
                        }
                        css(element, {
                            left: x + (this.xCorr || 0) + "px",
                            top: y + (this.yCorr || 0) + "px"
                        });
                        /** @type {string} */
                        this.cTT = g;
                        this.oldRotation = styles;
                        this.oldAlign = align;
                    }
                } else {
                    /** @type {boolean} */
                    this.alignOnAdd = true;
                }
            },
            setSpanRotation: function (rotation, alignCorrection, baseline) {
                var props = {};
                var cssTransformKey = this.renderer.getTransformKey();
                /** @type {string} */
                props[cssTransformKey] = props.transform = "rotate(" + rotation + "deg)";
                /** @type {string} */
                props[cssTransformKey + (isFirefox ? "Origin" : "-origin")] = props.transformOrigin = 100 * alignCorrection + "% " + baseline + "px";
                css(this.element, props);
            },
            getSpanCorrection: function (width, baseline, alignCorrection) {
                /** @type {number} */
                this.xCorr = -width * alignCorrection;
                /** @type {number} */
                this.yCorr = -baseline;
            }
        });
        extend(data.prototype, {
            getTransformKey: function () {
                return isMS && !/Edge/.test(win.navigator.userAgent) ? "-ms-transform" : isWebKit ? "-webkit-transform" : isFirefox ? "MozTransform" : win.opera ? "-o-transform" : "";
            },
            html: function (text, y, value) {
                var wrapper = this.createElement("span");
                var element = wrapper.element;
                var renderer = wrapper.renderer;
                var isSVG = renderer.isSVG;
                /**
                 * @param {!Object} element
                 * @param {?} update
                 * @return {undefined}
                 */
                var addSetters = function (element, update) {
                    ["opacity", "visibility"].forEach(function (prop) {
                        /**
                         * @param {?} name
                         * @param {?} id
                         * @param {?} entry__3995__auto__
                         * @return {undefined}
                         */
                        element[prop + "Setter"] = function (name, id, entry__3995__auto__) {
                            var method = element.div ? element.div.style : update;
                            SVGElement.prototype[prop + "Setter"].call(this, name, id, entry__3995__auto__);
                            if (method) {
                                method[id] = name;
                            }
                        };
                    });
                    /** @type {boolean} */
                    element.addedSetters = true;
                };
                /**
                 * @param {string} value
                 * @return {undefined}
                 */
                wrapper.textSetter = function (value) {
                    if (value !== element.innerHTML) {
                        delete this.bBox;
                        delete this.oldTextWidth;
                    }
                    /** @type {string} */
                    this.textStr = value;
                    element.innerHTML = generate(value, "");
                    /** @type {boolean} */
                    wrapper.doTransform = true;
                };
                if (isSVG) {
                    addSetters(wrapper, wrapper.element.style);
                }
                /** @type {function(?, string): undefined} */
                wrapper.xSetter = wrapper.ySetter = wrapper.alignSetter = wrapper.rotationSetter = function (value, key) {
                    if ("align" === key) {
                        /** @type {string} */
                        key = "textAlign";
                    }
                    wrapper[key] = value;
                    /** @type {boolean} */
                    wrapper.doTransform = true;
                };
                /**
                 * @return {undefined}
                 */
                wrapper.afterSetters = function () {
                    if (this.doTransform) {
                        this.htmlUpdateTransform();
                        /** @type {boolean} */
                        this.doTransform = false;
                    }
                };
                wrapper.attr({
                    text: text,
                    x: Math.round(y),
                    y: Math.round(value)
                }).css({
                    position: "absolute"
                });
                if (!renderer.styledMode) {
                    wrapper.css({
                        fontFamily: this.style.fontFamily,
                        fontSize: this.style.fontSize
                    });
                }
                /** @type {string} */
                element.style.whiteSpace = "nowrap";
                wrapper.css = wrapper.htmlCss;
                if (isSVG) {
                    /**
                     * @param {!Object} parent
                     * @return {?}
                     */
                    wrapper.add = function (parent) {
                        var container = renderer.box.parentNode;
                        /** @type {!Array} */
                        var parents = [];
                        if (this.parentGroup = parent) {
                            var node = parent.div;
                            if (!node) {
                                for (; parent;) {
                                    parents.push(parent);
                                    parent = parent.parentGroup;
                                }
                                parents.reverse().forEach(function (parentGroup) {
                                    /**
                                     * @param {string} value
                                     * @param {string} key
                                     * @return {undefined}
                                     */
                                    function fn(value, key) {
                                        /** @type {string} */
                                        parentGroup[key] = value;
                                        if ("translateX" === key) {
                                            /** @type {string} */
                                            style.left = value + "px";
                                        } else {
                                            /** @type {string} */
                                            style.top = value + "px";
                                        }
                                        /** @type {boolean} */
                                        parentGroup.doTransform = true;
                                    }
                                    var cls = attr(parentGroup.element, "class");
                                    node = parentGroup.div = parentGroup.div || createElement("div", cls ? {
                                        className: cls
                                    } : void 0, {
                                        position: "absolute",
                                        left: (parentGroup.translateX || 0) + "px",
                                        top: (parentGroup.translateY || 0) + "px",
                                        display: parentGroup.display,
                                        opacity: parentGroup.opacity,
                                        pointerEvents: parentGroup.styles && parentGroup.styles.pointerEvents
                                    }, node || container);
                                    var style = node.style;
                                    extend(parentGroup, {
                                        classSetter: function (d) {
                                            return function (attributeValue) {
                                                this.element.setAttribute("class", attributeValue);
                                                /** @type {string} */
                                                d.className = attributeValue;
                                            };
                                        }(node),
                                        on: function () {
                                            if (parents[0].div) {
                                                wrapper.on.apply({
                                                    element: parents[0].div
                                                }, arguments);
                                            }
                                            return parentGroup;
                                        },
                                        translateXSetter: fn,
                                        translateYSetter: fn
                                    });
                                    if (!parentGroup.addedSetters) {
                                        addSetters(parentGroup);
                                    }
                                });
                            }
                        } else {
                            node = container;
                        }
                        node.appendChild(element);
                        /** @type {boolean} */
                        wrapper.added = true;
                        if (wrapper.alignOnAdd) {
                            wrapper.htmlUpdateTransform();
                        }
                        return wrapper;
                    };
                }
                return wrapper;
            }
        });
    });
    set(x1, "parts/Time.js", [x1["parts/Globals.js"], x1["parts/Utilities.js"]], function (config, H) {
        var defined = H.defined;
        var extend = H.extend;
        var isObject = H.isObject;
        var getTZOffset = H.objectEach;
        var pad = H.pad;
        var Number = H.pick;
        var format = H.splat;
        var parse = config.merge;
        var timeUnits = config.timeUnits;
        var win = config.win;
        /**
         * @param {!Object} options
         * @return {undefined}
         */
        config.Time = function (options) {
            this.update(options, false);
        };
        config.Time.prototype = {
            defaultOptions: {
                Date: void 0,
                getTimezoneOffset: void 0,
                timezone: void 0,
                timezoneOffset: 0,
                useUTC: true
            },
            update: function (options) {
                var elemTimer = Number(options && options.useUTC, true);
                var match = this;
                this.options = options = parse(true, this.options || {}, options);
                this.Date = options.Date || win.Date || Date;
                this.timezoneOffset = (this.useUTC = elemTimer) && options.timezoneOffset;
                this.getTimezoneOffset = this.timezoneOffsetFunction();
                if ((this.variableTimezone = !(elemTimer && !options.getTimezoneOffset && !options.timezone)) || this.timezoneOffset) {
                    /**
                     * @param {string} name
                     * @param {!Date} date
                     * @return {?}
                     */
                    this.get = function (name, date) {
                        var startMillis = date.getTime();
                        /** @type {number} */
                        var origin = startMillis - match.getTimezoneOffset(date);
                        date.setTime(origin);
                        name = date["getUTC" + name]();
                        date.setTime(startMillis);
                        return name;
                    };
                    /**
                     * @param {string} name
                     * @param {!Date} obj
                     * @param {number} elem
                     * @return {undefined}
                     */
                    this.set = function (name, obj, elem) {
                        if ("Milliseconds" === name || "Seconds" === name || "Minutes" === name && 0 === obj.getTimezoneOffset() % 60) {
                            obj["set" + name](elem);
                        } else {
                            var key = match.getTimezoneOffset(obj);
                            /** @type {number} */
                            key = obj.getTime() - key;
                            obj.setTime(key);
                            obj["setUTC" + name](elem);
                            name = match.getTimezoneOffset(obj);
                            key = obj.getTime() + name;
                            obj.setTime(key);
                        }
                    };
                } else {
                    if (elemTimer) {
                        /**
                         * @param {string} name
                         * @param {!Object} date
                         * @return {?}
                         */
                        this.get = function (name, date) {
                            return date["getUTC" + name]();
                        };
                        /**
                         * @param {string} method
                         * @param {!Object} url
                         * @param {number} name
                         * @return {?}
                         */
                        this.set = function (method, url, name) {
                            return url["setUTC" + method](name);
                        };
                    } else {
                        /**
                         * @param {string} name
                         * @param {!Object} obj
                         * @return {?}
                         */
                        this.get = function (name, obj) {
                            return obj["get" + name]();
                        };
                        /**
                         * @param {string} name
                         * @param {!Object} scope
                         * @param {number} key
                         * @return {?}
                         */
                        this.set = function (name, scope, key) {
                            return scope["set" + name](key);
                        };
                    }
                }
            },
            makeTime: function (string, i, s, index, time, totalTime) {
                if (this.useUTC) {
                    var x = this.Date.UTC.apply(0, arguments);
                    var offset = this.getTimezoneOffset(x);
                    x = x + offset;
                    var width = this.getTimezoneOffset(x);
                    if (offset !== width) {
                        x = x + (width - offset);
                    } else {
                        if (!(offset - 36E5 !== this.getTimezoneOffset(x - 36E5) || config.isSafari)) {
                            /** @type {number} */
                            x = x - 36E5;
                        }
                    }
                } else {
                    x = (new this.Date(string, i, Number(s, 1), Number(index, 0), Number(time, 0), Number(totalTime, 0))).getTime();
                }
                return x;
            },
            timezoneOffsetFunction: function () {
                var d = this;
                var options = this.options;
                var moment = win.moment;
                if (!this.useUTC) {
                    return function (match) {
                        return 6E4 * (new Date(match)).getTimezoneOffset();
                    };
                }
                if (options.timezone) {
                    if (moment) {
                        return function (timestamp) {
                            return 6E4 * -moment.tz(timestamp, options.timezone).utcOffset();
                        };
                    }
                    config.error(25);
                }
                return this.useUTC && options.getTimezoneOffset ? function (offset) {
                    return 6E4 * options.getTimezoneOffset(offset);
                } : function () {
                    return 6E4 * (d.timezoneOffset || 0);
                };
            },
            dateFormat: function (data, time, utc) {
                if (!defined(time) || isNaN(time)) {
                    return config.defaultOptions.lang.invalidDate || "";
                }
                data = Number(data, "%Y-%m-%d %H:%M:%S");
                var value = this;
                var d = new this.Date(time);
                var i = this.get("Hours", d);
                var day = this.get("Day", d);
                var date = this.get("Date", d);
                var month = this.get("Month", d);
                var y = this.get("FullYear", d);
                var lang = config.defaultOptions.lang;
                var langWeekdays = lang.weekdays;
                var shortWeekdays = lang.shortWeekdays;
                d = extend({
                    a: shortWeekdays ? shortWeekdays[day] : langWeekdays[day].substr(0, 3),
                    A: langWeekdays[day],
                    d: pad(date),
                    e: pad(date, 2, " "),
                    w: day,
                    b: lang.shortMonths[month],
                    B: lang.months[month],
                    m: pad(month + 1),
                    o: month + 1,
                    y: y.toString().substr(2, 2),
                    Y: y,
                    H: pad(i),
                    k: i,
                    I: pad(i % 12 || 12),
                    l: i % 12 || 12,
                    M: pad(value.get("Minutes", d)),
                    p: 12 > i ? "AM" : "PM",
                    P: 12 > i ? "am" : "pm",
                    S: pad(d.getSeconds()),
                    L: pad(Math.floor(time % 1E3), 3)
                }, config.dateFormats);
                getTZOffset(d, function (f, s) {
                    for (; -1 !== data.indexOf("%" + s);) {
                        data = data.replace("%" + s, "function" === typeof f ? f.call(value, time) : f);
                    }
                });
                return utc ? data.substr(0, 1).toUpperCase() + data.substr(1) : data;
            },
            resolveDTLFormat: function (result) {
                return isObject(result, true) ? result : (result = format(result), {
                    main: result[0],
                    from: result[1],
                    to: result[2]
                });
            },
            getTimeTicks: function (normalizedInterval, value, max, min) {
                var self = this;
                /** @type {!Array} */
                var tickPositions = [];
                var higherRanks = {};
                var v = new self.Date(value);
                var interval = normalizedInterval.unitRange;
                var width = normalizedInterval.count || 1;
                var variableDayLength;
                min = Number(min, 1);
                if (defined(value)) {
                    self.set("Milliseconds", v, interval >= timeUnits.second ? 0 : width * Math.floor(self.get("Milliseconds", v) / width));
                    if (interval >= timeUnits.second) {
                        self.set("Seconds", v, interval >= timeUnits.minute ? 0 : width * Math.floor(self.get("Seconds", v) / width));
                    }
                    if (interval >= timeUnits.minute) {
                        self.set("Minutes", v, interval >= timeUnits.hour ? 0 : width * Math.floor(self.get("Minutes", v) / width));
                    }
                    if (interval >= timeUnits.hour) {
                        self.set("Hours", v, interval >= timeUnits.day ? 0 : width * Math.floor(self.get("Hours", v) / width));
                    }
                    if (interval >= timeUnits.day) {
                        self.set("Date", v, interval >= timeUnits.month ? 1 : Math.max(1, width * Math.floor(self.get("Date", v) / width)));
                    }
                    if (interval >= timeUnits.month) {
                        self.set("Month", v, interval >= timeUnits.year ? 0 : width * Math.floor(self.get("Month", v) / width));
                        var i = self.get("FullYear", v);
                    }
                    if (interval >= timeUnits.year) {
                        self.set("FullYear", v, i - i % width);
                    }
                    if (interval === timeUnits.week) {
                        i = self.get("Day", v);
                        self.set("Date", v, self.get("Date", v) - i + min + (i < min ? -7 : 0));
                    }
                    i = self.get("FullYear", v);
                    min = self.get("Month", v);
                    var id = self.get("Date", v);
                    var s = self.get("Hours", v);
                    value = v.getTime();
                    if (self.variableTimezone) {
                        /** @type {boolean} */
                        variableDayLength = max - value > 4 * timeUnits.month || self.getTimezoneOffset(value) !== self.getTimezoneOffset(max);
                    }
                    value = v.getTime();
                    /** @type {number} */
                    v = 1;
                    for (; value < max;) {
                        tickPositions.push(value);
                        value = interval === timeUnits.year ? self.makeTime(i + v * width, 0) : interval === timeUnits.month ? self.makeTime(i, min + v * width) : !variableDayLength || interval !== timeUnits.day && interval !== timeUnits.week ? variableDayLength && interval === timeUnits.hour && 1 < width ? self.makeTime(i, min, id, s + v * width) : value + interval * width : self.makeTime(i, min, id + v * width * (interval === timeUnits.day ? 1 : 7));
                        v++;
                    }
                    tickPositions.push(value);
                    if (interval <= timeUnits.hour && 1E4 > tickPositions.length) {
                        tickPositions.forEach(function (time) {
                            if (0 === time % 18E5 && "000000000" === self.dateFormat("%H%M%S%L", time)) {
                                /** @type {string} */
                                higherRanks[time] = "day";
                            }
                        });
                    }
                }
                tickPositions.info = extend(normalizedInterval, {
                    higherRanks: higherRanks,
                    totalRange: interval * width
                });
                return tickPositions;
            }
        };
    });
    set(x1, "parts/Options.js", [x1["parts/Globals.js"]], function (self) {
        var color = self.color;
        var merge = self.merge;
        self.defaultOptions = {
            colors: "#7cb5ec #434348 #90ed7d #f7a35c #8085e9 #f15c80 #e4d354 #2b908f #f45b5b #91e8e1".split(" "),
            symbols: ["circle", "diamond", "square", "triangle", "triangle-down"],
            lang: {
                loading: "Loading...",
                months: "January February March April May June July August September October November December".split(" "),
                shortMonths: "Jan Feb Mar Apr May Jun Jul Aug Sep Oct Nov Dec".split(" "),
                weekdays: "Sunday Monday Tuesday Wednesday Thursday Friday Saturday".split(" "),
                decimalPoint: ".",
                numericSymbols: "kMGTPE".split(""),
                resetZoom: "Reset zoom",
                resetZoomTitle: "Reset zoom level 1:1",
                thousandsSep: " "
            },
            global: {},
            time: self.Time.prototype.defaultOptions,
            chart: {
                styledMode: false,
                borderRadius: 0,
                colorCount: 10,
                defaultSeriesType: "line",
                ignoreHiddenSeries: true,
                spacing: [10, 10, 15, 10],
                resetZoomButton: {
                    theme: {
                        zIndex: 6
                    },
                    position: {
                        align: "right",
                        x: -10,
                        y: 10
                    }
                },
                width: null,
                height: null,
                borderColor: "#335cad",
                backgroundColor: "#ffffff",
                plotBorderColor: "#cccccc"
            },
            title: {
                text: "Chart title",
                align: "center",
                margin: 15,
                widthAdjust: -44
            },
            subtitle: {
                text: "",
                align: "center",
                widthAdjust: -44
            },
            caption: {
                margin: 15,
                text: "",
                align: "left",
                verticalAlign: "bottom"
            },
            plotOptions: {},
            labels: {
                style: {
                    position: "absolute",
                    color: "#333333"
                }
            },
            legend: {
                enabled: true,
                align: "center",
                alignColumns: true,
                layout: "horizontal",
                labelFormatter: function () {
                    return this.name;
                },
                borderColor: "#999999",
                borderRadius: 0,
                navigation: {
                    activeColor: "#003399",
                    inactiveColor: "#cccccc"
                },
                itemStyle: {
                    color: "#333333",
                    cursor: "pointer",
                    fontSize: "12px",
                    fontWeight: "bold",
                    textOverflow: "ellipsis"
                },
                itemHoverStyle: {
                    color: "#000000"
                },
                itemHiddenStyle: {
                    color: "#cccccc"
                },
                shadow: false,
                itemCheckboxStyle: {
                    position: "absolute",
                    width: "13px",
                    height: "13px"
                },
                squareSymbol: true,
                symbolPadding: 5,
                verticalAlign: "bottom",
                x: 0,
                y: 0,
                title: {
                    style: {
                        fontWeight: "bold"
                    }
                }
            },
            loading: {
                labelStyle: {
                    fontWeight: "bold",
                    position: "relative",
                    top: "45%"
                },
                style: {
                    position: "absolute",
                    backgroundColor: "#ffffff",
                    opacity: .5,
                    textAlign: "center"
                }
            },
            tooltip: {
                enabled: true,
                animation: self.svg,
                borderRadius: 3,
                dateTimeLabelFormats: {
                    millisecond: "%A, %b %e, %H:%M:%S.%L",
                    second: "%A, %b %e, %H:%M:%S",
                    minute: "%A, %b %e, %H:%M",
                    hour: "%A, %b %e, %H:%M",
                    day: "%A, %b %e, %Y",
                    week: "Week from %A, %b %e, %Y",
                    month: "%B %Y",
                    year: "%Y"
                },
                footerFormat: "",
                padding: 8,
                snap: self.isTouchDevice ? 25 : 10,
                headerFormat: '<span style="font-size: 10px">{point.key}</span><br/>',
                pointFormat: '<span style="color:{point.color}">\u25cf</span> {series.name}: <b>{point.y}</b><br/>',
                backgroundColor: color("#f7f7f7").setOpacity(.85).get(),
                borderWidth: 1,
                shadow: true,
                style: {
                    color: "#333333",
                    cursor: "default",
                    fontSize: "12px",
                    pointerEvents: "none",
                    whiteSpace: "nowrap"
                }
            },
            credits: {
                enabled: true,
                href: "https://www.highcharts.com?credits",
                position: {
                    align: "right",
                    x: -10,
                    verticalAlign: "bottom",
                    y: -5
                },
                style: {
                    cursor: "pointer",
                    color: "#999999",
                    fontSize: "9px"
                },
                text: "Highcharts.com"
            }
        };
        /**
         * @param {!Object} options
         * @return {?}
         */
        self.setOptions = function (options) {
            self.defaultOptions = merge(true, self.defaultOptions, options);
            if (options.time || options.global) {
                self.time.update(merge(self.defaultOptions.global, self.defaultOptions.time, options.global, options.time));
            }
            return self.defaultOptions;
        };
        /**
         * @return {?}
         */
        self.getOptions = function () {
            return self.defaultOptions;
        };
        self.defaultPlotOptions = self.defaultOptions.plotOptions;
        self.time = new self.Time(merge(self.defaultOptions.global, self.defaultOptions.time));
        /**
         * @param {string} value
         * @param {!Object} format
         * @param {number} utc
         * @return {?}
         */
        self.dateFormat = function (value, format, utc) {
            return self.time.dateFormat(value, format, utc);
        };
        "";
    });
    set(x1, "parts/Tick.js", [x1["parts/Globals.js"], x1["parts/Utilities.js"]], function (Highcharts, H) {
        var clamp = H.clamp;
        var correctFloat = H.correctFloat;
        var defined = H.defined;
        var destroyObjectProperties = H.destroyObjectProperties;
        var extend = H.extend;
        var isNumber = H.isNumber;
        var drawGridLines = H.objectEach;
        var pick = H.pick;
        var abs = Highcharts.fireEvent;
        var merge = Highcharts.merge;
        var deg2rad = Highcharts.deg2rad;
        /**
         * @param {string} axis
         * @param {!Array} pos
         * @param {!Object} name
         * @param {!Object} type
         * @param {!Object} noLabel
         * @return {undefined}
         */
        Highcharts.Tick = function (axis, pos, name, type, noLabel) {
            /** @type {string} */
            this.axis = axis;
            /** @type {!Array} */
            this.pos = pos;
            this.type = name || "";
            /** @type {boolean} */
            this.isNewLabel = this.isNew = true;
            this.parameters = noLabel || {};
            this.tickmarkOffset = this.parameters.tickmarkOffset;
            this.options = this.parameters.options;
            if (!(name || type)) {
                this.addLabel();
            }
        };
        Highcharts.Tick.prototype = {
            addLabel: function () {
                var self = this;
                var axis = self.axis;
                var options = axis.options;
                var chart = axis.chart;
                var categories = axis.categories;
                var value = axis.names;
                var pos = self.pos;
                var o = pick(self.options && self.options.labels, options.labels);
                var data = axis.tickPositions;
                /** @type {boolean} */
                var isFirst = pos === data[0];
                /** @type {boolean} */
                var isLast = pos === data[data.length - 1];
                value = this.parameters.category || (categories ? pick(categories[pos], value[pos], pos) : pos);
                var item = self.label;
                /** @type {boolean} */
                categories = (!o.step || 1 === o.step) && 1 === axis.tickInterval;
                data = data.info;
                var layer_i;
                var crossfilterable_layers;
                if (axis.isDatetimeAxis && data) {
                    var result = chart.time.resolveDTLFormat(options.dateTimeLabelFormats[!options.grid && data.higherRanks[pos] || data.unitName]);
                    var component = result.main;
                }
                /** @type {boolean} */
                self.isFirst = isFirst;
                /** @type {boolean} */
                self.isLast = isLast;
                self.formatCtx = {
                    axis: axis,
                    chart: chart,
                    isFirst: isFirst,
                    isLast: isLast,
                    dateTimeLabelFormat: component,
                    tickPositionInfo: data,
                    value: axis.isLog ? correctFloat(axis.lin2log(value)) : value,
                    pos: pos
                };
                options = axis.labelFormatter.call(self.formatCtx, this.formatCtx);
                if (crossfilterable_layers = result && result.list) {
                    /**
                     * @return {undefined}
                     */
                    self.shortenLabel = function () {
                        /** @type {number} */
                        layer_i = 0;
                        for (; layer_i < crossfilterable_layers.length; layer_i++) {
                            if (item.attr({
                                text: axis.labelFormatter.call(extend(self.formatCtx, {
                                    dateTimeLabelFormat: crossfilterable_layers[layer_i]
                                }))
                            }), item.getBBox().width < axis.getSlotWidth(self) - 2 * pick(o.padding, 5)) {
                                return;
                            }
                        }
                        item.attr({
                            text: ""
                        });
                    };
                }
                if (categories && axis._addedPlotLB && axis.isXAxis) {
                    self.moveLabel(options, o);
                }
                if (defined(item) || self.movedLabel) {
                    if (item && item.textStr !== options && !categories) {
                        if (!(!item.textWidth || o.style && o.style.width || item.styles.width)) {
                            item.css({
                                width: null
                            });
                        }
                        item.attr({
                            text: options
                        });
                        item.textPxLength = item.getBBox().width;
                    }
                } else {
                    self.label = item = self.createLabel({
                        x: 0,
                        y: 0
                    }, options, o);
                    /** @type {number} */
                    self.rotation = 0;
                }
            },
            moveLabel: function (label, index) {
                var self = this;
                var options = self.label;
                /** @type {boolean} */
                var inRange = false;
                var a = self.axis;
                var neg = a.reversed;
                var inverted = a.chart.inverted;
                if (options && options.textStr === label) {
                    self.movedLabel = options;
                    /** @type {boolean} */
                    inRange = true;
                    delete self.label;
                } else {
                    drawGridLines(a.ticks, function (item) {
                        if (!(inRange || item.isNew || item === self || !item.label || item.label.textStr !== label)) {
                            self.movedLabel = item.label;
                            /** @type {boolean} */
                            inRange = true;
                            item.labelPos = self.movedLabel.xy;
                            delete item.label;
                        }
                    });
                }
                if (!inRange && (self.labelPos || options)) {
                    var point = self.labelPos || options.xy;
                    options = inverted ? point.x : neg ? 0 : a.width + a.left;
                    a = inverted ? neg ? a.width + a.left : 0 : point.y;
                    self.movedLabel = self.createLabel({
                        x: options,
                        y: a
                    }, label, index);
                    if (self.movedLabel) {
                        self.movedLabel.attr({
                            opacity: 0
                        });
                    }
                }
            },
            createLabel: function (node, value, options) {
                var axis = this.axis;
                var chart = axis.chart;
                if (node = defined(value) && options.enabled ? chart.renderer.text(value, node.x, node.y, options.useHTML).add(axis.labelGroup) : null) {
                    if (!chart.styledMode) {
                        node.css(merge(options.style));
                    }
                    node.textPxLength = node.getBBox().width;
                }
                return node;
            },
            replaceMovedLabel: function () {
                var self = this.label;
                var a = this.axis;
                var h = a.reversed;
                var inverted = this.axis.chart.inverted;
                if (self && !this.isNew) {
                    var x = inverted ? self.xy.x : h ? a.left : a.width + a.left;
                    h = inverted ? h ? a.width + a.top : a.top : self.xy.y;
                    self.animate({
                        x: x,
                        y: h,
                        opacity: 0
                    }, void 0, self.destroy);
                    delete this.label;
                }
                /** @type {boolean} */
                a.isDirty = true;
                this.label = this.movedLabel;
                delete this.movedLabel;
            },
            getLabelSize: function () {
                return this.label ? this.label.getBBox()[this.axis.horiz ? "height" : "width"] : 0;
            },
            handleOverflow: function (pos) {
                var axis = this.axis;
                var settings = axis.options.labels;
                var x = pos.x;
                var chartWidth = axis.chart.chartWidth;
                var spacing = axis.chart.spacing;
                var a = pick(axis.labelLeft, Math.min(axis.pos, spacing[3]));
                spacing = pick(axis.labelRight, Math.max(axis.isRadial ? 0 : axis.pos + axis.len, chartWidth - spacing[1]));
                var label = this.label;
                var rotation = this.rotation;
                var l = {
                    left: 0,
                    center: .5,
                    right: 1
                }[axis.labelAlign || label.attr("align")];
                var r = label.getBBox().width;
                var e = axis.getSlotWidth(this);
                var i = e;
                /** @type {number} */
                var j = 1;
                var left;
                var css = {};
                if (rotation || "justify" !== pick(settings.overflow, "justify")) {
                    if (0 > rotation && x - l * r < a) {
                        /** @type {number} */
                        left = Math.round(x / Math.cos(rotation * deg2rad) - a);
                    } else {
                        if (0 < rotation && x + l * r > spacing) {
                            /** @type {number} */
                            left = Math.round((chartWidth - x) / Math.cos(rotation * deg2rad));
                        }
                    }
                } else {
                    if (chartWidth = x + (1 - l) * r, x - l * r < a ? i = pos.x + i * (1 - l) - a : chartWidth > spacing && (i = spacing - pos.x + i * l, j = -1), i = Math.min(e, i), i < e && "center" === axis.labelAlign && (pos.x += j * (e - i - l * (e - Math.min(r, i)))), r > i || axis.autoRotation && (label.styles || {}).width) {
                        /** @type {number} */
                        left = i;
                    }
                }
                if (left) {
                    if (this.shortenLabel) {
                        this.shortenLabel();
                    } else {
                        /** @type {number} */
                        css.width = Math.floor(left);
                        if (!(settings.style || {}).textOverflow) {
                            /** @type {string} */
                            css.textOverflow = "ellipsis";
                        }
                        label.css(css);
                    }
                }
            },
            getPosition: function (pos, i, x, old) {
                var axis = this.axis;
                var chart = axis.chart;
                var cHeight = old && chart.oldChartHeight || chart.chartHeight;
                pos = {
                    x: pos ? correctFloat(axis.translate(i + x, null, null, old) + axis.transB) : axis.left + axis.offset + (axis.opposite ? (old && chart.oldChartWidth || chart.chartWidth) - axis.right - axis.left : 0),
                    y: pos ? cHeight - axis.bottom + axis.offset - (axis.opposite ? axis.height : 0) : correctFloat(cHeight - axis.translate(i + x, null, null, old) - axis.transB)
                };
                pos.y = clamp(pos.y, -1E5, 1E5);
                abs(this, "afterGetPosition", {
                    pos: pos
                });
                return pos;
            },
            getLabelPosition: function (x, y, label, horiz, labelOptions, tickmarkOffset, index, step) {
                var axis = this.axis;
                var transA = axis.transA;
                var reversed = axis.isLinked && axis.linkedParent ? axis.linkedParent.reversed : axis.reversed;
                var staggerLines = axis.staggerLines;
                var names = axis.tickRotCorr || {
                    x: 0,
                    y: 0
                };
                var yOffset = labelOptions.y;
                /** @type {number} */
                var _ = horiz || axis.reserveSpaceDefault ? 0 : -axis.labelOffset * ("center" === axis.labelAlign ? .5 : 1);
                var pos = {};
                if (!defined(yOffset)) {
                    /** @type {number} */
                    yOffset = 0 === axis.side ? label.rotation ? -8 : -label.getBBox().height : 2 === axis.side ? names.y + 8 : Math.cos(label.rotation * deg2rad) * (names.y - label.getBBox(false, 0).height / 2);
                }
                /** @type {number} */
                x = x + labelOptions.x + _ + names.x - (tickmarkOffset && horiz ? tickmarkOffset * transA * (reversed ? -1 : 1) : 0);
                /** @type {number} */
                y = y + yOffset - (tickmarkOffset && !horiz ? tickmarkOffset * transA * (reversed ? 1 : -1) : 0);
                if (staggerLines) {
                    /** @type {number} */
                    label = index / (step || 1) % staggerLines;
                    if (axis.opposite) {
                        /** @type {number} */
                        label = staggerLines - label - 1;
                    }
                    /** @type {number} */
                    y = y + axis.labelOffset / staggerLines * label;
                }
                /** @type {string} */
                pos.x = x;
                /** @type {number} */
                pos.y = Math.round(y);
                abs(this, "afterGetLabelPosition", {
                    pos: pos,
                    tickmarkOffset: tickmarkOffset,
                    index: index
                });
                return pos;
            },
            getMarkPath: function (x, y, tickLength, tickWidth, horiz, renderer) {
                return renderer.crispLine(["M", x, y, "L", x + (horiz ? 0 : -tickLength), y + (horiz ? tickLength : 0)], tickWidth);
            },
            renderGridLine: function (old, opacity, id) {
                var axis = this.axis;
                var options = axis.options;
                var gridLine = this.gridLine;
                var settings = {};
                var i = this.pos;
                var type = this.type;
                var a = pick(this.tickmarkOffset, axis.tickmarkOffset);
                var renderer = axis.chart.renderer;
                /** @type {string} */
                var gridPrefix = type ? type + "Grid" : "grid";
                var value = options[gridPrefix + "LineWidth"];
                var v = options[gridPrefix + "LineColor"];
                options = options[gridPrefix + "LineDashStyle"];
                if (!gridLine) {
                    if (!axis.chart.styledMode) {
                        settings.stroke = v;
                        settings["stroke-width"] = value;
                        if (options) {
                            settings.dashstyle = options;
                        }
                    }
                    if (!type) {
                        /** @type {number} */
                        settings.zIndex = 1;
                    }
                    if (old) {
                        /** @type {number} */
                        opacity = 0;
                    }
                    this.gridLine = gridLine = renderer.path().attr(settings).addClass("highcharts-" + (type ? type + "-" : "") + "grid-line").add(axis.gridGroup);
                }
                if (gridLine && (id = axis.getPlotLinePath({
                    value: i + a,
                    lineWidth: gridLine.strokeWidth() * id,
                    force: "pass",
                    old: old
                }))) {
                    gridLine[old || this.isNew ? "attr" : "animate"]({
                        d: id,
                        opacity: opacity
                    });
                }
            },
            renderMark: function (y, opacity, reverseCrisp) {
                var axis = this.axis;
                var options = axis.options;
                var renderer = axis.chart.renderer;
                var type = this.type;
                /** @type {string} */
                var tickPrefix = type ? type + "Tick" : "tick";
                var tickSize = axis.tickSize(tickPrefix);
                var mark = this.mark;
                /** @type {boolean} */
                var isNewMark = !mark;
                var x = y.x;
                y = y.y;
                var borderWidth = pick(options[tickPrefix + "Width"], !type && axis.isXAxis ? 1 : 0);
                options = options[tickPrefix + "Color"];
                if (tickSize) {
                    if (axis.opposite) {
                        /** @type {number} */
                        tickSize[0] = -tickSize[0];
                    }
                    if (isNewMark) {
                        this.mark = mark = renderer.path().addClass("highcharts-" + (type ? type + "-" : "") + "tick").add(axis.axisGroup);
                        if (!axis.chart.styledMode) {
                            mark.attr({
                                stroke: options,
                                "stroke-width": borderWidth
                            });
                        }
                    }
                    mark[isNewMark ? "attr" : "animate"]({
                        d: this.getMarkPath(x, y, tickSize[0], mark.strokeWidth() * reverseCrisp, axis.horiz, renderer),
                        opacity: opacity
                    });
                }
            },
            renderLabel: function (xy, node, opacity, index) {
                var axis = this.axis;
                var horiz = axis.horiz;
                var options = axis.options;
                var label = this.label;
                var labelOptions = options.labels;
                var step = labelOptions.step;
                axis = pick(this.tickmarkOffset, axis.tickmarkOffset);
                /** @type {boolean} */
                var width = true;
                var x = xy.x;
                xy = xy.y;
                if (label && isNumber(x)) {
                    label.xy = xy = this.getLabelPosition(x, xy, label, horiz, labelOptions, axis, index, step);
                    if (this.isFirst && !this.isLast && !pick(options.showFirstLabel, 1) || this.isLast && !this.isFirst && !pick(options.showLastLabel, 1)) {
                        /** @type {boolean} */
                        width = false;
                    } else {
                        if (!(!horiz || labelOptions.step || labelOptions.rotation || node || 0 === opacity)) {
                            this.handleOverflow(xy);
                        }
                    }
                    if (step && index % step) {
                        /** @type {boolean} */
                        width = false;
                    }
                    if (width && isNumber(xy.y)) {
                        /** @type {number} */
                        xy.opacity = opacity;
                        label[this.isNewLabel ? "attr" : "animate"](xy);
                        /** @type {boolean} */
                        this.isNewLabel = false;
                    } else {
                        label.attr("y", -9999);
                        /** @type {boolean} */
                        this.isNewLabel = true;
                    }
                }
            },
            render: function (index, value, opacity) {
                var axis = this.axis;
                var pos = axis.horiz;
                var position = this.pos;
                var width = pick(this.tickmarkOffset, axis.tickmarkOffset);
                position = this.getPosition(pos, position, width, value);
                width = position.x;
                var y = position.y;
                /** @type {number} */
                axis = pos && width === axis.pos + axis.len || !pos && y === axis.pos ? -1 : 1;
                opacity = pick(opacity, 1);
                /** @type {boolean} */
                this.isActive = true;
                this.renderGridLine(value, opacity, axis);
                this.renderMark(position, opacity, axis);
                this.renderLabel(position, value, opacity, index);
                /** @type {boolean} */
                this.isNew = false;
                Highcharts.fireEvent(this, "afterRender");
            },
            destroy: function () {
                destroyObjectProperties(this, this.axis);
            }
        };
    });
    set(x1, "parts/Axis.js", [x1["parts/Globals.js"], x1["parts/Utilities.js"]], function (Highcharts, H) {
        var animObject = H.animObject;
        var arrayMax = H.arrayMax;
        var arrayMin = H.arrayMin;
        var add = H.clamp;
        var correctFloat = H.correctFloat;
        var defined = H.defined;
        var destroyObjectProperties = H.destroyObjectProperties;
        var extend = H.extend;
        var isArray = H.isArray;
        var map = H.isNumber;
        var isString = H.isString;
        var objectEach = H.objectEach;
        var pick = H.pick;
        var bounce = H.relativeLength;
        var splat = H.splat;
        var syncTimeout = H.syncTimeout;
        var addEvent = Highcharts.addEvent;
        var color = Highcharts.color;
        var defaultOptions = Highcharts.defaultOptions;
        var deg2rad = Highcharts.deg2rad;
        var each = Highcharts.fireEvent;
        var format = Highcharts.format;
        var getMagnitude = Highcharts.getMagnitude;
        var merge = Highcharts.merge;
        var normalizeTickInterval = Highcharts.normalizeTickInterval;
        var removeEvent = Highcharts.removeEvent;
        var seriesTypes = Highcharts.seriesTypes;
        var Tick = Highcharts.Tick;
        /**
         * @return {undefined}
         */
        H = function () {
            this.init.apply(this, arguments);
        };
        extend(H.prototype, {
            defaultOptions: {
                dateTimeLabelFormats: {
                    millisecond: {
                        main: "%H:%M:%S.%L",
                        range: false
                    },
                    second: {
                        main: "%H:%M:%S",
                        range: false
                    },
                    minute: {
                        main: "%H:%M",
                        range: false
                    },
                    hour: {
                        main: "%H:%M",
                        range: false
                    },
                    day: {
                        main: "%e. %b"
                    },
                    week: {
                        main: "%e. %b"
                    },
                    month: {
                        main: "%b '%y"
                    },
                    year: {
                        main: "%Y"
                    }
                },
                endOnTick: false,
                labels: {
                    enabled: true,
                    indentation: 10,
                    x: 0,
                    style: {
                        color: "#666666",
                        cursor: "default",
                        fontSize: "11px"
                    }
                },
                maxPadding: .01,
                minorTickLength: 2,
                minorTickPosition: "outside",
                minPadding: .01,
                showEmpty: true,
                startOfWeek: 1,
                startOnTick: false,
                tickLength: 10,
                tickPixelInterval: 100,
                tickmarkPlacement: "between",
                tickPosition: "outside",
                title: {
                    align: "middle",
                    style: {
                        color: "#666666"
                    }
                },
                type: "linear",
                minorGridLineColor: "#f2f2f2",
                minorGridLineWidth: 1,
                minorTickColor: "#999999",
                lineColor: "#ccd6eb",
                lineWidth: 1,
                gridLineColor: "#e6e6e6",
                tickColor: "#ccd6eb"
            },
            defaultYAxisOptions: {
                endOnTick: true,
                maxPadding: .05,
                minPadding: .05,
                tickPixelInterval: 72,
                showLastLabel: true,
                labels: {
                    x: -8
                },
                startOnTick: true,
                title: {
                    rotation: 270,
                    text: "Values"
                },
                stackLabels: {
                    allowOverlap: false,
                    enabled: false,
                    crop: true,
                    overflow: "justify",
                    formatter: function () {
                        var calculateHeight = this.axis.chart.numberFormatter;
                        return calculateHeight(this.total, -1);
                    },
                    style: {
                        color: "#000000",
                        fontSize: "11px",
                        fontWeight: "bold",
                        textOutline: "1px contrast"
                    }
                },
                gridLineWidth: 1,
                lineWidth: 0
            },
            defaultLeftAxisOptions: {
                labels: {
                    x: -15
                },
                title: {
                    rotation: 270
                }
            },
            defaultRightAxisOptions: {
                labels: {
                    x: 15
                },
                title: {
                    rotation: 90
                }
            },
            defaultBottomAxisOptions: {
                labels: {
                    autoRotation: [-45],
                    x: 0
                },
                margin: 15,
                title: {
                    rotation: 0
                }
            },
            defaultTopAxisOptions: {
                labels: {
                    autoRotation: [-45],
                    x: 0
                },
                margin: 15,
                title: {
                    rotation: 0
                }
            },
            init: function (chart, userOptions) {
                var isXAxis = userOptions.isX;
                var axis = this;
                /** @type {!Object} */
                axis.chart = chart;
                axis.horiz = chart.inverted && !axis.isZAxis ? !isXAxis : isXAxis;
                axis.isXAxis = isXAxis;
                axis.coll = axis.coll || (isXAxis ? "xAxis" : "yAxis");
                each(this, "init", {
                    userOptions: userOptions
                });
                axis.opposite = userOptions.opposite;
                axis.side = userOptions.side || (axis.horiz ? axis.opposite ? 0 : 2 : axis.opposite ? 1 : 3);
                axis.setOptions(userOptions);
                var options = this.options;
                var feedType = options.type;
                axis.labelFormatter = options.labels.formatter || axis.defaultLabelFormatter;
                /** @type {!Object} */
                axis.userOptions = userOptions;
                /** @type {number} */
                axis.minPixelPadding = 0;
                axis.reversed = options.reversed;
                /** @type {boolean} */
                axis.visible = false !== options.visible;
                /** @type {boolean} */
                axis.zoomEnabled = false !== options.zoomEnabled;
                /** @type {boolean} */
                axis.hasNames = "category" === feedType || true === options.categories;
                axis.categories = options.categories || axis.hasNames;
                if (!axis.names) {
                    /** @type {!Array} */
                    axis.names = [];
                    axis.names.keys = {};
                }
                axis.plotLinesAndBandsGroups = {};
                /** @type {boolean} */
                axis.isLog = "logarithmic" === feedType;
                /** @type {boolean} */
                axis.isDatetimeAxis = "datetime" === feedType;
                /** @type {boolean} */
                axis.positiveValuesOnly = axis.isLog && !axis.allowNegativeLog;
                axis.isLinked = defined(options.linkedTo);
                axis.ticks = {};
                /** @type {!Array} */
                axis.labelEdge = [];
                axis.minorTicks = {};
                /** @type {!Array} */
                axis.plotLinesAndBands = [];
                axis.alternateBands = {};
                /** @type {number} */
                axis.len = 0;
                axis.minRange = axis.userMinRange = options.minRange || options.maxZoom;
                axis.range = options.range;
                axis.offset = options.offset || 0;
                axis.stacks = {};
                axis.oldStacks = {};
                /** @type {number} */
                axis.stacksTouched = 0;
                /** @type {null} */
                axis.max = null;
                /** @type {null} */
                axis.min = null;
                axis.crosshair = pick(options.crosshair, splat(chart.options.tooltip.crosshairs)[isXAxis ? 0 : 1], false);
                userOptions = axis.options.events;
                if (-1 === chart.axes.indexOf(axis)) {
                    if (isXAxis) {
                        chart.axes.splice(chart.xAxis.length, 0, axis);
                    } else {
                        chart.axes.push(axis);
                    }
                    chart[axis.coll].push(axis);
                }
                axis.series = axis.series || [];
                if (chart.inverted && !axis.isZAxis && isXAxis && "undefined" === typeof axis.reversed) {
                    /** @type {boolean} */
                    axis.reversed = true;
                }
                objectEach(userOptions, function (value, play) {
                    if (Highcharts.isFunction(value)) {
                        addEvent(axis, play, value);
                    }
                });
                axis.lin2log = options.linearToLogConverter || axis.lin2log;
                if (axis.isLog) {
                    axis.val2lin = axis.log2lin;
                    axis.lin2val = axis.lin2log;
                }
                each(this, "afterInit");
            },
            setOptions: function (userOptions) {
                this.options = merge(this.defaultOptions, "yAxis" === this.coll && this.defaultYAxisOptions, [this.defaultTopAxisOptions, this.defaultRightAxisOptions, this.defaultBottomAxisOptions, this.defaultLeftAxisOptions][this.side], merge(defaultOptions[this.coll], userOptions));
                each(this, "afterSetOptions", {
                    userOptions: userOptions
                });
            },
            defaultLabelFormatter: function () {
                var axis = this.axis;
                var value = this.value;
                var d = axis.chart.time;
                var categories = axis.categories;
                var v = this.dateTimeLabelFormat;
                var l = defaultOptions.lang;
                var items = l.numericSymbols;
                l = l.numericSymbolMagnitude || 1E3;
                var i = items && items.length;
                var type = axis.options.labels.format;
                axis = axis.isLog ? Math.abs(value) : axis.tickInterval;
                var c = this.chart;
                var parseInt = c.numberFormatter;
                if (type) {
                    var ret = format(type, this, c);
                } else {
                    if (categories) {
                        ret = value;
                    } else {
                        if (v) {
                            ret = d.dateFormat(v, value);
                        } else {
                            if (i && 1E3 <= axis) {
                                for (; i-- && "undefined" === typeof ret;) {
                                    /** @type {number} */
                                    d = Math.pow(l, i + 1);
                                    if (axis >= d && 0 === 10 * value % d && null !== items[i] && 0 !== value) {
                                        ret = parseInt(value / d, -1) + items[i];
                                    }
                                }
                            }
                        }
                    }
                }
                if ("undefined" === typeof ret) {
                    ret = 1E4 <= Math.abs(value) ? parseInt(value, -1) : parseInt(value, -1, void 0, "");
                }
                return ret;
            },
            getSeriesExtremes: function () {
                var axis = this;
                var chart = axis.chart;
                var el;
                each(this, "getSeriesExtremes", null, function () {
                    /** @type {boolean} */
                    axis.hasVisibleSeries = false;
                    /** @type {null} */
                    axis.dataMin = axis.dataMax = axis.threshold = null;
                    /** @type {boolean} */
                    axis.softThreshold = !axis.isXAxis;
                    if (axis.buildStacks) {
                        axis.buildStacks();
                    }
                    axis.series.forEach(function (options) {
                        if (options.visible || !chart.options.chart.ignoreHiddenSeries) {
                            var o = options.options;
                            var threshold = o.threshold;
                            /** @type {boolean} */
                            axis.hasVisibleSeries = true;
                            if (axis.positiveValuesOnly && 0 >= threshold) {
                                /** @type {null} */
                                threshold = null;
                            }
                            if (axis.isXAxis) {
                                if (o = options.xData, o.length) {
                                    el = options.getXExtremes(o);
                                    var val = el.min;
                                    var value = el.max;
                                    if (!(map(val) || val instanceof Date)) {
                                        o = o.filter(map);
                                        el = options.getXExtremes(o);
                                        val = el.min;
                                        value = el.max;
                                    }
                                    if (o.length) {
                                        /** @type {number} */
                                        axis.dataMin = Math.min(pick(axis.dataMin, val), val);
                                        /** @type {number} */
                                        axis.dataMax = Math.max(pick(axis.dataMax, value), value);
                                    }
                                }
                            } else {
                                if (options.getExtremes(), value = options.dataMax, val = options.dataMin, defined(val) && defined(value) && (axis.dataMin = Math.min(pick(axis.dataMin, val), val), axis.dataMax = Math.max(pick(axis.dataMax, value), value)), defined(threshold) && (axis.threshold = threshold), !o.softThreshold || axis.positiveValuesOnly) {
                                    /** @type {boolean} */
                                    axis.softThreshold = false;
                                }
                            }
                        }
                    });
                });
                each(this, "afterGetSeriesExtremes");
            },
            translate: function (val, table, data, old, handleLog, pointPlacement) {
                var axis = this.linkedParent || this;
                /** @type {number} */
                var sign = 1;
                /** @type {number} */
                var cvsOffset = 0;
                var localA = old ? axis.oldTransA : axis.transA;
                old = old ? axis.oldMin : axis.min;
                var minPixelPadding = axis.minPixelPadding;
                handleLog = (axis.isOrdinal || axis.isBroken || axis.isLog && handleLog) && axis.lin2val;
                if (!localA) {
                    localA = axis.transA;
                }
                if (data) {
                    /** @type {number} */
                    sign = sign * -1;
                    cvsOffset = axis.len;
                }
                if (axis.reversed) {
                    /** @type {number} */
                    sign = sign * -1;
                    /** @type {number} */
                    cvsOffset = cvsOffset - sign * (axis.sector || axis.len);
                }
                if (table) {
                    val = (val * sign + cvsOffset - minPixelPadding) / localA + old;
                    if (handleLog) {
                        val = axis.lin2val(val);
                    }
                } else {
                    if (handleLog) {
                        val = axis.val2lin(val);
                    }
                    val = map(old) ? sign * (val - old) * localA + cvsOffset + sign * minPixelPadding + (map(pointPlacement) ? localA * pointPlacement : 0) : void 0;
                }
                return val;
            },
            toPixels: function (value, paneCoordinates) {
                return this.translate(value, false, !this.horiz, null, true) + (paneCoordinates ? 0 : this.pos);
            },
            toValue: function (pixel, paneCoordinates) {
                return this.translate(pixel - (paneCoordinates ? 0 : this.pos), true, !this.horiz, null, true);
            },
            getPlotLinePath: function (options) {
                var axis = this;
                var chart = axis.chart;
                var y = axis.left;
                var x = axis.top;
                var old = options.old;
                var min = options.value;
                var value = options.translatedValue;
                var lineWidth = options.lineWidth;
                var force = options.force;
                var t;
                var y1;
                var i;
                var y2;
                var cHeight = old && chart.oldChartHeight || chart.chartHeight;
                var max = old && chart.oldChartWidth || chart.chartWidth;
                var exist;
                var transB = axis.transB;
                /**
                 * @param {number} x
                 * @param {number} min
                 * @param {number} value
                 * @return {?}
                 */
                var between = function (x, min, value) {
                    if ("pass" !== force && x < min || x > value) {
                        if (force) {
                            x = add(x, min, value);
                        } else {
                            /** @type {boolean} */
                            exist = true;
                        }
                    }
                    return x;
                };
                options = {
                    value: min,
                    lineWidth: lineWidth,
                    old: old,
                    force: force,
                    acrossPanes: options.acrossPanes,
                    translatedValue: value
                };
                each(this, "getPlotLinePath", options, function (orientedFile) {
                    value = pick(value, axis.translate(min, null, null, old));
                    value = add(value, -1E5, 1E5);
                    /** @type {number} */
                    t = i = Math.round(value + transB);
                    /** @type {number} */
                    y1 = y2 = Math.round(cHeight - value - transB);
                    if (map(value)) {
                        if (axis.horiz) {
                            y1 = x;
                            /** @type {number} */
                            y2 = cHeight - axis.bottom;
                            t = i = between(t, y, y + axis.width);
                        } else {
                            t = y;
                            /** @type {number} */
                            i = max - axis.right;
                            y1 = y2 = between(y1, x, x + axis.height);
                        }
                    } else {
                        /** @type {boolean} */
                        exist = true;
                        /** @type {boolean} */
                        force = false;
                    }
                    orientedFile.path = exist && !force ? null : chart.renderer.crispLine(["M", t, y1, "L", i, y2], lineWidth || 1);
                });
                return options.path;
            },
            getLinearTickPositions: function (tickInterval, pos, min) {
                var value = correctFloat(Math.floor(pos / tickInterval) * tickInterval);
                min = correctFloat(Math.ceil(min / tickInterval) * tickInterval);
                /** @type {!Array} */
                var tickPositions = [];
                var startStringPos;
                if (correctFloat(value + tickInterval) === value) {
                    /** @type {number} */
                    startStringPos = 20;
                }
                if (this.single) {
                    return [pos];
                }
                pos = value;
                for (; pos <= min;) {
                    tickPositions.push(pos);
                    pos = correctFloat(pos + tickInterval, startStringPos);
                    if (pos === right) {
                        break;
                    }
                    /** @type {number} */
                    var right = pos;
                }
                return tickPositions;
            },
            getMinorTickInterval: function () {
                var options = this.options;
                return true === options.minorTicks ? pick(options.minorTickInterval, "auto") : false === options.minorTicks ? null : options.minorTickInterval;
            },
            getMinorTickPositions: function () {
                var axis = this;
                var pos = axis.options;
                var tickPositions = axis.tickPositions;
                var minorTickInterval = axis.minorTickInterval;
                /** @type {!Array} */
                var minorTickPositions = [];
                var max = axis.pointRangePadding || 0;
                /** @type {number} */
                var min = axis.min - max;
                max = axis.max + max;
                /** @type {number} */
                var range = max - min;
                if (range && range / minorTickInterval < axis.len / 3) {
                    if (axis.isLog) {
                        this.paddedTicks.forEach(function (b, i, paddedTicks) {
                            if (i) {
                                minorTickPositions.push.apply(minorTickPositions, axis.getLogTickPositions(minorTickInterval, paddedTicks[i - 1], paddedTicks[i], true));
                            }
                        });
                    } else {
                        if (axis.isDatetimeAxis && "auto" === this.getMinorTickInterval()) {
                            /** @type {!Array<?>} */
                            minorTickPositions = minorTickPositions.concat(axis.getTimeTicks(axis.normalizeTimeTickInterval(minorTickInterval), min, max, pos.startOfWeek));
                        } else {
                            /** @type {number} */
                            pos = min + (tickPositions[0] - min) % minorTickInterval;
                            for (; pos <= max && pos !== minorTickPositions[0]; pos = pos + minorTickInterval) {
                                minorTickPositions.push(pos);
                            }
                        }
                    }
                }
                if (0 !== minorTickPositions.length) {
                    axis.trimTicks(minorTickPositions);
                }
                return minorTickPositions;
            },
            adjustForMinRange: function () {
                var options = this.options;
                var min = this.min;
                var max = this.max;
                var index;
                var i;
                var restore;
                var xData;
                var _i;
                if (this.isXAxis && "undefined" === typeof this.minRange && !this.isLog) {
                    if (defined(options.min) || defined(options.max)) {
                        /** @type {null} */
                        this.minRange = null;
                    } else {
                        this.series.forEach(function (series) {
                            xData = series.xData;
                            /** @type {number} */
                            i = _i = series.xIncrement ? 1 : xData.length - 1;
                            for (; 0 < i; i--) {
                                if (restore = xData[i] - xData[i - 1], "undefined" === typeof index || restore < index) {
                                    /** @type {number} */
                                    index = restore;
                                }
                            }
                        });
                        /** @type {number} */
                        this.minRange = Math.min(5 * index, this.dataMax - this.dataMin);
                    }
                }
                if (max - min < this.minRange) {
                    /** @type {boolean} */
                    var l = this.dataMax - this.dataMin >= this.minRange;
                    var minRange = this.minRange;
                    /** @type {number} */
                    var minArgs = (minRange - max + min) / 2;
                    /** @type {!Array} */
                    minArgs = [min - minArgs, pick(options.min, min - minArgs)];
                    if (l) {
                        minArgs[2] = this.isLog ? this.log2lin(this.dataMin) : this.dataMin;
                    }
                    min = arrayMax(minArgs);
                    /** @type {!Array} */
                    max = [min + minRange, pick(options.max, min + minRange)];
                    if (l) {
                        max[2] = this.isLog ? this.log2lin(this.dataMax) : this.dataMax;
                    }
                    max = arrayMin(max);
                    if (max - min < minRange) {
                        /** @type {number} */
                        minArgs[0] = max - minRange;
                        minArgs[1] = pick(options.min, max - minRange);
                        min = arrayMax(minArgs);
                    }
                }
                this.min = min;
                this.max = max;
            },
            getClosest: function () {
                var a;
                if (this.categories) {
                    /** @type {number} */
                    a = 1;
                } else {
                    this.series.forEach(function (series) {
                        var b = series.closestPointRange;
                        var g = series.visible || !series.chart.options.chart.ignoreHiddenSeries;
                        if (!series.noSharedTooltip && defined(b) && g) {
                            a = defined(a) ? Math.min(a, b) : b;
                        }
                    });
                }
                return a;
            },
            nameToX: function (point) {
                var explicitCategories = isArray(this.categories);
                var r = explicitCategories ? this.categories : this.names;
                var segmentX = point.options.x;
                /** @type {boolean} */
                point.series.requireSorting = false;
                if (!defined(segmentX)) {
                    segmentX = false === this.options.uniqueNames ? point.series.autoIncrement() : explicitCategories ? r.indexOf(point.name) : pick(r.keys[point.name], -1);
                }
                if (-1 === segmentX) {
                    if (!explicitCategories) {
                        var x = r.length;
                    }
                } else {
                    x = segmentX;
                }
                if ("undefined" !== typeof x) {
                    this.names[x] = point.name;
                    this.names.keys[point.name] = x;
                }
                return x;
            },
            updateNames: function () {
                var axis = this;
                var a = this.names;
                if (0 < a.length) {
                    Object.keys(a.keys).forEach(function (n) {
                        delete a.keys[n];
                    });
                    /** @type {number} */
                    a.length = 0;
                    this.minRange = this.userMinRange;
                    (this.series || []).forEach(function (series) {
                        /** @type {null} */
                        series.xIncrement = null;
                        if (!series.points || series.isDirtyData) {
                            /** @type {number} */
                            axis.max = Math.max(axis.max, series.xData.length - 1);
                            series.processData();
                            series.generatePoints();
                        }
                        series.data.forEach(function (point, i) {
                            if (point && point.options && "undefined" !== typeof point.name) {
                                var value = axis.nameToX(point);
                                if ("undefined" !== typeof value && value !== point.x) {
                                    point.x = value;
                                    series.xData[i] = value;
                                }
                            }
                        });
                    });
                }
            },
            setAxisTranslation: function (saveOld) {
                var axis = this;
                /** @type {number} */
                var index = axis.max - axis.min;
                var a = axis.axisPointRange || 0;
                /** @type {number} */
                var pos = 0;
                /** @type {number} */
                var length = 0;
                var linkedParent = axis.linkedParent;
                /** @type {boolean} */
                var hasCategories = !!axis.categories;
                var transA = axis.transA;
                var isXAxis = axis.isXAxis;
                if (isXAxis || hasCategories || a) {
                    var closestPointRange = axis.getClosest();
                    if (linkedParent) {
                        pos = linkedParent.minPointOffset;
                        length = linkedParent.pointRangePadding;
                    } else {
                        axis.series.forEach(function (series) {
                            var n = hasCategories ? 1 : isXAxis ? pick(series.options.pointRange, closestPointRange, 0) : axis.axisPointRange || 0;
                            var number = series.options.pointPlacement;
                            /** @type {number} */
                            a = Math.max(a, n);
                            if (!axis.single || hasCategories) {
                                series = seriesTypes.xrange && series instanceof seriesTypes.xrange ? !isXAxis : isXAxis;
                                /** @type {number} */
                                pos = Math.max(pos, series && isString(number) ? 0 : n / 2);
                                /** @type {number} */
                                length = Math.max(length, series && "on" === number ? 0 : n);
                            }
                        });
                    }
                    /** @type {number} */
                    linkedParent = axis.ordinalSlope && closestPointRange ? axis.ordinalSlope / closestPointRange : 1;
                    axis.minPointOffset = pos = pos * linkedParent;
                    axis.pointRangePadding = length = length * linkedParent;
                    /** @type {number} */
                    axis.pointRange = Math.min(a, axis.single && hasCategories ? 1 : index);
                    if (isXAxis) {
                        axis.closestPointRange = closestPointRange;
                    }
                }
                if (saveOld) {
                    axis.oldTransA = transA;
                }
                axis.translationSlope = axis.transA = transA = axis.staticScale || axis.len / (index + length || 1);
                axis.transB = axis.horiz ? axis.left : axis.bottom;
                /** @type {number} */
                axis.minPixelPadding = transA * pos;
                each(this, "afterSetAxisTranslation");
            },
            minFromRange: function () {
                return this.max - this.range;
            },
            setTickInterval: function (minTickInterval) {
                var axis = this;
                var length = axis.chart;
                var options = axis.options;
                var isLog = axis.isLog;
                var isDatetimeAxis = axis.isDatetimeAxis;
                var isXAxis = axis.isXAxis;
                var isLinked = axis.isLinked;
                var maxPadding = options.maxPadding;
                var minPadding = options.minPadding;
                var tickIntervalOption = options.tickInterval;
                var m = options.tickPixelInterval;
                var categories = axis.categories;
                var threshold = map(axis.threshold) ? axis.threshold : null;
                var softThreshold = axis.softThreshold;
                if (!(isDatetimeAxis || categories || isLinked)) {
                    this.getTickAmount();
                }
                var left = pick(axis.userMin, options.min);
                var hardMax = pick(axis.userMax, options.max);
                if (isLinked) {
                    axis.linkedParent = length[axis.coll][options.linkedTo];
                    var xAxis = axis.linkedParent.getExtremes();
                    axis.min = pick(xAxis.min, xAxis.dataMin);
                    axis.max = pick(xAxis.max, xAxis.dataMax);
                    if (options.type !== axis.linkedParent.options.type) {
                        Highcharts.error(11, 1, length);
                    }
                } else {
                    if (!softThreshold && defined(threshold)) {
                        if (axis.dataMin >= threshold) {
                            xAxis = threshold;
                            /** @type {number} */
                            minPadding = 0;
                        } else {
                            if (axis.dataMax <= threshold) {
                                var thresholdMax = threshold;
                                /** @type {number} */
                                maxPadding = 0;
                            }
                        }
                    }
                    axis.min = pick(left, xAxis, axis.dataMin);
                    axis.max = pick(hardMax, thresholdMax, axis.dataMax);
                }
                if (isLog) {
                    if (axis.positiveValuesOnly && !minTickInterval && 0 >= Math.min(axis.min, pick(axis.dataMin, axis.min))) {
                        Highcharts.error(10, 1, length);
                    }
                    axis.min = correctFloat(axis.log2lin(axis.min), 16);
                    axis.max = correctFloat(axis.log2lin(axis.max), 16);
                }
                if (axis.range && defined(axis.max)) {
                    /** @type {number} */
                    axis.userMin = axis.min = left = Math.max(axis.dataMin, axis.minFromRange());
                    axis.userMax = hardMax = axis.max;
                    /** @type {null} */
                    axis.range = null;
                }
                each(axis, "foundExtremes");
                if (axis.beforePadding) {
                    axis.beforePadding();
                }
                axis.adjustForMinRange();
                if (!(categories || axis.axisPointRange || axis.usePercentage || isLinked) && defined(axis.min) && defined(axis.max) && (length = axis.max - axis.min)) {
                    if (!defined(left) && minPadding) {
                        axis.min -= length * minPadding;
                    }
                    if (!defined(hardMax) && maxPadding) {
                        axis.max += length * maxPadding;
                    }
                }
                if (!map(axis.userMin)) {
                    if (map(options.softMin) && options.softMin < axis.min) {
                        axis.min = left = options.softMin;
                    }
                    if (map(options.floor)) {
                        /** @type {number} */
                        axis.min = Math.max(axis.min, options.floor);
                    }
                }
                if (!map(axis.userMax)) {
                    if (map(options.softMax) && options.softMax > axis.max) {
                        axis.max = hardMax = options.softMax;
                    }
                    if (map(options.ceiling)) {
                        /** @type {number} */
                        axis.max = Math.min(axis.max, options.ceiling);
                    }
                }
                if (softThreshold && defined(axis.dataMin)) {
                    threshold = threshold || 0;
                    if (!defined(left) && axis.min < threshold && axis.dataMin >= threshold) {
                        axis.min = axis.options.minRange ? Math.min(threshold, axis.max - axis.minRange) : threshold;
                    } else {
                        if (!defined(hardMax) && axis.max > threshold && axis.dataMax <= threshold) {
                            axis.max = axis.options.minRange ? Math.max(threshold, axis.min + axis.minRange) : threshold;
                        }
                    }
                }
                axis.tickInterval = axis.min === axis.max || "undefined" === typeof axis.min || "undefined" === typeof axis.max ? 1 : isLinked && !tickIntervalOption && m === axis.linkedParent.options.tickPixelInterval ? tickIntervalOption = axis.linkedParent.tickInterval : pick(tickIntervalOption, this.tickAmount ? (axis.max - axis.min) / Math.max(this.tickAmount - 1, 1) : void 0, categories ? 1 : (axis.max - axis.min) * m / Math.max(axis.len, m));
                if (isXAxis && !minTickInterval) {
                    axis.series.forEach(function (s) {
                        s.processData(axis.min !== axis.oldMin || axis.max !== axis.oldMax);
                    });
                }
                axis.setAxisTranslation(true);
                if (axis.beforeSetTickPositions) {
                    axis.beforeSetTickPositions();
                }
                if (axis.postProcessTickInterval) {
                    axis.tickInterval = axis.postProcessTickInterval(axis.tickInterval);
                }
                if (axis.pointRange && !tickIntervalOption) {
                    /** @type {number} */
                    axis.tickInterval = Math.max(axis.pointRange, axis.tickInterval);
                }
                minTickInterval = pick(options.minTickInterval, axis.isDatetimeAxis && axis.closestPointRange);
                if (!tickIntervalOption && axis.tickInterval < minTickInterval) {
                    /** @type {string} */
                    axis.tickInterval = minTickInterval;
                }
                if (!(isDatetimeAxis || isLog || tickIntervalOption)) {
                    axis.tickInterval = normalizeTickInterval(axis.tickInterval, null, getMagnitude(axis.tickInterval), pick(options.allowDecimals, !(.5 < axis.tickInterval && 5 > axis.tickInterval && 1E3 < axis.max && 9999 > axis.max)), !!this.tickAmount);
                }
                if (!this.tickAmount) {
                    axis.tickInterval = axis.unsquish();
                }
                this.setTickPositions();
            },
            setTickPositions: function () {
                var options = this.options;
                var tickPositionsOption = options.tickPositions;
                var tickPositions = this.getMinorTickInterval();
                var tickPositioner = options.tickPositioner;
                var startOnTick = options.startOnTick;
                var endOnTick = options.endOnTick;
                /** @type {number} */
                this.tickmarkOffset = this.categories && "between" === options.tickmarkPlacement && 1 === this.tickInterval ? .5 : 0;
                this.minorTickInterval = "auto" === tickPositions && this.tickInterval ? this.tickInterval / 5 : tickPositions;
                this.single = this.min === this.max && defined(this.min) && !this.tickAmount && (parseInt(this.min, 10) === this.min || false !== options.allowDecimals);
                this.tickPositions = tickPositions = tickPositionsOption && tickPositionsOption.slice();
                if (!tickPositions && (!this.ordinalPositions && (this.max - this.min) / this.tickInterval > Math.max(2 * this.len, 200) ? (tickPositions = [this.min, this.max], Highcharts.error(19, false, this.chart)) : tickPositions = this.isDatetimeAxis ? this.getTimeTicks(this.normalizeTimeTickInterval(this.tickInterval, options.units), this.min, this.max, options.startOfWeek, this.ordinalPositions, this.closestPointRange, true) : this.isLog ? this.getLogTickPositions(this.tickInterval, this.min, this.max) :
                    this.getLinearTickPositions(this.tickInterval, this.min, this.max), tickPositions.length > this.len && (tickPositions = [tickPositions[0], tickPositions.pop()], tickPositions[0] === tickPositions[1] && (tickPositions.length = 1)), this.tickPositions = tickPositions, tickPositioner && (tickPositioner = tickPositioner.apply(this, [this.min, this.max])))) {
                    this.tickPositions = tickPositions = tickPositioner;
                }
                this.paddedTicks = tickPositions.slice(0);
                this.trimTicks(tickPositions, startOnTick, endOnTick);
                if (!this.isLinked) {
                    if (this.single && 2 > tickPositions.length && !this.categories) {
                        this.min -= .5;
                        this.max += .5;
                    }
                    if (!(tickPositionsOption || tickPositioner)) {
                        this.adjustTickAmount();
                    }
                }
                each(this, "afterSetTickPositions");
            },
            trimTicks: function (tickPositions, startOnTick, endOnTick) {
                var roundedMin = tickPositions[0];
                var roundedMax = tickPositions[tickPositions.length - 1];
                var minPointOffset = this.minPointOffset || 0;
                each(this, "trimTicks");
                if (!this.isLinked) {
                    if (startOnTick && -Infinity !== roundedMin) {
                        this.min = roundedMin;
                    } else {
                        for (; this.min - minPointOffset > tickPositions[0];) {
                            tickPositions.shift();
                        }
                    }
                    if (endOnTick) {
                        this.max = roundedMax;
                    } else {
                        for (; this.max + minPointOffset < tickPositions[tickPositions.length - 1];) {
                            tickPositions.pop();
                        }
                    }
                    if (0 === tickPositions.length && defined(roundedMin) && !this.options.tickPositions) {
                        tickPositions.push((roundedMax + roundedMin) / 2);
                    }
                }
            },
            alignToOthers: function () {
                var _baseSegment = {};
                var hasOther;
                var options = this.options;
                if (!(false === this.chart.options.chart.alignTicks || false === options.alignTicks || false === options.startOnTick || false === options.endOnTick || this.isLog)) {
                    this.chart[this.coll].forEach(function (that) {
                        var axis = that.options;
                        /** @type {string} */
                        axis = [that.horiz ? axis.left : axis.top, axis.width, axis.height, axis.pane].join();
                        if (that.series.length) {
                            if (_baseSegment[axis]) {
                                /** @type {boolean} */
                                hasOther = true;
                            } else {
                                /** @type {number} */
                                _baseSegment[axis] = 1;
                            }
                        }
                    });
                }
                return hasOther;
            },
            getTickAmount: function () {
                var options = this.options;
                var tickAmount = options.tickAmount;
                var tickPixelInterval = options.tickPixelInterval;
                if (!defined(options.tickInterval) && this.len < tickPixelInterval && !this.isRadial && !this.isLog && options.startOnTick && options.endOnTick) {
                    /** @type {number} */
                    tickAmount = 2;
                }
                if (!tickAmount && this.alignToOthers()) {
                    /** @type {number} */
                    tickAmount = Math.ceil(this.len / tickPixelInterval) + 1;
                }
                if (4 > tickAmount) {
                    this.finalTickAmt = tickAmount;
                    /** @type {number} */
                    tickAmount = 5;
                }
                this.tickAmount = tickAmount;
            },
            adjustTickAmount: function () {
                var b = this.options;
                var a = this.tickInterval;
                var d = this.tickPositions;
                var tickAmount = this.tickAmount;
                var finalTickAmt = this.finalTickAmt;
                var currentTickAmount = d && d.length;
                var out = pick(this.threshold, this.softThreshold ? 0 : null);
                var val;
                if (this.hasData()) {
                    if (currentTickAmount < tickAmount) {
                        val = this.min;
                        for (; d.length < tickAmount;) {
                            if (d.length % 2 || val === out) {
                                d.push(correctFloat(d[d.length - 1] + a));
                            } else {
                                d.unshift(correctFloat(d[0] - a));
                            }
                        }
                        this.transA *= (currentTickAmount - 1) / (tickAmount - 1);
                        this.min = b.startOnTick ? d[0] : Math.min(this.min, d[0]);
                        this.max = b.endOnTick ? d[d.length - 1] : Math.max(this.max, d[d.length - 1]);
                    } else {
                        if (currentTickAmount > tickAmount) {
                            this.tickInterval *= 2;
                            this.setTickPositions();
                        }
                    }
                    if (defined(finalTickAmt)) {
                        a = b = d.length;
                        for (; a--;) {
                            if (3 === finalTickAmt && 1 === a % 2 || 2 >= finalTickAmt && 0 < a && a < b - 1) {
                                d.splice(a, 1);
                            }
                        }
                        this.finalTickAmt = void 0;
                    }
                }
            },
            setScale: function () {
                var componentCtor = this.series.some(function (series) {
                    return series.isDirtyData || series.isDirty || series.xAxis && series.xAxis.isDirty;
                });
                var withKey;
                this.oldMin = this.min;
                this.oldMax = this.max;
                this.oldAxisLength = this.len;
                this.setAxisSize();
                if ((withKey = this.len !== this.oldAxisLength) || componentCtor || this.isLinked || this.forceRedraw || this.userMin !== this.oldUserMin || this.userMax !== this.oldUserMax || this.alignToOthers()) {
                    if (this.resetStacks) {
                        this.resetStacks();
                    }
                    /** @type {boolean} */
                    this.forceRedraw = false;
                    this.getSeriesExtremes();
                    this.setTickInterval();
                    this.oldUserMin = this.userMin;
                    this.oldUserMax = this.userMax;
                    if (!this.isDirty) {
                        /** @type {boolean} */
                        this.isDirty = withKey || this.min !== this.oldMin || this.max !== this.oldMax;
                    }
                } else {
                    if (this.cleanStacks) {
                        this.cleanStacks();
                    }
                }
                each(this, "afterSetScale");
            },
            setExtremes: function (newMin, newMax, redraw, animation, result) {
                var axis = this;
                var chart = axis.chart;
                redraw = pick(redraw, true);
                axis.series.forEach(function (exports) {
                    delete exports.kdTree;
                });
                result = extend(result, {
                    min: newMin,
                    max: newMax
                });
                each(axis, "setExtremes", result, function () {
                    /** @type {number} */
                    axis.userMin = newMin;
                    /** @type {number} */
                    axis.userMax = newMax;
                    axis.eventArgs = result;
                    if (redraw) {
                        chart.redraw(animation);
                    }
                });
            },
            zoom: function (end, started) {
                var opacity = this.dataMin;
                var width = this.dataMax;
                var o = this.options;
                /** @type {number} */
                var min = Math.min(opacity, pick(o.min, opacity));
                /** @type {number} */
                var max = Math.max(width, pick(o.max, width));
                end = {
                    newMin: end,
                    newMax: started
                };
                each(this, "zoom", end, function (p) {
                    var newMin = p.newMin;
                    var newMax = p.newMax;
                    if (newMin !== this.min || newMax !== this.max) {
                        if (!this.allowZoomOutside) {
                            if (defined(opacity)) {
                                if (newMin < min) {
                                    /** @type {number} */
                                    newMin = min;
                                }
                                if (newMin > max) {
                                    /** @type {number} */
                                    newMin = max;
                                }
                            }
                            if (defined(width)) {
                                if (newMax < min) {
                                    /** @type {number} */
                                    newMax = min;
                                }
                                if (newMax > max) {
                                    /** @type {number} */
                                    newMax = max;
                                }
                            }
                        }
                        /** @type {boolean} */
                        this.displayBtn = "undefined" !== typeof newMin || "undefined" !== typeof newMax;
                        this.setExtremes(newMin, newMax, false, void 0, {
                            trigger: "zoom"
                        });
                    }
                    /** @type {boolean} */
                    p.zoomed = true;
                });
                return end.zoomed;
            },
            setAxisSize: function () {
                var chart = this.chart;
                var left = this.options;
                var offsets = left.offsets || [0, 0, 0, 0];
                var horiz = this.horiz;
                /** @type {number} */
                var width = this.width = Math.round(bounce(pick(left.width, chart.plotWidth - offsets[3] + offsets[1]), chart.plotWidth));
                /** @type {number} */
                var height = this.height = Math.round(bounce(pick(left.height, chart.plotHeight - offsets[0] + offsets[2]), chart.plotHeight));
                /** @type {number} */
                var top = this.top = Math.round(bounce(pick(left.top, chart.plotTop + offsets[0]), chart.plotHeight, chart.plotTop));
                /** @type {number} */
                left = this.left = Math.round(bounce(pick(left.left, chart.plotLeft + offsets[3]), chart.plotWidth, chart.plotLeft));
                /** @type {number} */
                this.bottom = chart.chartHeight - height - top;
                /** @type {number} */
                this.right = chart.chartWidth - width - left;
                /** @type {number} */
                this.len = Math.max(horiz ? width : height, 0);
                /** @type {number} */
                this.pos = horiz ? left : top;
            },
            getExtremes: function () {
                var isLog = this.isLog;
                return {
                    min: isLog ? correctFloat(this.lin2log(this.min)) : this.min,
                    max: isLog ? correctFloat(this.lin2log(this.max)) : this.max,
                    dataMin: this.dataMin,
                    dataMax: this.dataMax,
                    userMin: this.userMin,
                    userMax: this.userMax
                };
            },
            getThreshold: function (n) {
                var val = this.isLog;
                var len = val ? this.lin2log(this.min) : this.min;
                val = val ? this.lin2log(this.max) : this.max;
                if (null === n || -Infinity === n) {
                    n = len;
                } else {
                    if (Infinity === n) {
                        n = val;
                    } else {
                        if (len > n) {
                            n = len;
                        } else {
                            if (val < n) {
                                n = val;
                            }
                        }
                    }
                }
                return this.translate(n, 0, 1, 0, 1);
            },
            autoLabelAlign: function (result) {
                /** @type {number} */
                var t = (pick(result, 0) - 90 * this.side + 720) % 360;
                result = {
                    align: "center"
                };
                each(this, "autoLabelAlign", result, function (table) {
                    if (15 < t && 165 > t) {
                        /** @type {string} */
                        table.align = "right";
                    } else {
                        if (195 < t && 345 > t) {
                            /** @type {string} */
                            table.align = "left";
                        }
                    }
                });
                return result.align;
            },
            tickSize: function (prefix) {
                var options = this.options;
                var x = options[prefix + "Length"];
                var detectOpts = pick(options[prefix + "Width"], "tick" === prefix && this.isXAxis && !this.categories ? 1 : 0);
                if (detectOpts && x) {
                    if ("inside" === options[prefix + "Position"]) {
                        /** @type {number} */
                        x = -x;
                    }
                    /** @type {!Array} */
                    var queuex = [x, detectOpts];
                }
                prefix = {
                    tickSize: queuex
                };
                each(this, "afterTickSize", prefix);
                return prefix.tickSize;
            },
            labelMetrics: function () {
                var i = this.tickPositions && this.tickPositions[0] || 0;
                return this.chart.renderer.fontMetrics(this.options.labels.style && this.options.labels.style.fontSize, this.ticks[i] && this.ticks[i].label);
            },
            unsquish: function () {
                var labelOptions = this.options.labels;
                var horiz = this.horiz;
                var tickInterval = this.tickInterval;
                var newTickInterval = tickInterval;
                /** @type {number} */
                var slotSize = this.len / (((this.categories ? 1 : 0) + this.max - this.min) / tickInterval);
                var rotation;
                var rotationOption = labelOptions.rotation;
                var labelMetrics = this.labelMetrics();
                var step;
                /** @type {number} */
                var best_part_step_diff = Number.MAX_VALUE;
                var autoRotation;
                /** @type {number} */
                var range = this.max - this.min;
                /**
                 * @param {number} spaceNeeded
                 * @return {?}
                 */
                var getStep = function (spaceNeeded) {
                    /** @type {number} */
                    var step = spaceNeeded / (slotSize || 1);
                    /** @type {number} */
                    step = 1 < step ? Math.ceil(step) : 1;
                    if (step * tickInterval > range && Infinity !== spaceNeeded && Infinity !== slotSize && range) {
                        /** @type {number} */
                        step = Math.ceil(range / tickInterval);
                    }
                    return correctFloat(step * tickInterval);
                };
                if (horiz) {
                    if (autoRotation = !labelOptions.staggerLines && !labelOptions.step && (defined(rotationOption) ? [rotationOption] : slotSize < pick(labelOptions.autoRotationLimit, 80) && labelOptions.autoRotation)) {
                        autoRotation.forEach(function (rot) {
                            if (rot === rotationOption || rot && -90 <= rot && 90 >= rot) {
                                step = getStep(Math.abs(labelMetrics.h / Math.sin(deg2rad * rot)));
                                var tmp_step_diff = step + Math.abs(rot / 360);
                                if (tmp_step_diff < best_part_step_diff) {
                                    best_part_step_diff = tmp_step_diff;
                                    /** @type {number} */
                                    rotation = rot;
                                    newTickInterval = step;
                                }
                            }
                        });
                    }
                } else {
                    if (!labelOptions.step) {
                        newTickInterval = getStep(labelMetrics.h);
                    }
                }
                this.autoRotation = autoRotation;
                this.labelRotation = pick(rotation, rotationOption);
                return newTickInterval;
            },
            getSlotWidth: function (item) {
                var chart = this.chart;
                var horiz = this.horiz;
                var options = this.options.labels;
                /** @type {number} */
                var slotCount = Math.max(this.tickPositions.length - (this.categories ? 0 : 1), 1);
                var n = chart.margin[3];
                return item && item.slotWidth || horiz && 2 > (options.step || 0) && !options.rotation && (this.staggerLines || 1) * this.len / slotCount || !horiz && (options.style && parseInt(options.style.width, 10) || n && n - chart.spacing[3] || .33 * chart.chartWidth);
            },
            renderUnsquish: function () {
                var chart = this.chart;
                var renderer = chart.renderer;
                var tickPositions = this.tickPositions;
                var c = this.ticks;
                var labelOptions = this.options.labels;
                var obj = labelOptions && labelOptions.style || {};
                var horiz = this.horiz;
                var slotWidth = this.getSlotWidth();
                /** @type {number} */
                var i = Math.max(1, Math.round(slotWidth - 2 * (labelOptions.padding || 5)));
                var attr = {};
                var labelMetrics = this.labelMetrics();
                var s = labelOptions.style && labelOptions.style.textOverflow;
                /** @type {number} */
                var h = 0;
                if (!isString(labelOptions.rotation)) {
                    attr.rotation = labelOptions.rotation || 0;
                }
                tickPositions.forEach(function (b) {
                    b = c[b];
                    if (b.movedLabel) {
                        b.replaceMovedLabel();
                    }
                    if (b && b.label && b.label.textPxLength > h) {
                        h = b.label.textPxLength;
                    }
                });
                this.maxLabelLength = h;
                if (this.autoRotation) {
                    if (h > i && h > labelMetrics.h) {
                        attr.rotation = this.labelRotation;
                    } else {
                        /** @type {number} */
                        this.labelRotation = 0;
                    }
                } else {
                    if (slotWidth) {
                        /** @type {number} */
                        var w = i;
                        if (!s) {
                            /** @type {string} */
                            var window = "clip";
                            i = tickPositions.length;
                            for (; !horiz && i--;) {
                                var label = tickPositions[i];
                                if (label = c[label].label) {
                                    if (label.styles && "ellipsis" === label.styles.textOverflow) {
                                        label.css({
                                            textOverflow: "clip"
                                        });
                                    } else {
                                        if (label.textPxLength > slotWidth) {
                                            label.css({
                                                width: slotWidth + "px"
                                            });
                                        }
                                    }
                                    if (label.getBBox().height > this.len / tickPositions.length - (labelMetrics.h - labelMetrics.f)) {
                                        /** @type {string} */
                                        label.specificTextOverflow = "ellipsis";
                                    }
                                }
                            }
                        }
                    }
                }
                if (attr.rotation) {
                    w = h > .5 * chart.chartHeight ? .33 * chart.chartHeight : h;
                    if (!s) {
                        /** @type {string} */
                        window = "ellipsis";
                    }
                }
                if (this.labelAlign = labelOptions.align || this.autoLabelAlign(this.labelRotation)) {
                    attr.align = this.labelAlign;
                }
                tickPositions.forEach(function (p) {
                    var options = (p = c[p]) && p.label;
                    var h = obj.width;
                    var e = {};
                    if (options) {
                        options.attr(attr);
                        if (p.shortenLabel) {
                            p.shortenLabel();
                        } else {
                            if (w && !h && "nowrap" !== obj.whiteSpace && (w < options.textPxLength || "SPAN" === options.element.tagName)) {
                                e.width = w;
                                if (!s) {
                                    e.textOverflow = options.specificTextOverflow || window;
                                }
                                options.css(e);
                            } else {
                                if (options.styles && options.styles.width && !e.width && !h) {
                                    options.css({
                                        width: null
                                    });
                                }
                            }
                        }
                        delete options.specificTextOverflow;
                        p.rotation = attr.rotation;
                    }
                }, this);
                this.tickRotCorr = renderer.rotCorr(labelMetrics.b, this.labelRotation || 0, 0 !== this.side);
            },
            hasData: function () {
                return this.series.some(function (criterium) {
                    return criterium.hasData();
                }) || this.options.showEmpty && defined(this.min) && defined(this.max);
            },
            addTitle: function (display) {
                var renderer = this.chart.renderer;
                var horiz = this.horiz;
                var opposite = this.opposite;
                var axisTitleOptions = this.options.title;
                var textAlign;
                var width = this.chart.styledMode;
                if (!this.axisTitle) {
                    if (!(textAlign = axisTitleOptions.textAlign)) {
                        textAlign = (horiz ? {
                            low: "left",
                            middle: "center",
                            high: "right"
                        } : {
                            low: opposite ? "right" : "left",
                            middle: "center",
                            high: opposite ? "left" : "right"
                        })[axisTitleOptions.align];
                    }
                    this.axisTitle = renderer.text(axisTitleOptions.text, 0, 0, axisTitleOptions.useHTML).attr({
                        zIndex: 7,
                        rotation: axisTitleOptions.rotation || 0,
                        align: textAlign
                    }).addClass("highcharts-axis-title");
                    if (!width) {
                        this.axisTitle.css(merge(axisTitleOptions.style));
                    }
                    this.axisTitle.add(this.axisGroup);
                    /** @type {boolean} */
                    this.axisTitle.isNew = true;
                }
                if (!(width || axisTitleOptions.style.width || this.isRadial)) {
                    this.axisTitle.css({
                        width: this.len
                    });
                }
                this.axisTitle[display ? "show" : "hide"](display);
            },
            generateTick: function (pos) {
                var ticks = this.ticks;
                if (ticks[pos]) {
                    ticks[pos].addLabel();
                } else {
                    ticks[pos] = new Tick(this, pos);
                }
            },
            getOffset: function () {
                var axis = this;
                var chart = axis.chart;
                var renderer = chart.renderer;
                var options = axis.options;
                var range = axis.tickPositions;
                var ticks = axis.ticks;
                var horiz = axis.horiz;
                var side = axis.side;
                var key = chart.inverted && !axis.isZAxis ? [1, 0, 3, 2][side] : side;
                var showAxis;
                /** @type {number} */
                var titleOffset = 0;
                /** @type {number} */
                var min = 0;
                var axisTitleOptions = options.title;
                var labelOptions = options.labels;
                /** @type {number} */
                var i = 0;
                var axisOffset = chart.axisOffset;
                chart = chart.clipOffset;
                var directionFactor = [-1, 1, 1, -1][side];
                var classNames = options.className;
                var axisParent = axis.axisParent;
                var hasData = axis.hasData();
                axis.showAxis = showAxis = hasData || pick(options.showEmpty, true);
                axis.staggerLines = axis.horiz && labelOptions.staggerLines;
                if (!axis.axisGroup) {
                    axis.gridGroup = renderer.g("grid").attr({
                        zIndex: options.gridZIndex || 1
                    }).addClass("highcharts-" + this.coll.toLowerCase() + "-grid " + (classNames || "")).add(axisParent);
                    axis.axisGroup = renderer.g("axis").attr({
                        zIndex: options.zIndex || 2
                    }).addClass("highcharts-" + this.coll.toLowerCase() + " " + (classNames || "")).add(axisParent);
                    axis.labelGroup = renderer.g("axis-labels").attr({
                        zIndex: labelOptions.zIndex || 7
                    }).addClass("highcharts-" + axis.coll.toLowerCase() + "-labels " + (classNames || "")).add(axisParent);
                }
                if (hasData || axis.isLinked) {
                    range.forEach(function (pos, i) {
                        axis.generateTick(pos, i);
                    });
                    axis.renderUnsquish();
                    /** @type {boolean} */
                    axis.reserveSpaceDefault = 0 === side || 2 === side || {
                        1: "left",
                        3: "right"
                    }[side] === axis.labelAlign;
                    if (pick(labelOptions.reserveSpace, "center" === axis.labelAlign ? true : null, axis.reserveSpaceDefault)) {
                        range.forEach(function (pos) {
                            /** @type {number} */
                            i = Math.max(ticks[pos].getLabelSize(), i);
                        });
                    }
                    if (axis.staggerLines) {
                        /** @type {number} */
                        i = i * axis.staggerLines;
                    }
                    /** @type {number} */
                    axis.labelOffset = i * (axis.opposite ? -1 : 1);
                } else {
                    objectEach(ticks, function (anAlertDialog, minor) {
                        anAlertDialog.destroy();
                        delete ticks[minor];
                    });
                }
                if (axisTitleOptions && axisTitleOptions.text && false !== axisTitleOptions.enabled && (axis.addTitle(showAxis), showAxis && false !== axisTitleOptions.reserveSpace)) {
                    axis.titleOffset = titleOffset = axis.axisTitle.getBBox()[horiz ? "height" : "width"];
                    var titleOffsetOption = axisTitleOptions.offset;
                    min = defined(titleOffsetOption) ? 0 : pick(axisTitleOptions.margin, horiz ? 5 : 10);
                }
                axis.renderLine();
                /** @type {number} */
                axis.offset = directionFactor * pick(options.offset, axisOffset[side] ? axisOffset[side] + (options.margin || 0) : 0);
                axis.tickRotCorr = axis.tickRotCorr || {
                    x: 0,
                    y: 0
                };
                /** @type {number} */
                renderer = 0 === side ? -axis.labelMetrics().h : 2 === side ? axis.tickRotCorr.y : 0;
                min = Math.abs(i) + min;
                if (i) {
                    /** @type {number} */
                    min = min - renderer + directionFactor * (horiz ? pick(labelOptions.y, axis.tickRotCorr.y + 8 * directionFactor) : labelOptions.x);
                }
                axis.axisTitleMargin = pick(titleOffsetOption, min);
                if (axis.getMaxLabelDimensions) {
                    axis.maxLabelDimensions = axis.getMaxLabelDimensions(ticks, range);
                }
                horiz = this.tickSize("tick");
                /** @type {number} */
                axisOffset[side] = Math.max(axisOffset[side], axis.axisTitleMargin + titleOffset + directionFactor * axis.offset, min, range && range.length && horiz ? horiz[0] + directionFactor * axis.offset : 0);
                /** @type {number} */
                options = options.offset ? 0 : 2 * Math.floor(axis.axisLine.strokeWidth() / 2);
                /** @type {number} */
                chart[key] = Math.max(chart[key], options);
                each(this, "afterGetOffset");
            },
            getLinePath: function (lineWidth) {
                var chart = this.chart;
                var opposite = this.opposite;
                var x = this.offset;
                var horiz = this.horiz;
                var offset = this.left + (opposite ? this.width : 0) + x;
                x = chart.chartHeight - this.bottom - (opposite ? this.height : 0) + x;
                if (opposite) {
                    /** @type {number} */
                    lineWidth = lineWidth * -1;
                }
                return chart.renderer.crispLine(["M", horiz ? this.left : offset, horiz ? x : this.top, "L", horiz ? chart.chartWidth - this.right : offset, horiz ? x : chart.chartHeight - this.bottom], lineWidth);
            },
            renderLine: function () {
                if (!this.axisLine) {
                    this.axisLine = this.chart.renderer.path().addClass("highcharts-axis-line").add(this.axisGroup);
                    if (!this.chart.styledMode) {
                        this.axisLine.attr({
                            stroke: this.options.lineColor,
                            "stroke-width": this.options.lineWidth,
                            zIndex: 7
                        });
                    }
                }
            },
            getTitlePosition: function () {
                var horiz = this.horiz;
                var offAxis = this.left;
                var axisTop = this.top;
                var axisLength = this.len;
                var axisTitleOptions = this.options.title;
                var margin = horiz ? offAxis : axisTop;
                var opposite = this.opposite;
                var offset = this.offset;
                var xOption = axisTitleOptions.x || 0;
                var yOption = axisTitleOptions.y || 0;
                var text = this.axisTitle;
                var p = this.chart.renderer.fontMetrics(axisTitleOptions.style && axisTitleOptions.style.fontSize, text);
                /** @type {number} */
                text = Math.max(text.getBBox(null, 0).height - p.h - 1, 0);
                axisLength = {
                    low: margin + (horiz ? 0 : axisLength),
                    middle: margin + axisLength / 2,
                    high: margin + (horiz ? axisLength : 0)
                }[axisTitleOptions.align];
                offAxis = (horiz ? axisTop + this.height : offAxis) + (horiz ? 1 : -1) * (opposite ? -1 : 1) * this.axisTitleMargin + [-text, text, p.f, -text][this.side];
                horiz = {
                    x: horiz ? axisLength + xOption : offAxis + (opposite ? this.width : 0) + offset + xOption,
                    y: horiz ? offAxis + yOption - (opposite ? this.height : 0) + offset : axisLength + yOption
                };
                each(this, "afterGetTitlePosition", {
                    titlePosition: horiz
                });
                return horiz;
            },
            renderMinorTick: function (pos) {
                var model = this.chart.hasRendered && map(this.oldMin);
                var minorTicks = this.minorTicks;
                if (!minorTicks[pos]) {
                    minorTicks[pos] = new Tick(this, pos, "minor");
                }
                if (model && minorTicks[pos].isNew) {
                    minorTicks[pos].render(null, true);
                }
                minorTicks[pos].render(null, false, 1);
            },
            renderTick: function (pos, i) {
                var isLinked = this.isLinked;
                var ticks = this.ticks;
                var model = this.chart.hasRendered && map(this.oldMin);
                if (!isLinked || pos >= this.min && pos <= this.max) {
                    if (!ticks[pos]) {
                        ticks[pos] = new Tick(this, pos);
                    }
                    if (model && ticks[pos].isNew) {
                        ticks[pos].render(i, true, -1);
                    }
                    ticks[pos].render(i);
                }
            },
            render: function () {
                var axis = this;
                var chart = axis.chart;
                var options = axis.options;
                var isLog = axis.isLog;
                var isLinked = axis.isLinked;
                var tickPositions = axis.tickPositions;
                var axisTitle = axis.axisTitle;
                var ticks = axis.ticks;
                var minorTicks = axis.minorTicks;
                var alternateBands = axis.alternateBands;
                var stackLabelOptions = options.stackLabels;
                var alternateGridColor = options.alternateGridColor;
                var tickmarkOffset = axis.tickmarkOffset;
                var axisLine = axis.axisLine;
                var showAxis = axis.showAxis;
                var animation = animObject(chart.renderer.globalAnimation);
                var from;
                var to;
                /** @type {number} */
                axis.labelEdge.length = 0;
                /** @type {boolean} */
                axis.overlap = false;
                [ticks, minorTicks, alternateBands].forEach(function (data) {
                    objectEach(data, function (ifCondition) {
                        /** @type {boolean} */
                        ifCondition.isActive = false;
                    });
                });
                if (axis.hasData() || isLinked) {
                    if (axis.minorTickInterval && !axis.categories) {
                        axis.getMinorTickPositions().forEach(function (pos) {
                            axis.renderMinorTick(pos);
                        });
                    }
                    if (tickPositions.length) {
                        tickPositions.forEach(function (pos, i) {
                            axis.renderTick(pos, i);
                        });
                        if (tickmarkOffset && (0 === axis.min || axis.single)) {
                            if (!ticks[-1]) {
                                ticks[-1] = new Tick(axis, -1, null, true);
                            }
                            ticks[-1].render(-1);
                        }
                    }
                    if (alternateGridColor) {
                        tickPositions.forEach(function (pos, i) {
                            to = "undefined" !== typeof tickPositions[i + 1] ? tickPositions[i + 1] + tickmarkOffset : axis.max - tickmarkOffset;
                            if (0 === i % 2 && pos < axis.max && to <= axis.max + (chart.polar ? -tickmarkOffset : tickmarkOffset)) {
                                if (!alternateBands[pos]) {
                                    alternateBands[pos] = new Highcharts.PlotLineOrBand(axis);
                                }
                                from = pos + tickmarkOffset;
                                alternateBands[pos].options = {
                                    from: isLog ? axis.lin2log(from) : from,
                                    to: isLog ? axis.lin2log(to) : to,
                                    color: alternateGridColor
                                };
                                alternateBands[pos].render();
                                /** @type {boolean} */
                                alternateBands[pos].isActive = true;
                            }
                        });
                    }
                    if (!axis._addedPlotLB) {
                        (options.plotLines || []).concat(options.plotBands || []).forEach(function (plotLineOptions) {
                            axis.addPlotBandOrLine(plotLineOptions);
                        });
                        /** @type {boolean} */
                        axis._addedPlotLB = true;
                    }
                }
                [ticks, minorTicks, alternateBands].forEach(function (registry) {
                    var n;
                    /** @type {!Array} */
                    var queue = [];
                    var t = animation.duration;
                    objectEach(registry, function (subscribable, c) {
                        if (!subscribable.isActive) {
                            subscribable.render(c, false, 0);
                            /** @type {boolean} */
                            subscribable.isActive = false;
                            queue.push(c);
                        }
                    });
                    syncTimeout(function () {
                        /** @type {number} */
                        n = queue.length;
                        for (; n--;) {
                            if (registry[queue[n]] && !registry[queue[n]].isActive) {
                                registry[queue[n]].destroy();
                                delete registry[queue[n]];
                            }
                        }
                    }, registry !== alternateBands && chart.hasRendered && t ? t : 0);
                });
                if (axisLine) {
                    axisLine[axisLine.isPlaced ? "animate" : "attr"]({
                        d: this.getLinePath(axisLine.strokeWidth())
                    });
                    /** @type {boolean} */
                    axisLine.isPlaced = true;
                    axisLine[showAxis ? "show" : "hide"](showAxis);
                }
                if (axisTitle && showAxis) {
                    options = axis.getTitlePosition();
                    if (map(options.y)) {
                        axisTitle[axisTitle.isNew ? "attr" : "animate"](options);
                        /** @type {boolean} */
                        axisTitle.isNew = false;
                    } else {
                        axisTitle.attr("y", -9999);
                        /** @type {boolean} */
                        axisTitle.isNew = true;
                    }
                }
                if (stackLabelOptions && stackLabelOptions.enabled) {
                    axis.renderStackTotals();
                }
                /** @type {boolean} */
                axis.isDirty = false;
                each(this, "afterRender");
            },
            redraw: function () {
                if (this.visible) {
                    this.render();
                    this.plotLinesAndBands.forEach(function (_renderJs) {
                        _renderJs.render();
                    });
                }
                this.series.forEach(function (cur) {
                    /** @type {boolean} */
                    cur.isDirty = true;
                });
            },
            keepProps: "extKey hcEvents names series userMax userMin".split(" "),
            destroy: function (i) {
                var axis = this;
                var stacks = axis.stacks;
                var plotLinesAndBands = axis.plotLinesAndBands;
                var plotGroup;
                each(this, "destroy", {
                    keepEvents: i
                });
                if (!i) {
                    removeEvent(axis);
                }
                objectEach(stacks, function (coll, name) {
                    destroyObjectProperties(coll);
                    /** @type {null} */
                    stacks[name] = null;
                });
                [axis.ticks, axis.minorTicks, axis.alternateBands].forEach(function (coll) {
                    destroyObjectProperties(coll);
                });
                if (plotLinesAndBands) {
                    i = plotLinesAndBands.length;
                    for (; i--;) {
                        plotLinesAndBands[i].destroy();
                    }
                }
                "stackTotalGroup axisLine axisTitle axisGroup gridGroup labelGroup cross scrollbar".split(" ").forEach(function (index) {
                    if (axis[index]) {
                        axis[index] = axis[index].destroy();
                    }
                });
                for (plotGroup in axis.plotLinesAndBandsGroups) {
                    axis.plotLinesAndBandsGroups[plotGroup] = axis.plotLinesAndBandsGroups[plotGroup].destroy();
                }
                objectEach(axis, function (a, id) {
                    if (-1 === axis.keepProps.indexOf(id)) {
                        delete axis[id];
                    }
                });
            },
            drawCrosshair: function (e, point) {
                var options = this.crosshair;
                var categorized = pick(options.snap, true);
                var interval;
                var graphic = this.cross;
                each(this, "drawCrosshair", {
                    e: e,
                    point: point
                });
                if (!e) {
                    e = this.cross && this.cross.e;
                }
                if (this.crosshair && false !== (defined(point) || !categorized)) {
                    if (categorized) {
                        if (defined(point)) {
                            interval = pick("colorAxis" !== this.coll ? point.crosshairPos : null, this.isXAxis ? point.plotX : this.len - point.plotY);
                        }
                    } else {
                        interval = e && (this.horiz ? e.chartX - this.pos : this.len - e.chartY + this.pos);
                    }
                    if (defined(interval)) {
                        var a = {
                            value: point && (this.isXAxis ? point.x : pick(point.stackY, point.y)),
                            translatedValue: interval
                        };
                        if (this.chart.polar) {
                            extend(a, {
                                isCrosshair: true,
                                chartX: e && e.chartX,
                                chartY: e && e.chartY,
                                point: point
                            });
                        }
                        a = this.getPlotLinePath(a) || null;
                    }
                    if (!defined(a)) {
                        this.hideCrosshair();
                        return;
                    }
                    categorized = this.categories && !this.isRadial;
                    if (!graphic) {
                        this.cross = graphic = this.chart.renderer.path().addClass("highcharts-crosshair highcharts-crosshair-" + (categorized ? "category " : "thin ") + options.className).attr({
                            zIndex: pick(options.zIndex, 2)
                        }).add();
                        if (!this.chart.styledMode) {
                            graphic.attr({
                                stroke: options.color || (categorized ? color("#ccd6eb").setOpacity(.25).get() : "#cccccc"),
                                "stroke-width": pick(options.width, 1)
                            }).css({
                                "pointer-events": "none"
                            });
                            if (options.dashStyle) {
                                graphic.attr({
                                    dashstyle: options.dashStyle
                                });
                            }
                        }
                    }
                    graphic.show().attr({
                        d: a
                    });
                    if (categorized && !options.width) {
                        graphic.attr({
                            "stroke-width": this.transA
                        });
                    }
                    /** @type {!Object} */
                    this.cross.e = e;
                } else {
                    this.hideCrosshair();
                }
                each(this, "afterDrawCrosshair", {
                    e: e,
                    point: point
                });
            },
            hideCrosshair: function () {
                if (this.cross) {
                    this.cross.hide();
                }
                each(this, "afterHideCrosshair");
            }
        });
        return Highcharts.Axis = H;
    });
    set(x1, "parts/DateTimeAxis.js", [x1["parts/Globals.js"]], function (H) {
        var Axis = H.Axis;
        var getMagnitude = H.getMagnitude;
        var normalizeTickInterval = H.normalizeTickInterval;
        var timeUnits = H.timeUnits;
        /**
         * @return {?}
         */
        Axis.prototype.getTimeTicks = function () {
            return this.chart.time.getTimeTicks.apply(this.chart.time, arguments);
        };
        /**
         * @param {number} tickInterval
         * @param {!Object} unit
         * @return {?}
         */
        Axis.prototype.normalizeTimeTickInterval = function (tickInterval, unit) {
            var queue = unit || [["millisecond", [1, 2, 5, 10, 20, 25, 50, 100, 200, 500]], ["second", [1, 2, 5, 10, 15, 30]], ["minute", [1, 2, 5, 10, 15, 30]], ["hour", [1, 2, 3, 4, 6, 8, 12]], ["day", [1, 2]], ["week", [1, 2]], ["month", [1, 2, 3, 4, 6]], ["year", null]];
            unit = queue[queue.length - 1];
            var interval = timeUnits[unit[0]];
            var multiples = unit[1];
            var i;
            /** @type {number} */
            i = 0;
            for (; i < queue.length && !(unit = queue[i], interval = timeUnits[unit[0]], multiples = unit[1], queue[i + 1] && tickInterval <= (interval * multiples[multiples.length - 1] + timeUnits[queue[i + 1][0]]) / 2); i++) {
            }
            if (interval === timeUnits.year && tickInterval < 5 * interval) {
                /** @type {!Array} */
                multiples = [1, 2, 5];
            }
            tickInterval = normalizeTickInterval(tickInterval / interval, multiples, "year" === unit[0] ? Math.max(getMagnitude(tickInterval / interval), 1) : 1);
            return {
                unitRange: interval,
                count: tickInterval,
                unitName: unit[0]
            };
        };
    });
    set(x1, "parts/LogarithmicAxis.js", [x1["parts/Globals.js"], x1["parts/Utilities.js"]], function (H, Axis) {
        var pick = Axis.pick;
        Axis = H.Axis;
        var getMagnitude = H.getMagnitude;
        var normalizeTickInterval = H.normalizeTickInterval;
        /**
         * @param {number} interval
         * @param {number} min
         * @param {number} max
         * @param {number} minor
         * @return {?}
         */
        Axis.prototype.getLogTickPositions = function (interval, min, max, minor) {
            var options = this.options;
            var i = this.len;
            /** @type {!Array} */
            var positions = [];
            if (!minor) {
                /** @type {null} */
                this._minorAutoInterval = null;
            }
            if (.5 <= interval) {
                /** @type {number} */
                interval = Math.round(interval);
                positions = this.getLinearTickPositions(interval, min, max);
            } else {
                if (.08 <= interval) {
                    /** @type {number} */
                    i = Math.floor(min);
                    var j;
                    var break2;
                    /** @type {!Array} */
                    options = .3 < interval ? [1, 2, 4] : .15 < interval ? [1, 2, 4, 6, 8] : [1, 2, 3, 4, 5, 6, 7, 8, 9];
                    for (; i < max + 1 && !break2; i++) {
                        /** @type {number} */
                        var len = options.length;
                        /** @type {number} */
                        j = 0;
                        for (; j < len && !break2; j++) {
                            var theta = this.log2lin(this.lin2log(i) * options[j]);
                            if (theta > min && (!minor || x <= max) && "undefined" !== typeof x) {
                                positions.push(x);
                            }
                            if (x > max) {
                                /** @type {boolean} */
                                break2 = true;
                            }
                            var x = theta;
                        }
                    }
                } else {
                    min = this.lin2log(min);
                    max = this.lin2log(max);
                    interval = minor ? this.getMinorTickInterval() : options.tickInterval;
                    interval = pick("auto" === interval ? null : interval, this._minorAutoInterval, options.tickPixelInterval / (minor ? 5 : 1) * (max - min) / ((minor ? i / this.tickPositions.length : i) || 1));
                    interval = normalizeTickInterval(interval, null, getMagnitude(interval));
                    positions = this.getLinearTickPositions(interval, min, max).map(this.log2lin);
                    if (!minor) {
                        /** @type {number} */
                        this._minorAutoInterval = interval / 5;
                    }
                }
            }
            if (!minor) {
                /** @type {number} */
                this.tickInterval = interval;
            }
            return positions;
        };
        /**
         * @param {?} value
         * @return {?}
         */
        Axis.prototype.log2lin = function (value) {
            return Math.log(value) / Math.LN10;
        };
        /**
         * @param {?} key
         * @return {?}
         */
        Axis.prototype.lin2log = function (key) {
            return Math.pow(10, key);
        };
    });
    set(x1, "parts/PlotLineOrBand.js", [x1["parts/Globals.js"], x1["parts/Axis.js"], x1["parts/Utilities.js"]], function (Highcharts, EventGroup, H) {
        var arrayMax = H.arrayMax;
        var arrayMin = H.arrayMin;
        var defined = H.defined;
        var destroyObjectProperties = H.destroyObjectProperties;
        var erase = H.erase;
        var extend = H.extend;
        var objectEach = H.objectEach;
        var pick = H.pick;
        var merge = Highcharts.merge;
        /**
         * @param {string} axis
         * @param {!Object} options
         * @return {undefined}
         */
        Highcharts.PlotLineOrBand = function (axis, options) {
            /** @type {string} */
            this.axis = axis;
            if (options) {
                /** @type {!Object} */
                this.options = options;
                this.id = options.id;
            }
        };
        Highcharts.PlotLineOrBand.prototype = {
            render: function () {
                Highcharts.fireEvent(this, "render");
                var plotLine = this;
                var axis = plotLine.axis;
                var horiz = axis.horiz;
                var options = plotLine.options;
                var p = options.label;
                var label = plotLine.label;
                var to = options.to;
                var from = options.from;
                var value = options.value;
                var isBand = defined(from) && defined(to);
                var hasValue = defined(value);
                var svgElem = plotLine.svgElem;
                /** @type {boolean} */
                var isNew = !svgElem;
                /** @type {!Array} */
                var a = [];
                var group = options.color;
                var zIndex = pick(options.zIndex, 0);
                var events = options.events;
                a = {
                    "class": "highcharts-plot-" + (isBand ? "band " : "line ") + (options.className || "")
                };
                var style = {};
                var renderer = axis.chart.renderer;
                /** @type {string} */
                var groupName = isBand ? "bands" : "lines";
                if (axis.isLog) {
                    from = axis.log2lin(from);
                    to = axis.log2lin(to);
                    value = axis.log2lin(value);
                }
                if (!axis.chart.styledMode) {
                    if (hasValue) {
                        a.stroke = group || "#999999";
                        a["stroke-width"] = pick(options.width, 1);
                        if (options.dashStyle) {
                            a.dashstyle = options.dashStyle;
                        }
                    } else {
                        if (isBand) {
                            a.fill = group || "#e6ebf5";
                            if (options.borderWidth) {
                                a.stroke = options.borderColor;
                                a["stroke-width"] = options.borderWidth;
                            }
                        }
                    }
                }
                style.zIndex = zIndex;
                /** @type {string} */
                groupName = groupName + ("-" + zIndex);
                if (!(group = axis.plotLinesAndBandsGroups[groupName])) {
                    axis.plotLinesAndBandsGroups[groupName] = group = renderer.g("plot-" + groupName).attr(style).add();
                }
                if (isNew) {
                    plotLine.svgElem = svgElem = renderer.path().attr(a).add(group);
                }
                if (hasValue) {
                    a = axis.getPlotLinePath({
                        value: value,
                        lineWidth: svgElem.strokeWidth(),
                        acrossPanes: options.acrossPanes
                    });
                } else {
                    if (isBand) {
                        a = axis.getPlotBandPath(from, to, options);
                    } else {
                        return;
                    }
                }
                if ((isNew || !svgElem.d) && a && a.length) {
                    svgElem.attr({
                        d: a
                    });
                    if (events) {
                        objectEach(events, function (a, eventType) {
                            svgElem.on(eventType, function (_invoker) {
                                events[eventType].apply(plotLine, [_invoker]);
                            });
                        });
                    }
                } else {
                    if (svgElem) {
                        if (a) {
                            svgElem.show(true);
                            svgElem.animate({
                                d: a
                            });
                        } else {
                            if (svgElem.d) {
                                svgElem.hide();
                                if (label) {
                                    plotLine.label = label = label.destroy();
                                }
                            }
                        }
                    }
                }
                if (p && (defined(p.text) || defined(p.formatter)) && a && a.length && 0 < axis.width && 0 < axis.height && !a.isFlat) {
                    p = merge({
                        align: horiz && isBand && "center",
                        x: horiz ? !isBand && 4 : 10,
                        verticalAlign: !horiz && isBand && "middle",
                        y: horiz ? isBand ? 16 : 10 : isBand ? 6 : -4,
                        rotation: horiz && !isBand && 90
                    }, p);
                    this.renderLabel(p, a, isBand, zIndex);
                } else {
                    if (label) {
                        label.hide();
                    }
                }
                return plotLine;
            },
            renderLabel: function (options, xs, x, index) {
                var label = this.label;
                var arr = this.axis.chart.renderer;
                if (!label) {
                    label = {
                        align: options.textAlign || options.align,
                        rotation: options.rotation,
                        "class": "highcharts-plot-" + (x ? "band" : "line") + "-label " + (options.className || "")
                    };
                    /** @type {number} */
                    label.zIndex = index;
                    index = this.getLabelText(options);
                    this.label = label = arr.text(index, 0, 0, options.useHTML).attr(label).add();
                    if (!this.axis.chart.styledMode) {
                        label.css(options.style);
                    }
                }
                arr = xs.xBounds || [xs[1], xs[4], x ? xs[6] : xs[1]];
                xs = xs.yBounds || [xs[2], xs[5], x ? xs[7] : xs[2]];
                x = arrayMin(arr);
                index = arrayMin(xs);
                label.align(options, false, {
                    x: x,
                    y: index,
                    width: arrayMax(arr) - x,
                    height: arrayMax(xs) - index
                });
                label.show(true);
            },
            getLabelText: function (value) {
                return defined(value.formatter) ? value.formatter.call(this) : value.text;
            },
            destroy: function () {
                erase(this.axis.plotLinesAndBands, this);
                delete this.axis;
                destroyObjectProperties(this);
            }
        };
        extend(EventGroup.prototype, {
            getPlotBandPath: function (from, to) {
                var innerStartPoint = this.getPlotLinePath({
                    value: to,
                    force: true,
                    acrossPanes: this.options.acrossPanes
                });
                var toPath = this.getPlotLinePath({
                    value: from,
                    force: true,
                    acrossPanes: this.options.acrossPanes
                });
                /** @type {!Array} */
                var path = [];
                var horiz = this.horiz;
                /** @type {number} */
                var a = 1;
                /** @type {boolean} */
                from = from < this.min && to < this.min || from > this.max && to > this.max;
                if (toPath && innerStartPoint) {
                    if (from) {
                        /** @type {boolean} */
                        var medium_editor_list = toPath.toString() === innerStartPoint.toString();
                        /** @type {number} */
                        a = 0;
                    }
                    /** @type {number} */
                    from = 0;
                    for (; from < toPath.length; from = from + 6) {
                        if (horiz && innerStartPoint[from + 1] === toPath[from + 1]) {
                            innerStartPoint[from + 1] += a;
                            innerStartPoint[from + 4] += a;
                        } else {
                            if (!(horiz || innerStartPoint[from + 2] !== toPath[from + 2])) {
                                innerStartPoint[from + 2] += a;
                                innerStartPoint[from + 5] += a;
                            }
                        }
                        path.push("M", toPath[from + 1], toPath[from + 2], "L", toPath[from + 4], toPath[from + 5], innerStartPoint[from + 4], innerStartPoint[from + 5], innerStartPoint[from + 1], innerStartPoint[from + 2], "z");
                        /** @type {(boolean|undefined)} */
                        path.isFlat = medium_editor_list;
                    }
                }
                return path;
            },
            addPlotBand: function (options) {
                return this.addPlotBandOrLine(options, "plotBands");
            },
            addPlotLine: function (options) {
                return this.addPlotBandOrLine(options, "plotLines");
            },
            addPlotBandOrLine: function (options, coll) {
                var obj = (new Highcharts.PlotLineOrBand(this, options)).render();
                var userOptions = this.userOptions;
                if (obj) {
                    if (coll) {
                        var value = userOptions[coll] || [];
                        value.push(options);
                        userOptions[coll] = value;
                    }
                    this.plotLinesAndBands.push(obj);
                }
                return obj;
            },
            removePlotBandOrLine: function (id) {
                var plotLinesAndBands = this.plotLinesAndBands;
                var options = this.options;
                var userOptions = this.userOptions;
                var i = plotLinesAndBands.length;
                for (; i--;) {
                    if (plotLinesAndBands[i].id === id) {
                        plotLinesAndBands[i].destroy();
                    }
                }
                [options.plotLines || [], userOptions.plotLines || [], options.plotBands || [], userOptions.plotBands || []].forEach(function (arr) {
                    i = arr.length;
                    for (; i--;) {
                        if (arr[i].id === id) {
                            erase(arr, arr[i]);
                        }
                    }
                });
            },
            removePlotBand: function (id) {
                this.removePlotBandOrLine(id);
            },
            removePlotLine: function (id) {
                this.removePlotBandOrLine(id);
            }
        });
    });
    set(x1, "parts/Tooltip.js", [x1["parts/Globals.js"], x1["parts/Utilities.js"]], function (self, H) {
        var clamp = H.clamp;
        var defined = H.defined;
        var discardElement = H.discardElement;
        var extend = H.extend;
        var isNumber = H.isNumber;
        var isString = H.isString;
        var pick = H.pick;
        var splat = H.splat;
        var syncTimeout = H.syncTimeout;
        "";
        var doc = self.doc;
        var format = self.format;
        var merge = self.merge;
        var timeUnits = self.timeUnits;
        /**
         * @return {undefined}
         */
        self.Tooltip = function () {
            this.init.apply(this, arguments);
        };
        self.Tooltip.prototype = {
            init: function (chart, options) {
                /** @type {!Object} */
                this.chart = chart;
                /** @type {!Object} */
                this.options = options;
                /** @type {!Array} */
                this.crosshairs = [];
                this.now = {
                    x: 0,
                    y: 0
                };
                /** @type {boolean} */
                this.isHidden = true;
                this.split = options.split && !chart.inverted && !chart.polar;
                this.shared = options.shared || this.split;
                this.outside = pick(options.outside, !(!chart.scrollablePixelsX && !chart.scrollablePixelsY));
            },
            cleanSplit: function (force) {
                this.chart.series.forEach(function (series) {
                    var tt = series && series.tt;
                    if (tt) {
                        if (!tt.isActive || force) {
                            series.tt = tt.destroy();
                        } else {
                            /** @type {boolean} */
                            tt.isActive = false;
                        }
                    }
                });
            },
            applyFilter: function () {
                var chart = this.chart;
                chart.renderer.definition({
                    tagName: "filter",
                    id: "drop-shadow-" + chart.index,
                    opacity: .5,
                    children: [{
                        tagName: "feGaussianBlur",
                        "in": "SourceAlpha",
                        stdDeviation: 1
                    }, {
                        tagName: "feOffset",
                        dx: 1,
                        dy: 1
                    }, {
                        tagName: "feComponentTransfer",
                        children: [{
                            tagName: "feFuncA",
                            type: "linear",
                            slope: .3
                        }]
                    }, {
                        tagName: "feMerge",
                        children: [{
                            tagName: "feMergeNode"
                        }, {
                            tagName: "feMergeNode",
                            "in": "SourceGraphic"
                        }]
                    }]
                });
                chart.renderer.definition({
                    tagName: "style",
                    textContent: ".highcharts-tooltip-" + chart.index + "{filter:url(#drop-shadow-" + chart.index + ")}"
                });
            },
            getLabel: function () {
                var params = this;
                var renderer = this.chart.renderer;
                var slots = this.chart.styledMode;
                var options = this.options;
                /** @type {string} */
                var label = "tooltip" + (defined(options.className) ? " " + options.className : "");
                var canvas;
                if (!this.label) {
                    if (this.outside) {
                        this.container = canvas = self.doc.createElement("div");
                        /** @type {string} */
                        canvas.className = "highcharts-tooltip-container";
                        self.css(canvas, {
                            position: "absolute",
                            top: "1px",
                            pointerEvents: options.style && options.style.pointerEvents,
                            zIndex: 3
                        });
                        self.doc.body.appendChild(canvas);
                        this.renderer = renderer = new self.Renderer(canvas, 0, 0, {}, void 0, void 0, renderer.styledMode);
                    }
                    if (this.split) {
                        this.label = renderer.g(label);
                    } else {
                        this.label = renderer.label("", 0, 0, options.shape || "callout", null, null, options.useHTML, null, label).attr({
                            padding: options.padding,
                            r: options.borderRadius
                        });
                        if (!slots) {
                            this.label.attr({
                                fill: options.backgroundColor,
                                "stroke-width": options.borderWidth
                            }).css(options.style).shadow(options.shadow);
                        }
                    }
                    if (slots) {
                        this.applyFilter();
                        this.label.addClass("highcharts-tooltip-" + this.chart.index);
                    }
                    if (params.outside && !params.split) {
                        var k = {
                            x: this.label.xSetter,
                            y: this.label.ySetter
                        };
                        /**
                         * @param {string} key
                         * @param {?} value
                         * @return {undefined}
                         */
                        this.label.xSetter = function (key, value) {
                            k[value].call(this.label, params.distance);
                            /** @type {string} */
                            canvas.style.left = key + "px";
                        };
                        /**
                         * @param {string} key
                         * @param {?} value
                         * @return {undefined}
                         */
                        this.label.ySetter = function (key, value) {
                            k[value].call(this.label, params.distance);
                            /** @type {string} */
                            canvas.style.top = key + "px";
                        };
                    }
                    this.label.attr({
                        zIndex: 8
                    }).add();
                }
                return this.label;
            },
            update: function (options) {
                this.destroy();
                merge(true, this.chart.options.tooltip.userOptions, options);
                this.init(this.chart, merge(true, this.options, options));
            },
            destroy: function () {
                if (this.label) {
                    this.label = this.label.destroy();
                }
                if (this.split && this.tt) {
                    this.cleanSplit(this.chart, true);
                    this.tt = this.tt.destroy();
                }
                if (this.renderer) {
                    this.renderer = this.renderer.destroy();
                    discardElement(this.container);
                }
                self.clearTimeout(this.hideTimer);
                self.clearTimeout(this.tooltipTimeout);
            },
            move: function (x, y, anchorX, anchorY) {
                var tooltip = this;
                var now = tooltip.now;
                /** @type {boolean} */
                var animate = false !== tooltip.options.animation && !tooltip.isHidden && (1 < Math.abs(x - now.x) || 1 < Math.abs(y - now.y));
                var skipAnchor = tooltip.followPointer || 1 < tooltip.len;
                extend(now, {
                    x: animate ? (2 * now.x + x) / 3 : x,
                    y: animate ? (now.y + y) / 2 : y,
                    anchorX: skipAnchor ? void 0 : animate ? (2 * now.anchorX + anchorX) / 3 : anchorX,
                    anchorY: skipAnchor ? void 0 : animate ? (now.anchorY + anchorY) / 2 : anchorY
                });
                tooltip.getLabel().attr(now);
                if (animate) {
                    self.clearTimeout(this.tooltipTimeout);
                    /** @type {number} */
                    this.tooltipTimeout = setTimeout(function () {
                        if (tooltip) {
                            tooltip.move(x, y, anchorX, anchorY);
                        }
                    }, 32);
                }
            },
            hide: function (delay) {
                var property = this;
                self.clearTimeout(this.hideTimer);
                delay = pick(delay, this.options.hideDelay, 500);
                if (!this.isHidden) {
                    this.hideTimer = syncTimeout(function () {
                        property.getLabel()[delay ? "fadeOut" : "hide"]();
                        /** @type {boolean} */
                        property.isHidden = true;
                    }, delay);
                }
            },
            getAnchor: function (points, mouseEvent) {
                var chart = this.chart;
                var pointer = chart.pointer;
                var inverted = chart.inverted;
                var plotTop = chart.plotTop;
                var plotLeft = chart.plotLeft;
                /** @type {number} */
                var plotX = 0;
                /** @type {number} */
                var plotY = 0;
                var yAxis;
                var xAxis;
                points = splat(points);
                if (this.followPointer && mouseEvent) {
                    if ("undefined" === typeof mouseEvent.chartX) {
                        mouseEvent = pointer.normalize(mouseEvent);
                    }
                    /** @type {!Array} */
                    points = [mouseEvent.chartX - chart.plotLeft, mouseEvent.chartY - plotTop];
                } else {
                    if (points[0].tooltipPos) {
                        points = points[0].tooltipPos;
                    } else {
                        points.forEach(function (point) {
                            yAxis = point.series.yAxis;
                            xAxis = point.series.xAxis;
                            plotX = plotX + (point.plotX + (!inverted && xAxis ? xAxis.left - plotLeft : 0));
                            plotY = plotY + ((point.plotLow ? (point.plotLow + point.plotHigh) / 2 : point.plotY) + (!inverted && yAxis ? yAxis.top - plotTop : 0));
                        });
                        /** @type {number} */
                        plotX = plotX / points.length;
                        /** @type {number} */
                        plotY = plotY / points.length;
                        /** @type {!Array} */
                        points = [inverted ? chart.plotWidth - plotY : plotX, this.shared && !inverted && 1 < points.length && mouseEvent ? mouseEvent.chartY - plotTop : inverted ? chart.plotHeight - plotX : plotY];
                    }
                }
                return points.map(Math.round);
            },
            getPosition: function (i, e, point) {
                var chart = this.chart;
                var t = this.distance;
                var out = {};
                var L = chart.inverted && point.h || 0;
                var autoReview;
                var inverted = this.outside;
                var base1 = inverted ? doc.documentElement.clientWidth - 2 * t : chart.chartWidth;
                var h = inverted ? Math.max(doc.body.scrollHeight, doc.documentElement.scrollHeight, doc.body.offsetHeight, doc.documentElement.offsetHeight, doc.documentElement.clientHeight) : chart.chartHeight;
                var sp = chart.pointer.getChartPosition();
                var z = chart.containerScaling;
                /**
                 * @param {number} x
                 * @return {?}
                 */
                var parseFloat = function (x) {
                    return z ? x * z.scaleX : x;
                };
                /**
                 * @param {number} y
                 * @return {?}
                 */
                var f = function (y) {
                    return z ? y * z.scaleY : y;
                };
                /**
                 * @param {string} id
                 * @return {?}
                 */
                var position = function (id) {
                    /** @type {boolean} */
                    var isStacked = "x" === id;
                    return [id, isStacked ? base1 : h, isStacked ? i : e].concat(inverted ? [isStacked ? parseFloat(i) : f(e), isStacked ? sp.left - t + parseFloat(point.plotX + chart.plotLeft) : sp.top - t + f(point.plotY + chart.plotTop), 0, isStacked ? base1 : h] : [isStacked ? i : e, isStacked ? point.plotX + chart.plotLeft : point.plotY + chart.plotTop, isStacked ? chart.plotLeft : chart.plotTop, isStacked ? chart.plotLeft + chart.plotWidth : chart.plotTop + chart.plotHeight]);
                };
                var offset = position("y");
                var p = position("x");
                var r = !this.followPointer && pick(point.ttBelow, !chart.inverted === !!point.negative);
                /**
                 * @param {string} id
                 * @param {?} count
                 * @param {number} a
                 * @param {number} i
                 * @param {number} c
                 * @param {undefined} v
                 * @param {string} n
                 * @return {?}
                 */
                var format = function (id, count, a, i, c, v, n) {
                    var showSize = "y" === id ? f(t) : parseFloat(t);
                    /** @type {number} */
                    var hideSize = (a - i) / 2;
                    /** @type {boolean} */
                    var haveByte2 = i < c - t;
                    /** @type {boolean} */
                    var hasVal = c + t + i < count;
                    /** @type {number} */
                    var query = c - showSize - a + hideSize;
                    /** @type {number} */
                    c = c + showSize - hideSize;
                    if (r && hasVal) {
                        /** @type {number} */
                        out[id] = c;
                    } else {
                        if (!r && haveByte2) {
                            /** @type {number} */
                            out[id] = query;
                        } else {
                            if (haveByte2) {
                                /** @type {number} */
                                out[id] = Math.min(n - i, 0 > query - L ? query : query - L);
                            } else {
                                if (hasVal) {
                                    /** @type {number} */
                                    out[id] = Math.max(v, c + L + a > count ? c : c + L);
                                } else {
                                    return false;
                                }
                            }
                        }
                    }
                };
                /**
                 * @param {?} str
                 * @param {number} i
                 * @param {number} w
                 * @param {number} p
                 * @param {number} x
                 * @return {?}
                 */
                var val = function (str, i, w, p, x) {
                    var value;
                    if (x < t || x > i - t) {
                        /** @type {boolean} */
                        value = false;
                    } else {
                        /** @type {number} */
                        out[str] = x < w / 2 ? 1 : x > i - p / 2 ? i - p - 2 : x - w / 2;
                    }
                    return value;
                };
                /**
                 * @param {string} data
                 * @return {undefined}
                 */
                var getValue = function (data) {
                    var start = offset;
                    offset = p;
                    p = start;
                    /** @type {string} */
                    autoReview = data;
                };
                /**
                 * @return {undefined}
                 */
                var run = function () {
                    if (false !== format.apply(0, offset)) {
                        if (!(false !== val.apply(0, p) || autoReview)) {
                            getValue(true);
                            run();
                        }
                    } else {
                        if (autoReview) {
                            /** @type {number} */
                            out.x = out.y = 0;
                        } else {
                            getValue(true);
                            run();
                        }
                    }
                };
                if (chart.inverted || 1 < this.len) {
                    getValue();
                }
                run();
                return out;
            },
            defaultFormatter: function (name) {
                var items = this.points || splat(this);
                /** @type {!Array} */
                var s = [name.tooltipFooterHeaderFormatter(items[0])];
                /** @type {!Array<?>} */
                s = s.concat(name.bodyFormatter(items));
                s.push(name.tooltipFooterHeaderFormatter(items[0], true));
                return s;
            },
            refresh: function (item, x) {
                var text = this.chart;
                var options = this.options;
                /** @type {!Object} */
                var point = item;
                var data = {};
                /** @type {!Array} */
                var questions = [];
                var currentSeries = options.formatter || this.defaultFormatter;
                data = this.shared;
                var textSR = text.styledMode;
                if (options.enabled) {
                    self.clearTimeout(this.hideTimer);
                    this.followPointer = splat(point)[0].series.tooltipOptions.followPointer;
                    var a = this.getAnchor(point, x);
                    x = a[0];
                    var y = a[1];
                    if (!data || point.series && point.series.noSharedTooltip) {
                        data = point.getLabelConfig();
                    } else {
                        text.pointer.applyInactiveState(point);
                        point.forEach(function (item) {
                            item.setState("hover");
                            questions.push(item.getLabelConfig());
                        });
                        data = {
                            x: point[0].category,
                            y: point[0].y
                        };
                        /** @type {!Array} */
                        data.points = questions;
                        point = point[0];
                    }
                    /** @type {number} */
                    this.len = questions.length;
                    text = currentSeries.call(data, this);
                    currentSeries = point.series;
                    this.distance = pick(currentSeries.tooltipOptions.distance, 16);
                    if (false === text) {
                        this.hide();
                    } else {
                        if (this.split) {
                            this.renderSplit(text, splat(item));
                        } else {
                            item = this.getLabel();
                            if (!(options.style.width && !textSR)) {
                                item.css({
                                    width: this.chart.spacingBox.width
                                });
                            }
                            item.attr({
                                text: text && text.join ? text.join("") : text
                            });
                            item.removeClass(/highcharts-color-[\d]+/g).addClass("highcharts-color-" + pick(point.colorIndex, currentSeries.colorIndex));
                            if (!textSR) {
                                item.attr({
                                    stroke: options.borderColor || point.color || currentSeries.color || "#666666"
                                });
                            }
                            this.updatePosition({
                                plotX: x,
                                plotY: y,
                                negative: point.negative,
                                ttBelow: point.ttBelow,
                                h: a[2] || 0
                            });
                        }
                        if (this.isHidden && this.label) {
                            this.label.attr({
                                opacity: 1
                            }).show();
                        }
                        /** @type {boolean} */
                        this.isHidden = false;
                    }
                    self.fireEvent(this, "refresh");
                }
            },
            renderSplit: function (value, points) {
                /**
                 * @param {string} b
                 * @param {number} s
                 * @param {boolean} index
                 * @param {number} x
                 * @param {number} c
                 * @return {?}
                 */
                function add(b, s, index, x, c) {
                    if (void 0 === c) {
                        /** @type {boolean} */
                        c = true;
                    }
                    if (index) {
                        s = param ? 0 : out;
                        b = clamp(b - x / 2, rect.left, rect.right - x);
                    } else {
                        /** @type {number} */
                        s = s - t;
                        b = c ? b - x - d : b + d;
                        b = clamp(b, c ? b : rect.left, rect.right);
                    }
                    return {
                        x: b,
                        y: s
                    };
                }
                var e = this;
                var o = e.chart;
                var chart = e.chart;
                var chartWidth = chart.chartWidth;
                var height = chart.chartHeight;
                var oldPlotHeight = chart.plotHeight;
                var left = chart.plotLeft;
                var top = chart.plotTop;
                var width = chart.plotWidth;
                var ctx = chart.pointer;
                var renderer = chart.renderer;
                var l = chart.scrollablePixelsX;
                l = void 0 === l ? 0 : l;
                var result = chart.scrollablePixelsY;
                var vertical = void 0 === result ? 0 : result;
                result = chart.scrollingContainer;
                result = void 0 === result ? {
                    scrollLeft: 0,
                    scrollTop: 0
                } : result;
                var x0 = result.scrollLeft;
                var x2 = result.scrollTop;
                var chartLen = chart.styledMode;
                var d = e.distance;
                var options = e.options;
                var f = e.options.positioner;
                var rect = {
                    left: l ? left : 0,
                    right: l ? left + width - l : chartWidth,
                    top: vertical ? top : 0,
                    bottom: vertical ? top + oldPlotHeight - vertical : height
                };
                var clone = e.getLabel();
                /** @type {boolean} */
                var param = !(!o.xAxis[0] || !o.xAxis[0].opposite);
                var t = top;
                /** @type {number} */
                var c = 0;
                /** @type {number} */
                var out = oldPlotHeight - vertical;
                if (isString(value)) {
                    /** @type {!Array} */
                    value = [false, value];
                }
                value = value.slice(0, points.length + 1).reduce(function (context, value, point) {
                    if (false !== value && "" !== value) {
                        point = points[point - 1] || {
                            isHeader: true,
                            plotX: points[0].plotX,
                            plotY: oldPlotHeight,
                            series: {}
                        };
                        /** @type {boolean} */
                        var inverted = point.isHeader;
                        var path = inverted ? e : point.series;
                        var node = path.tt;
                        /** @type {boolean} */
                        var b = point.isHeader;
                        var x = point.series;
                        var y = "highcharts-color-" + pick(point.colorIndex, x.colorIndex, "none");
                        if (!node) {
                            node = {
                                padding: options.padding,
                                r: options.borderRadius
                            };
                            if (!chartLen) {
                                node.fill = options.backgroundColor;
                                node["stroke-width"] = options.borderWidth;
                            }
                            node = renderer.label(null, null, null, options[b ? "headerShape" : "shape"] || "callout", null, null, options.useHTML).addClass(b ? "highcharts-tooltip-header " : "highcharts-tooltip-box " + y).attr(node).add(clone);
                        }
                        /** @type {boolean} */
                        node.isActive = true;
                        node.attr({
                            text: value
                        });
                        if (!chartLen) {
                            node.css(options.style).shadow(options.shadow).attr({
                                stroke: options.borderColor || point.color || x.color || "#333333"
                            });
                        }
                        value = path.tt = node;
                        b = value.getBBox();
                        path = b.width + value.strokeWidth();
                        if (inverted) {
                            c = b.height;
                            out = out + c;
                            if (param) {
                                /** @type {number} */
                                t = t - c;
                            }
                        }
                        x = point.plotX;
                        x = void 0 === x ? 0 : x;
                        y = point.plotY;
                        y = void 0 === y ? 0 : y;
                        var s = point.series;
                        if (point.isHeader) {
                            /** @type {number} */
                            x = left + x - x0;
                            y = top + (oldPlotHeight - vertical) / 2;
                        } else {
                            node = s.xAxis;
                            s = s.yAxis;
                            /** @type {number} */
                            x = node.pos + clamp(x, -d, node.len + d) - x0;
                            /** @type {number} */
                            y = s.pos + clamp(y, 0, s.len) - x2;
                        }
                        x = clamp(x, rect.left - d, rect.right + d);
                        y = clamp(y, rect.top, rect.bottom);
                        b = b.height + 1;
                        node = f ? f.call(e, path, b, point) : add(x, y, inverted, path);
                        context.push({
                            align: f ? 0 : void 0,
                            anchorX: x,
                            anchorY: y,
                            boxWidth: path,
                            point: point,
                            rank: pick(node.rank, inverted ? 1 : 0),
                            size: b,
                            target: node.y,
                            tt: value,
                            x: node.x
                        });
                    }
                    return context;
                }, []);
                if (!f && value.some(function (objectToMeasure) {
                    return 0 > objectToMeasure.x;
                })) {
                    value = value.map(function (data) {
                        var obj = add(data.anchorX, data.anchorY, data.point.isHeader, data.boxWidth, false);
                        return extend(data, {
                            target: obj.y,
                            x: obj.x
                        });
                    });
                }
                e.cleanSplit();
                self.distribute(value, out, void 0);
                value.forEach(function (node) {
                    var c = node.pos;
                    node.tt.attr({
                        visibility: "undefined" === typeof c ? "hidden" : "inherit",
                        x: node.x,
                        y: c + t,
                        anchorX: node.anchorX,
                        anchorY: node.anchorY
                    });
                });
                value = e.container;
                o = e.renderer;
                if (e.outside && value && o) {
                    chart = clone.getBBox();
                    o.setSize(chart.width + chart.x, chart.height + chart.y, false);
                    ctx = ctx.getChartPosition();
                    /** @type {string} */
                    value.style.left = ctx.left + "px";
                    /** @type {string} */
                    value.style.top = ctx.top + "px";
                }
            },
            updatePosition: function (point) {
                var chart = this.chart;
                var p = chart.pointer;
                var data = this.getLabel();
                var x = point.plotX + chart.plotLeft;
                var y = point.plotY + chart.plotTop;
                p = p.getChartPosition();
                point = (this.options.positioner || this.getPosition).call(this, data.width, data.height, point);
                if (this.outside) {
                    var delta = (this.options.borderWidth || 0) + 2 * this.distance;
                    this.renderer.setSize(data.width + delta, data.height + delta, false);
                    if (chart = chart.containerScaling) {
                        self.css(this.container, {
                            transform: "scale(" + chart.scaleX + ", " + chart.scaleY + ")"
                        });
                        /** @type {number} */
                        x = x * chart.scaleX;
                        /** @type {number} */
                        y = y * chart.scaleY;
                    }
                    x = x + (p.left - point.x);
                    y = y + (p.top - point.y);
                }
                this.move(Math.round(point.x), Math.round(point.y || 0), x, y);
            },
            getDateFormat: function (range, format, type, result) {
                var date = this.chart.time;
                var content = date.dateFormat("%m-%d %H:%M:%S.%L", format);
                var CONVERSIONS = {
                    millisecond: 15,
                    second: 12,
                    minute: 9,
                    hour: 6,
                    day: 3
                };
                /** @type {string} */
                var lastTokenWithSpace = "millisecond";
                for (i in timeUnits) {
                    if (range === timeUnits.week && +date.dateFormat("%w", format) === type && "00:00:00.000" === content.substr(6)) {
                        /** @type {string} */
                        var i = "week";
                        break;
                    }
                    if (timeUnits[i] > range) {
                        /** @type {string} */
                        i = lastTokenWithSpace;
                        break;
                    }
                    if (CONVERSIONS[i] && content.substr(CONVERSIONS[i]) !== "01-01 00:00:00.000".substr(CONVERSIONS[i])) {
                        break;
                    }
                    if ("week" !== i) {
                        /** @type {string} */
                        lastTokenWithSpace = i;
                    }
                }
                if (i) {
                    var dateFormat = date.resolveDTLFormat(result[i]).main;
                }
                return dateFormat;
            },
            getXDateFormat: function (point, options, xAxis) {
                options = options.dateTimeLabelFormats;
                var type = xAxis && xAxis.closestPointRange;
                return (type ? this.getDateFormat(type, point.x, xAxis.options.startOfWeek, options) : options.day) || options.year;
            },
            tooltipFooterHeaderFormatter: function (labelConfig, isFooter) {
                /** @type {string} */
                var footOrHead = isFooter ? "footer" : "header";
                var series = labelConfig.series;
                var tooltipOptions = series.tooltipOptions;
                var xDateFormat = tooltipOptions.xDateFormat;
                var xAxis = series.xAxis;
                var isDateTime = xAxis && "datetime" === xAxis.options.type && isNumber(labelConfig.key);
                var name = tooltipOptions[footOrHead + "Format"];
                isFooter = {
                    isFooter: isFooter,
                    labelConfig: labelConfig
                };
                self.fireEvent(this, "headerFormatter", isFooter, function (data) {
                    if (isDateTime && !xDateFormat) {
                        xDateFormat = this.getXDateFormat(labelConfig, tooltipOptions, xAxis);
                    }
                    if (isDateTime && xDateFormat) {
                        (labelConfig.point && labelConfig.point.tooltipDateKeys || ["key"]).forEach(function (a) {
                            name = name.replace("{point." + a + "}", "{point." + a + ":" + xDateFormat + "}");
                        });
                    }
                    if (series.chart.styledMode) {
                        name = this.styledModeFormat(name);
                    }
                    data.text = format(name, {
                        point: labelConfig,
                        series: series
                    }, this.chart);
                });
                return isFooter.text;
            },
            bodyFormatter: function (items) {
                return items.map(function (item) {
                    var tooltipOptions = item.series.tooltipOptions;
                    return (tooltipOptions[(item.point.formatPrefix || "point") + "Formatter"] || item.point.tooltipFormatter).call(item.point, tooltipOptions[(item.point.formatPrefix || "point") + "Format"] || "");
                });
            },
            styledModeFormat: function (elements) {
                return elements.replace('style="font-size: 10px"', 'class="highcharts-header"').replace(/style="color:{(point|series)\.color}"/g, 'class="highcharts-color-{$1.colorIndex}"');
            }
        };
    });
    set(x1, "parts/Pointer.js", [x1["parts/Globals.js"], x1["parts/Utilities.js"]], function (H, Highcharts) {
        var attr = Highcharts.attr;
        var defined = Highcharts.defined;
        var extend = Highcharts.extend;
        var merge = Highcharts.isNumber;
        var format = Highcharts.isObject;
        var objectEach = Highcharts.objectEach;
        var off = Highcharts.offset;
        var pick = Highcharts.pick;
        var splat = Highcharts.splat;
        var addEvent = H.addEvent;
        var charts = H.charts;
        var color = H.color;
        var css = H.css;
        var $ = H.find;
        var fireEvent = H.fireEvent;
        var Tooltip = H.Tooltip;
        /**
         * @param {undefined} options
         * @param {undefined} event
         * @return {undefined}
         */
        H.Pointer = function (options, event) {
            this.init(options, event);
        };
        H.Pointer.prototype = {
            init: function (chart, options) {
                /** @type {!Object} */
                this.options = options;
                /** @type {!Object} */
                this.chart = chart;
                this.runChartClick = options.chart.events && !!options.chart.events.click;
                /** @type {!Array} */
                this.pinchDown = [];
                this.lastValidTouch = {};
                if (Tooltip) {
                    chart.tooltip = new Tooltip(chart, options.tooltip);
                    this.followTouchMove = pick(options.tooltip.followTouchMove, true);
                }
                this.setDOMEvents();
            },
            zoomOption: function (e) {
                var s = this.chart;
                var options = s.options.chart;
                var val = options.zoomType || "";
                s = s.inverted;
                if (/touch/.test(e.type)) {
                    val = pick(options.pinchType, val);
                }
                /** @type {boolean} */
                this.zoomX = e = /x/.test(val);
                /** @type {boolean} */
                this.zoomY = val = /y/.test(val);
                this.zoomHor = e && !s || val && s;
                this.zoomVert = val && !s || e && s;
                /** @type {boolean} */
                this.hasZoom = e || val;
            },
            getChartPosition: function () {
                var target = this.chart;
                target = target.scrollingContainer || target.container;
                return this.chartPosition || (this.chartPosition = off(target));
            },
            normalize: function (e, pos) {
                var c = e.touches ? e.touches.length ? e.touches.item(0) : e.changedTouches[0] : e;
                if (!pos) {
                    pos = this.getChartPosition();
                }
                /** @type {number} */
                var value = c.pageX - pos.left;
                /** @type {number} */
                pos = c.pageY - pos.top;
                if (c = this.chart.containerScaling) {
                    /** @type {number} */
                    value = value / c.scaleX;
                    /** @type {number} */
                    pos = pos / c.scaleY;
                }
                return extend(e, {
                    chartX: Math.round(value),
                    chartY: Math.round(pos)
                });
            },
            getCoordinates: function (e) {
                var coordinates = {
                    xAxis: [],
                    yAxis: []
                };
                this.chart.axes.forEach(function (axis) {
                    coordinates[axis.isXAxis ? "xAxis" : "yAxis"].push({
                        axis: axis,
                        value: axis.toValue(e[axis.horiz ? "chartX" : "chartY"])
                    });
                });
                return coordinates;
            },
            findNearestKDPoint: function (name, shared, p) {
                var p1;
                name.forEach(function (data) {
                    /** @type {boolean} */
                    var content = !(data.noSharedTooltip && shared) && 0 > data.options.findNearestPointBy.indexOf("y");
                    data = data.searchPoint(p, content);
                    if ((content = format(data, true)) && !(content = !format(p1, true))) {
                        /** @type {number} */
                        content = p1.distX - data.distX;
                        /** @type {number} */
                        var undefined = p1.dist - data.dist;
                        /** @type {number} */
                        var e = (data.series.group && data.series.group.zIndex) - (p1.series.group && p1.series.group.zIndex);
                        /** @type {boolean} */
                        content = 0 < (0 !== content && shared ? content : 0 !== undefined ? undefined : 0 !== e ? e : p1.series.index > data.series.index ? -1 : 1);
                    }
                    if (content) {
                        /** @type {!Object} */
                        p1 = data;
                    }
                });
                return p1;
            },
            getPointFromEvent: function (e) {
                e = e.target;
                var point;
                for (; e && !point;) {
                    point = e.point;
                    e = e.parentNode;
                }
                return point;
            },
            getChartCoordinatesFromPoint: function (point, inverted) {
                var yAxis = point.series;
                var xAxis = yAxis.xAxis;
                yAxis = yAxis.yAxis;
                var plotY = pick(point.clientX, point.plotX);
                var data = point.shapeArgs;
                if (xAxis && yAxis) {
                    return inverted ? {
                        chartX: xAxis.len + xAxis.pos - plotY,
                        chartY: yAxis.len + yAxis.pos - point.plotY
                    } : {
                        chartX: plotY + xAxis.pos,
                        chartY: point.plotY + yAxis.pos
                    };
                }
                if (data && data.x && data.y) {
                    return {
                        chartX: data.x,
                        chartY: data.y
                    };
                }
            },
            getHoverData: function (range, series, colors, data, shared, coordinates) {
                var d;
                /** @type {!Array} */
                var seen_opts = [];
                /** @type {boolean} */
                data = !(!data || !range);
                var elements = series && !series.stickyTracking ? [series] : colors.filter(function (s) {
                    return s.visible && !(!shared && s.directTouch) && pick(s.options.enableMouseTracking, true) && s.stickyTracking;
                });
                series = (d = data || !coordinates ? range : this.findNearestKDPoint(elements, shared, coordinates)) && d.series;
                if (d) {
                    if (shared && !series.noSharedTooltip) {
                        elements = colors.filter(function (s) {
                            return s.visible && !(!shared && s.directTouch) && pick(s.options.enableMouseTracking, true) && !s.noSharedTooltip;
                        });
                        elements.forEach(function (e) {
                            var t = $(e.points, function (node) {
                                return node.x === d.x && !node.isNull;
                            });
                            if (format(t)) {
                                if (e.chart.isBoosting) {
                                    t = e.getPoint(t);
                                }
                                seen_opts.push(t);
                            }
                        });
                    } else {
                        seen_opts.push(d);
                    }
                }
                return {
                    hoverPoint: d,
                    hoverSeries: series,
                    hoverPoints: seen_opts
                };
            },
            runPointActions: function (e, p) {
                var chart = this.chart;
                var tooltip = chart.tooltip && chart.tooltip.options.enabled ? chart.tooltip : void 0;
                var useSharedTooltip = tooltip ? tooltip.shared : false;
                var hoverPoint = p || chart.hoverPoint;
                var series = hoverPoint && hoverPoint.series || chart.hoverSeries;
                series = this.getHoverData(hoverPoint, series, chart.series, (!e || "touchmove" !== e.type) && (!!p || series && series.directTouch && this.isDirectTouch), useSharedTooltip, e);
                hoverPoint = series.hoverPoint;
                var points = series.hoverPoints;
                p = (series = series.hoverSeries) && series.tooltipOptions.followPointer;
                useSharedTooltip = useSharedTooltip && series && !series.noSharedTooltip;
                if (hoverPoint && (hoverPoint !== chart.hoverPoint || tooltip && tooltip.isHidden)) {
                    (chart.hoverPoints || []).forEach(function (comp) {
                        if (-1 === points.indexOf(comp)) {
                            comp.setState();
                        }
                    });
                    if (chart.hoverSeries !== series) {
                        series.onMouseOver();
                    }
                    this.applyInactiveState(points);
                    (points || []).forEach(function (series) {
                        series.setState("hover");
                    });
                    if (chart.hoverPoint) {
                        chart.hoverPoint.firePointEvent("mouseOut");
                    }
                    if (!hoverPoint.series) {
                        return;
                    }
                    hoverPoint.firePointEvent("mouseOver");
                    chart.hoverPoints = points;
                    chart.hoverPoint = hoverPoint;
                    if (tooltip) {
                        tooltip.refresh(useSharedTooltip ? points : hoverPoint, e);
                    }
                } else {
                    if (p && tooltip && !tooltip.isHidden) {
                        hoverPoint = tooltip.getAnchor([{}], e);
                        tooltip.updatePosition({
                            plotX: hoverPoint[0],
                            plotY: hoverPoint[1]
                        });
                    }
                }
                if (!this.unDocMouseMove) {
                    this.unDocMouseMove = addEvent(chart.container.ownerDocument, "mousemove", function (e) {
                        var chart = charts[H.hoverChartIndex];
                        if (chart) {
                            chart.pointer.onDocumentMouseMove(e);
                        }
                    });
                }
                chart.axes.forEach(function (axis) {
                    var parent = pick(axis.crosshair.snap, true);
                    var containerSize = parent ? H.find(points, function (p) {
                        return p.series[axis.coll] === axis;
                    }) : void 0;
                    if (containerSize || !parent) {
                        axis.drawCrosshair(e, containerSize);
                    } else {
                        axis.hideCrosshair();
                    }
                });
            },
            applyInactiveState: function (arr) {
                /** @type {!Array} */
                var data = [];
                var series;
                (arr || []).forEach(function (status) {
                    series = status.series;
                    data.push(series);
                    if (series.linkedParent) {
                        data.push(series.linkedParent);
                    }
                    if (series.linkedSeries) {
                        data = data.concat(series.linkedSeries);
                    }
                    if (series.navigatorSeries) {
                        data.push(series.navigatorSeries);
                    }
                });
                this.chart.series.forEach(function (button) {
                    if (-1 === data.indexOf(button)) {
                        button.setState("inactive", true);
                    } else {
                        if (button.options.inactiveOtherPoints) {
                            button.setAllPointsToState("inactive");
                        }
                    }
                });
            },
            reset: function (state, delay) {
                var chart = this.chart;
                var hoverSeries = chart.hoverSeries;
                var hoverPoint = chart.hoverPoint;
                var hoverPoints = chart.hoverPoints;
                var tooltip = chart.tooltip;
                var value = tooltip && tooltip.shared ? hoverPoints : hoverPoint;
                if (state && value) {
                    splat(value).forEach(function (point) {
                        if (point.series.isCartesian && "undefined" === typeof point.plotX) {
                            /** @type {boolean} */
                            state = false;
                        }
                    });
                }
                if (state) {
                    if (tooltip && value && splat(value).length) {
                        tooltip.refresh(value);
                        if (tooltip.shared && hoverPoints) {
                            hoverPoints.forEach(function (that) {
                                that.setState(that.state, true);
                                if (that.series.isCartesian) {
                                    if (that.series.xAxis.crosshair) {
                                        that.series.xAxis.drawCrosshair(null, that);
                                    }
                                    if (that.series.yAxis.crosshair) {
                                        that.series.yAxis.drawCrosshair(null, that);
                                    }
                                }
                            });
                        } else {
                            if (hoverPoint) {
                                hoverPoint.setState(hoverPoint.state, true);
                                chart.axes.forEach(function (axis) {
                                    if (axis.crosshair && hoverPoint.series[axis.coll] === axis) {
                                        axis.drawCrosshair(null, hoverPoint);
                                    }
                                });
                            }
                        }
                    }
                } else {
                    if (hoverPoint) {
                        hoverPoint.onMouseOut();
                    }
                    if (hoverPoints) {
                        hoverPoints.forEach(function (DefaultProvider) {
                            DefaultProvider.setState();
                        });
                    }
                    if (hoverSeries) {
                        hoverSeries.onMouseOut();
                    }
                    if (tooltip) {
                        tooltip.hide(delay);
                    }
                    if (this.unDocMouseMove) {
                        this.unDocMouseMove = this.unDocMouseMove();
                    }
                    chart.axes.forEach(function (axis) {
                        axis.hideCrosshair();
                    });
                    /** @type {null} */
                    this.hoverX = chart.hoverPoints = chart.hoverPoint = null;
                }
            },
            scaleGroups: function (a, clip) {
                var chart = this.chart;
                var b;
                chart.series.forEach(function (series) {
                    b = a || series.getPlotBox();
                    if (series.xAxis && series.xAxis.zoomEnabled && series.group) {
                        series.group.attr(b);
                        if (series.markerGroup) {
                            series.markerGroup.attr(b);
                            series.markerGroup.clip(clip ? chart.clipRect : null);
                        }
                        if (series.dataLabelsGroup) {
                            series.dataLabelsGroup.attr(b);
                        }
                    }
                });
                chart.clipRect.attr(clip || chart.clipBox);
            },
            dragStart: function (e) {
                var chart = this.chart;
                chart.mouseIsDown = e.type;
                /** @type {boolean} */
                chart.cancelClick = false;
                chart.mouseDownX = this.mouseDownX = e.chartX;
                chart.mouseDownY = this.mouseDownY = e.chartY;
            },
            drag: function (e) {
                var chart = this.chart;
                var chartOptions = chart.options.chart;
                var size = e.chartX;
                var chartY = e.chartY;
                var zoomHor = this.zoomHor;
                var zoomVert = this.zoomVert;
                var plotLeft = chart.plotLeft;
                var plotTop = chart.plotTop;
                var plotWidth = chart.plotWidth;
                var plotHeight = chart.plotHeight;
                var selectionMarker = this.selectionMarker;
                var mouseDownX = this.mouseDownX;
                var mouseDownY = this.mouseDownY;
                var q = format(chartOptions.panning) ? chartOptions.panning && chartOptions.panning.enabled : chartOptions.panning;
                var panKey = chartOptions.panKey && e[chartOptions.panKey + "Key"];
                if (!selectionMarker || !selectionMarker.touch) {
                    if (size < plotLeft ? size = plotLeft : size > plotLeft + plotWidth && (size = plotLeft + plotWidth), chartY < plotTop ? chartY = plotTop : chartY > plotTop + plotHeight && (chartY = plotTop + plotHeight), this.hasDragged = Math.sqrt(Math.pow(mouseDownX - size, 2) + Math.pow(mouseDownY - chartY, 2)), 10 < this.hasDragged) {
                        var clickedInside = chart.isInsidePlot(mouseDownX - plotLeft, mouseDownY - plotTop);
                        if (chart.hasCartesianSeries && (this.zoomX || this.zoomY) && clickedInside && !panKey && !selectionMarker) {
                            this.selectionMarker = selectionMarker = chart.renderer.rect(plotLeft, plotTop, zoomHor ? 1 : plotWidth, zoomVert ? 1 : plotHeight, 0).attr({
                                "class": "highcharts-selection-marker",
                                zIndex: 7
                            }).add();
                            if (!chart.styledMode) {
                                selectionMarker.attr({
                                    fill: chartOptions.selectionMarkerFill || color("#335cad").setOpacity(.25).get()
                                });
                            }
                        }
                        if (selectionMarker && zoomHor) {
                            /** @type {number} */
                            size = size - mouseDownX;
                            selectionMarker.attr({
                                width: Math.abs(size),
                                x: (0 < size ? 0 : size) + mouseDownX
                            });
                        }
                        if (selectionMarker && zoomVert) {
                            /** @type {number} */
                            size = chartY - mouseDownY;
                            selectionMarker.attr({
                                height: Math.abs(size),
                                y: (0 < size ? 0 : size) + mouseDownY
                            });
                        }
                        if (clickedInside && !selectionMarker && q) {
                            chart.pan(e, chartOptions.panning);
                        }
                    }
                }
            },
            drop: function (event) {
                var pointer = this;
                var chart = this.chart;
                var hasPinched = this.hasPinched;
                if (this.selectionMarker) {
                    var selectionData = {
                        originalEvent: event,
                        xAxis: [],
                        yAxis: []
                    };
                    var selectionBox = this.selectionMarker;
                    var attrName = selectionBox.attr ? selectionBox.attr("x") : selectionBox.x;
                    var selectionTop = selectionBox.attr ? selectionBox.attr("y") : selectionBox.y;
                    var a = selectionBox.attr ? selectionBox.attr("width") : selectionBox.width;
                    var Initial = selectionBox.attr ? selectionBox.attr("height") : selectionBox.height;
                    var L;
                    if (this.hasDragged || hasPinched) {
                        chart.axes.forEach(function (axis) {
                            if (axis.zoomEnabled && defined(axis.min) && (hasPinched || pointer[{
                                xAxis: "zoomX",
                                yAxis: "zoomY"
                            }[axis.coll]])) {
                                var value = axis.horiz;
                                var minPixelPadding = "touchend" === event.type ? axis.minPixelPadding : 0;
                                var first = axis.toValue((value ? attrName : selectionTop) + minPixelPadding);
                                value = axis.toValue((value ? attrName + a : selectionTop + Initial) - minPixelPadding);
                                selectionData[axis.coll].push({
                                    axis: axis,
                                    min: Math.min(first, value),
                                    max: Math.max(first, value)
                                });
                                /** @type {boolean} */
                                L = true;
                            }
                        });
                        if (L) {
                            fireEvent(chart, "selection", selectionData, function (args) {
                                chart.zoom(extend(args, hasPinched ? {
                                    animation: false
                                } : null));
                            });
                        }
                    }
                    if (merge(chart.index)) {
                        this.selectionMarker = this.selectionMarker.destroy();
                    }
                    if (hasPinched) {
                        this.scaleGroups();
                    }
                }
                if (chart && merge(chart.index)) {
                    css(chart.container, {
                        cursor: chart._cursor
                    });
                    /** @type {boolean} */
                    chart.cancelClick = 10 < this.hasDragged;
                    /** @type {boolean} */
                    chart.mouseIsDown = this.hasDragged = this.hasPinched = false;
                    /** @type {!Array} */
                    this.pinchDown = [];
                }
            },
            onContainerMouseDown: function (e) {
                e = this.normalize(e);
                if (2 !== e.button) {
                    this.zoomOption(e);
                    if (e.preventDefault) {
                        e.preventDefault();
                    }
                    this.dragStart(e);
                }
            },
            onDocumentMouseUp: function (event) {
                if (charts[H.hoverChartIndex]) {
                    charts[H.hoverChartIndex].pointer.drop(event);
                }
            },
            onDocumentMouseMove: function (e) {
                var chart = this.chart;
                var chartPosition = this.chartPosition;
                e = this.normalize(e, chartPosition);
                if (!(!chartPosition || this.inClass(e.target, "highcharts-tracker") || chart.isInsidePlot(e.chartX - chart.plotLeft, e.chartY - chart.plotTop))) {
                    this.reset();
                }
            },
            onContainerMouseLeave: function (e) {
                var chart = charts[H.hoverChartIndex];
                if (chart && (e.relatedTarget || e.toElement)) {
                    chart.pointer.reset();
                    chart.pointer.chartPosition = void 0;
                }
            },
            onContainerMouseMove: function (e) {
                var chart = this.chart;
                if (!(defined(H.hoverChartIndex) && charts[H.hoverChartIndex] && charts[H.hoverChartIndex].mouseIsDown)) {
                    H.hoverChartIndex = chart.index;
                }
                e = this.normalize(e);
                if (!e.preventDefault) {
                    /** @type {boolean} */
                    e.returnValue = false;
                }
                if ("mousedown" === chart.mouseIsDown) {
                    this.drag(e);
                }
                if (!(!this.inClass(e.target, "highcharts-tracker") && !chart.isInsidePlot(e.chartX - chart.plotLeft, e.chartY - chart.plotTop) || chart.openMenu)) {
                    this.runPointActions(e);
                }
            },
            inClass: function (element, className) {
                var elemClassName;
                for (; element;) {
                    if (elemClassName = attr(element, "class")) {
                        if (-1 !== elemClassName.indexOf(className)) {
                            return true;
                        }
                        if (-1 !== elemClassName.indexOf("highcharts-container")) {
                            return false;
                        }
                    }
                    element = element.parentNode;
                }
            },
            onTrackerMouseOut: function (e) {
                var series = this.chart.hoverSeries;
                e = e.relatedTarget || e.toElement;
                /** @type {boolean} */
                this.isDirectTouch = false;
                if (!(!series || !e || series.stickyTracking || this.inClass(e, "highcharts-tooltip") || this.inClass(e, "highcharts-series-" + series.index) && this.inClass(e, "highcharts-tracker"))) {
                    series.onMouseOut();
                }
            },
            onContainerClick: function (e) {
                var chart = this.chart;
                var hoverPoint = chart.hoverPoint;
                var plotLeft = chart.plotLeft;
                var plotTop = chart.plotTop;
                e = this.normalize(e);
                if (!chart.cancelClick) {
                    if (hoverPoint && this.inClass(e.target, "highcharts-tracker")) {
                        fireEvent(hoverPoint.series, "click", extend(e, {
                            point: hoverPoint
                        }));
                        if (chart.hoverPoint) {
                            hoverPoint.firePointEvent("click", e);
                        }
                    } else {
                        extend(e, this.getCoordinates(e));
                        if (chart.isInsidePlot(e.chartX - plotLeft, e.chartY - plotTop)) {
                            fireEvent(chart, "click", e);
                        }
                    }
                }
            },
            setDOMEvents: function () {
                var pointer = this;
                var container = pointer.chart.container;
                var doc = container.ownerDocument;
                /**
                 * @param {!Object} e
                 * @return {undefined}
                 */
                container.onmousedown = function (e) {
                    pointer.onContainerMouseDown(e);
                };
                /**
                 * @param {!Object} e
                 * @return {undefined}
                 */
                container.onmousemove = function (e) {
                    pointer.onContainerMouseMove(e);
                };
                /**
                 * @param {!Object} e
                 * @return {undefined}
                 */
                container.onclick = function (e) {
                    pointer.onContainerClick(e);
                };
                this.unbindContainerMouseLeave = addEvent(container, "mouseleave", pointer.onContainerMouseLeave);
                if (!H.unbindDocumentMouseUp) {
                    H.unbindDocumentMouseUp = addEvent(doc, "mouseup", pointer.onDocumentMouseUp);
                }
                if (H.hasTouch) {
                    addEvent(container, "touchstart", function (e) {
                        pointer.onContainerTouchStart(e);
                    });
                    addEvent(container, "touchmove", function (e) {
                        pointer.onContainerTouchMove(e);
                    });
                    if (!H.unbindDocumentTouchEnd) {
                        H.unbindDocumentTouchEnd = addEvent(doc, "touchend", pointer.onDocumentTouchEnd);
                    }
                }
            },
            destroy: function () {
                var pointer = this;
                if (pointer.unDocMouseMove) {
                    pointer.unDocMouseMove();
                }
                this.unbindContainerMouseLeave();
                if (!H.chartCount) {
                    if (H.unbindDocumentMouseUp) {
                        H.unbindDocumentMouseUp = H.unbindDocumentMouseUp();
                    }
                    if (H.unbindDocumentTouchEnd) {
                        H.unbindDocumentTouchEnd = H.unbindDocumentTouchEnd();
                    }
                }
                clearInterval(pointer.tooltipTimeout);
                objectEach(pointer, function (b, keyPart) {
                    /** @type {null} */
                    pointer[keyPart] = null;
                });
            }
        };
    });
    set(x1, "parts/TouchPointer.js", [x1["parts/Globals.js"], x1["parts/Utilities.js"]], function (H, utils) {
        var extend = utils.extend;
        var pick = utils.pick;
        var charts = H.charts;
        var noop = H.noop;
        extend(H.Pointer.prototype, {
            pinchTranslate: function (pinchDown, touches, transform, selectionMarker, clip, lastValidTouch) {
                if (this.zoomHor) {
                    this.pinchTranslateDirection(true, pinchDown, touches, transform, selectionMarker, clip, lastValidTouch);
                }
                if (this.zoomVert) {
                    this.pinchTranslateDirection(false, pinchDown, touches, transform, selectionMarker, clip, lastValidTouch);
                }
            },
            pinchTranslateDirection: function (horiz, selectionXY, setScale, transform, selectionMarker, clip, lastValidTouch, forcedScale) {
                var chart = this.chart;
                /** @type {string} */
                var xy = horiz ? "x" : "y";
                /** @type {string} */
                var XY = horiz ? "X" : "Y";
                /** @type {string} */
                var sChartXY = "chart" + XY;
                /** @type {string} */
                var wh = horiz ? "width" : "height";
                var plotLeftTop = chart["plot" + (horiz ? "Left" : "Top")];
                var selectionWH;
                var clipXY;
                var scale = forcedScale || 1;
                var inverted = chart.inverted;
                var bounds = chart.bounds[horiz ? "h" : "v"];
                /** @type {boolean} */
                var singleTouch = 1 === selectionXY.length;
                var touch0Start = selectionXY[0][sChartXY];
                var touch0Now = setScale[0][sChartXY];
                var touch1Start = !singleTouch && selectionXY[1][sChartXY];
                var touch1Now = !singleTouch && setScale[1][sChartXY];
                /**
                 * @return {undefined}
                 */
                setScale = function () {
                    if (!singleTouch && 20 < Math.abs(touch0Start - touch1Start)) {
                        scale = forcedScale || Math.abs(touch0Now - touch1Now) / Math.abs(touch0Start - touch1Start);
                    }
                    clipXY = (plotLeftTop - touch0Now) / scale + touch0Start;
                    /** @type {number} */
                    selectionWH = chart["plot" + (horiz ? "Width" : "Height")] / scale;
                };
                setScale();
                selectionXY = clipXY;
                if (selectionXY < bounds.min) {
                    selectionXY = bounds.min;
                    /** @type {boolean} */
                    var n = true;
                } else {
                    if (selectionXY + selectionWH > bounds.max) {
                        /** @type {number} */
                        selectionXY = bounds.max - selectionWH;
                        /** @type {boolean} */
                        n = true;
                    }
                }
                if (n) {
                    /** @type {number} */
                    touch0Now = touch0Now - .8 * (touch0Now - lastValidTouch[xy][0]);
                    if (!singleTouch) {
                        /** @type {number} */
                        touch1Now = touch1Now - .8 * (touch1Now - lastValidTouch[xy][1]);
                    }
                    setScale();
                } else {
                    /** @type {!Array} */
                    lastValidTouch[xy] = [touch0Now, touch1Now];
                }
                if (!inverted) {
                    /** @type {number} */
                    clip[xy] = clipXY - plotLeftTop;
                    clip[wh] = selectionWH;
                }
                clip = inverted ? 1 / scale : scale;
                selectionMarker[wh] = selectionWH;
                /** @type {string} */
                selectionMarker[xy] = selectionXY;
                transform[inverted ? horiz ? "scaleY" : "scaleX" : "scale" + XY] = scale;
                /** @type {number} */
                transform["translate" + XY] = clip * plotLeftTop + (touch0Now - clip * touch0Start);
            },
            pinch: function (e) {
                var self = this;
                var chart = self.chart;
                var pinchDown = self.pinchDown;
                var touches = e.touches;
                var l = touches.length;
                var lastValidTouch = self.lastValidTouch;
                var hasZoom = self.hasZoom;
                var selectionMarker = self.selectionMarker;
                var transform = {};
                var fireClickEvent = 1 === l && (self.inClass(e.target, "highcharts-tracker") && chart.runTrackerClick || self.runChartClick);
                var clip = {};
                if (1 < l) {
                    /** @type {boolean} */
                    self.initiated = true;
                }
                if (hasZoom && self.initiated && !fireClickEvent) {
                    e.preventDefault();
                }
                [].map.call(touches, function (a) {
                    return self.normalize(a);
                });
                if ("touchstart" === e.type) {
                    [].forEach.call(touches, function (e, i) {
                        pinchDown[i] = {
                            chartX: e.chartX,
                            chartY: e.chartY
                        };
                    });
                    /** @type {!Array} */
                    lastValidTouch.x = [pinchDown[0].chartX, pinchDown[1] && pinchDown[1].chartX];
                    /** @type {!Array} */
                    lastValidTouch.y = [pinchDown[0].chartY, pinchDown[1] && pinchDown[1].chartY];
                    chart.axes.forEach(function (axis) {
                        if (axis.zoomEnabled) {
                            var prevProfile = chart.bounds[axis.horiz ? "h" : "v"];
                            var minPixelPadding = axis.minPixelPadding;
                            var min = axis.toPixels(Math.min(pick(axis.options.min, axis.dataMin), axis.dataMin));
                            var max = axis.toPixels(Math.max(pick(axis.options.max, axis.dataMax), axis.dataMax));
                            /** @type {number} */
                            var absMax = Math.max(min, max);
                            /** @type {number} */
                            prevProfile.min = Math.min(axis.pos, Math.min(min, max) - minPixelPadding);
                            /** @type {number} */
                            prevProfile.max = Math.max(axis.pos + axis.len, absMax + minPixelPadding);
                        }
                    });
                    /** @type {boolean} */
                    self.res = true;
                } else {
                    if (self.followTouchMove && 1 === l) {
                        this.runPointActions(self.normalize(e));
                    } else {
                        if (pinchDown.length) {
                            if (!selectionMarker) {
                                self.selectionMarker = selectionMarker = extend({
                                    destroy: noop,
                                    touch: true
                                }, chart.plotBox);
                            }
                            self.pinchTranslate(pinchDown, touches, transform, selectionMarker, clip, lastValidTouch);
                            self.hasPinched = hasZoom;
                            self.scaleGroups(transform, clip);
                            if (self.res) {
                                /** @type {boolean} */
                                self.res = false;
                                this.reset(false, 0);
                            }
                        }
                    }
                }
            },
            touch: function (e, line) {
                var chart = this.chart;
                var B;
                if (chart.index !== H.hoverChartIndex) {
                    this.onContainerMouseLeave({
                        relatedTarget: true
                    });
                }
                H.hoverChartIndex = chart.index;
                if (1 === e.touches.length) {
                    if (e = this.normalize(e), (B = chart.isInsidePlot(e.chartX - chart.plotLeft, e.chartY - chart.plotTop)) && !chart.openMenu) {
                        if (line) {
                            this.runPointActions(e);
                        }
                        if ("touchmove" === e.type) {
                            line = this.pinchDown;
                            /** @type {boolean} */
                            var userRoutesActions = line[0] ? 4 <= Math.sqrt(Math.pow(line[0].chartX - e.chartX, 2) + Math.pow(line[0].chartY - e.chartY, 2)) : false;
                        }
                        if (pick(userRoutesActions, true)) {
                            this.pinch(e);
                        }
                    } else {
                        if (line) {
                            this.reset();
                        }
                    }
                } else {
                    if (2 === e.touches.length) {
                        this.pinch(e);
                    }
                }
            },
            onContainerTouchStart: function (e) {
                this.zoomOption(e);
                this.touch(e, true);
            },
            onContainerTouchMove: function (e) {
                this.touch(e);
            },
            onDocumentTouchEnd: function (event) {
                if (charts[H.hoverChartIndex]) {
                    charts[H.hoverChartIndex].pointer.drop(event);
                }
            }
        });
    });
    set(x1, "parts/MSPointer.js", [x1["parts/Globals.js"], x1["parts/Utilities.js"]], function (H, wrap) {
        var extend = wrap.extend;
        var objectEach = wrap.objectEach;
        wrap = wrap.wrap;
        var addEvent = H.addEvent;
        var charts = H.charts;
        var css = H.css;
        var d = H.doc;
        var noop = H.noop;
        var Pointer = H.Pointer;
        var removeEvent = H.removeEvent;
        var win = H.win;
        if (!H.hasTouch && (win.PointerEvent || win.MSPointerEvent)) {
            var touches = {};
            /** @type {boolean} */
            var hasPointerEvent = !!win.PointerEvent;
            /**
             * @return {?}
             */
            var getWebkitTouches = function () {
                /** @type {!Array} */
                var fake = [];
                /**
                 * @param {?} key
                 * @return {?}
                 */
                fake.item = function (key) {
                    return this[key];
                };
                objectEach(touches, function (event) {
                    fake.push({
                        pageX: event.pageX,
                        pageY: event.pageY,
                        target: event.target
                    });
                });
                return fake;
            };
            /**
             * @param {!Object} e
             * @param {string} method
             * @param {string} name
             * @param {!Object} p
             * @return {undefined}
             */
            var translateMSPointer = function (e, method, name, p) {
                if (!("touch" !== e.pointerType && e.pointerType !== e.MSPOINTER_TYPE_TOUCH || !charts[H.hoverChartIndex])) {
                    p(e);
                    p = charts[H.hoverChartIndex].pointer;
                    p[method]({
                        type: name,
                        target: e.currentTarget,
                        preventDefault: noop,
                        touches: getWebkitTouches()
                    });
                }
            };
            extend(Pointer.prototype, {
                onContainerPointerDown: function (e) {
                    translateMSPointer(e, "onContainerTouchStart", "touchstart", function (e) {
                        touches[e.pointerId] = {
                            pageX: e.pageX,
                            pageY: e.pageY,
                            target: e.currentTarget
                        };
                    });
                },
                onContainerPointerMove: function (e) {
                    translateMSPointer(e, "onContainerTouchMove", "touchmove", function (e) {
                        touches[e.pointerId] = {
                            pageX: e.pageX,
                            pageY: e.pageY
                        };
                        if (!touches[e.pointerId].target) {
                            touches[e.pointerId].target = e.currentTarget;
                        }
                    });
                },
                onDocumentPointerUp: function (e) {
                    translateMSPointer(e, "onDocumentTouchEnd", "touchend", function (e) {
                        delete touches[e.pointerId];
                    });
                },
                batchMSEvents: function (fn) {
                    fn(this.chart.container, hasPointerEvent ? "pointerdown" : "MSPointerDown", this.onContainerPointerDown);
                    fn(this.chart.container, hasPointerEvent ? "pointermove" : "MSPointerMove", this.onContainerPointerMove);
                    fn(d, hasPointerEvent ? "pointerup" : "MSPointerUp", this.onDocumentPointerUp);
                }
            });
            wrap(Pointer.prototype, "init", function (proceed, chart, touches) {
                proceed.call(this, chart, touches);
                if (this.hasZoom) {
                    css(chart.container, {
                        "-ms-touch-action": "none",
                        "touch-action": "none"
                    });
                }
            });
            wrap(Pointer.prototype, "setDOMEvents", function (prevModFn) {
                prevModFn.apply(this);
                if (this.hasZoom || this.followTouchMove) {
                    this.batchMSEvents(addEvent);
                }
            });
            wrap(Pointer.prototype, "destroy", function (realPrint) {
                this.batchMSEvents(removeEvent);
                realPrint.call(this);
            });
        }
    });
    set(x1, "parts/Legend.js", [x1["parts/Globals.js"], x1["parts/Utilities.js"]], function (H, _) {
        var defined = _.defined;
        var discardElement = _.discardElement;
        var isNumber = _.isNumber;
        var pick = _.pick;
        var _isFunction = _.relativeLength;
        var callback = _.setAnimation;
        var range = _.syncTimeout;
        _ = _.wrap;
        var addEvent = H.addEvent;
        var css = H.css;
        var each = H.fireEvent;
        var isFirefox = H.isFirefox;
        var marginNames = H.marginNames;
        var merge = H.merge;
        var stableSort = H.stableSort;
        var win = H.win;
        /**
         * @param {undefined} options
         * @param {undefined} callback
         * @return {undefined}
         */
        H.Legend = function (options, callback) {
            this.init(options, callback);
        };
        H.Legend.prototype = {
            init: function (chart, options) {
                /** @type {!Object} */
                this.chart = chart;
                this.setOptions(options);
                if (options.enabled) {
                    this.render();
                    addEvent(this.chart, "endResize", function () {
                        this.legend.positionCheckboxes();
                    });
                    if (this.proximate) {
                        this.unchartrender = addEvent(this.chart, "render", function () {
                            this.legend.proximatePositions();
                            this.legend.positionItems();
                        });
                    } else {
                        if (this.unchartrender) {
                            this.unchartrender();
                        }
                    }
                }
            },
            setOptions: function (options) {
                var padding = pick(options.padding, 8);
                /** @type {!Object} */
                this.options = options;
                if (!this.chart.styledMode) {
                    this.itemStyle = options.itemStyle;
                    this.itemHiddenStyle = merge(this.itemStyle, options.itemHiddenStyle);
                }
                this.itemMarginTop = options.itemMarginTop || 0;
                this.itemMarginBottom = options.itemMarginBottom || 0;
                this.padding = padding;
                /** @type {number} */
                this.initialItemY = padding - 5;
                this.symbolWidth = pick(options.symbolWidth, 16);
                /** @type {!Array} */
                this.pages = [];
                /** @type {boolean} */
                this.proximate = "proximate" === options.layout && !this.chart.inverted;
            },
            update: function (options, redraw) {
                var chart = this.chart;
                this.setOptions(merge(true, this.options, options));
                this.destroy();
                /** @type {boolean} */
                chart.isDirtyLegend = chart.isDirtyBox = true;
                if (pick(redraw, true)) {
                    chart.redraw();
                }
                each(this, "afterUpdate");
            },
            colorizeItem: function (item, visible) {
                item.legendGroup[visible ? "removeClass" : "addClass"]("highcharts-legend-item-hidden");
                if (!this.chart.styledMode) {
                    var opt = this.options;
                    var legendItem = item.legendItem;
                    var legendLine = item.legendLine;
                    var legendSymbol = item.legendSymbol;
                    var hiddenColor = this.itemHiddenStyle.color;
                    opt = visible ? opt.itemStyle.color : hiddenColor;
                    var symbolColor = visible ? item.color || hiddenColor : hiddenColor;
                    var markerOptions = item.options && item.options.marker;
                    var symbolAttr = {
                        fill: symbolColor
                    };
                    if (legendItem) {
                        legendItem.css({
                            fill: opt,
                            color: opt
                        });
                    }
                    if (legendLine) {
                        legendLine.attr({
                            stroke: symbolColor
                        });
                    }
                    if (legendSymbol) {
                        if (markerOptions && legendSymbol.isMarker) {
                            symbolAttr = item.pointAttribs();
                            if (!visible) {
                                symbolAttr.stroke = symbolAttr.fill = hiddenColor;
                            }
                        }
                        legendSymbol.attr(symbolAttr);
                    }
                }
                each(this, "afterColorizeItem", {
                    item: item,
                    visible: visible
                });
            },
            positionItems: function () {
                this.allItems.forEach(this.positionItem, this);
                if (!this.chart.isResizing) {
                    this.positionCheckboxes();
                }
            },
            positionItem: function (item) {
                var options = this.options;
                var spacing = options.symbolPadding;
                /** @type {boolean} */
                options = !options.rtl;
                var value = item._legendItemPos;
                var url = value[0];
                value = value[1];
                var node = item.checkbox;
                if ((item = item.legendGroup) && item.element) {
                    item[defined(item.translateY) ? "animate" : "attr"]({
                        translateX: options ? url : this.legendWidth - url - 2 * spacing - 4,
                        translateY: value
                    });
                }
                if (node) {
                    node.x = url;
                    node.y = value;
                }
            },
            destroyItem: function (obj) {
                var c = obj.checkbox;
                ["legendItem", "legendLine", "legendSymbol", "legendGroup"].forEach(function (index) {
                    if (obj[index]) {
                        obj[index] = obj[index].destroy();
                    }
                });
                if (c) {
                    discardElement(obj.checkbox);
                }
            },
            destroy: function () {
                /**
                 * @param {?} socketId
                 * @return {undefined}
                 */
                function destroy(socketId) {
                    if (this[socketId]) {
                        this[socketId] = this[socketId].destroy();
                    }
                }
                this.getAllItems().forEach(function (processChild) {
                    ["legendItem", "legendGroup"].forEach(destroy, processChild);
                });
                "clipRect up down pager nav box title group".split(" ").forEach(destroy, this);
                /** @type {null} */
                this.display = null;
            },
            positionCheckboxes: function () {
                var alignAttr = this.group && this.group.alignAttr;
                var clipHeight = this.clipHeight || this.legendHeight;
                var titleHeight = this.titleHeight;
                if (alignAttr) {
                    var translateY = alignAttr.translateY;
                    this.allItems.forEach(function (item) {
                        var node = item.checkbox;
                        if (node) {
                            var top = translateY + titleHeight + node.y + (this.scrollOffset || 0) + 3;
                            css(node, {
                                left: alignAttr.translateX + item.checkboxOffset + node.x - 20 + "px",
                                top: top + "px",
                                display: this.proximate || top > translateY - 6 && top < translateY + clipHeight - 6 ? "" : "none"
                            });
                        }
                    }, this);
                }
            },
            renderTitle: function () {
                var options = this.options;
                var padding = this.padding;
                var titleOptions = options.title;
                /** @type {number} */
                var titleHeight = 0;
                if (titleOptions.text) {
                    if (!this.title) {
                        this.title = this.chart.renderer.label(titleOptions.text, padding - 3, padding - 4, null, null, null, options.useHTML, null, "legend-title").attr({
                            zIndex: 1
                        });
                        if (!this.chart.styledMode) {
                            this.title.css(titleOptions.style);
                        }
                        this.title.add(this.group);
                    }
                    if (!titleOptions.width) {
                        this.title.css({
                            width: this.maxLegendWidth + "px"
                        });
                    }
                    options = this.title.getBBox();
                    titleHeight = options.height;
                    this.offsetWidth = options.width;
                    this.contentGroup.attr({
                        translateY: titleHeight
                    });
                }
                this.titleHeight = titleHeight;
            },
            setText: function (item) {
                var options = this.options;
                item.legendItem.attr({
                    text: options.labelFormat ? H.format(options.labelFormat, item, this.chart) : options.labelFormatter.call(item)
                });
            },
            renderItem: function (item) {
                var chart = this.chart;
                var renderer = chart.renderer;
                var options = this.options;
                var symbolWidth = this.symbolWidth;
                var symbolPadding = options.symbolPadding;
                var itemStyle = this.itemStyle;
                var itemHiddenStyle = this.itemHiddenStyle;
                var diff = "horizontal" === options.layout ? pick(options.itemDistance, 20) : 0;
                /** @type {boolean} */
                var ltr = !options.rtl;
                var li = item.legendItem;
                /** @type {boolean} */
                var isSeries = !item.series;
                var series = !isSeries && item.series.drawLegendSymbol ? item.series : item;
                var seriesOptions = series.options;
                seriesOptions = this.createCheckboxForItem && seriesOptions && seriesOptions.showCheckbox;
                diff = symbolWidth + symbolPadding + diff + (seriesOptions ? 20 : 0);
                var r = options.useHTML;
                var cls = item.options.className;
                if (!li) {
                    item.legendGroup = renderer.g("legend-item").addClass("highcharts-" + series.type + "-series highcharts-color-" + item.colorIndex + (cls ? " " + cls : "") + (isSeries ? " highcharts-series-" + item.index : "")).attr({
                        zIndex: 1
                    }).add(this.scrollGroup);
                    item.legendItem = li = renderer.text("", ltr ? symbolWidth + symbolPadding : -symbolPadding, this.baseline || 0, r);
                    if (!chart.styledMode) {
                        li.css(merge(item.visible ? itemStyle : itemHiddenStyle));
                    }
                    li.attr({
                        align: ltr ? "left" : "right",
                        zIndex: 2
                    }).add(item.legendGroup);
                    if (!this.baseline) {
                        this.fontMetrics = renderer.fontMetrics(chart.styledMode ? 12 : itemStyle.fontSize, li);
                        this.baseline = this.fontMetrics.f + 3 + this.itemMarginTop;
                        li.attr("y", this.baseline);
                    }
                    this.symbolHeight = options.symbolHeight || this.fontMetrics.f;
                    series.drawLegendSymbol(this, item);
                    if (this.setItemEvents) {
                        this.setItemEvents(item, li, r);
                    }
                }
                if (seriesOptions && !item.checkbox) {
                    this.createCheckboxForItem(item);
                }
                this.colorizeItem(item, item.visible);
                if (!(!chart.styledMode && itemStyle.width)) {
                    li.css({
                        width: (options.itemWidth || this.widthOption || chart.spacingBox.width) - diff
                    });
                }
                this.setText(item);
                chart = li.getBBox();
                item.itemWidth = item.checkboxOffset = options.itemWidth || item.legendItemWidth || chart.width + diff;
                /** @type {number} */
                this.maxItemWidth = Math.max(this.maxItemWidth, item.itemWidth);
                this.totalItemWidth += item.itemWidth;
                /** @type {number} */
                this.itemHeight = item.itemHeight = Math.round(item.legendItemHeight || chart.height || this.symbolHeight);
            },
            layoutItem: function (me) {
                var options = this.options;
                var padding = this.padding;
                /** @type {boolean} */
                var horizontal = "horizontal" === options.layout;
                var height = me.itemHeight;
                var px = this.itemMarginBottom;
                var avatarTop = this.itemMarginTop;
                var type = horizontal ? pick(options.itemDistance, 20) : 0;
                var width = this.maxLegendWidth;
                options = options.alignColumns && this.totalItemWidth > width ? this.maxItemWidth : me.itemWidth;
                if (horizontal && this.itemX - padding + options > width) {
                    this.itemX = padding;
                    if (this.lastLineHeight) {
                        this.itemY += avatarTop + this.lastLineHeight + px;
                    }
                    /** @type {number} */
                    this.lastLineHeight = 0;
                }
                this.lastItemY = avatarTop + this.itemY + px;
                /** @type {number} */
                this.lastLineHeight = Math.max(height, this.lastLineHeight);
                /** @type {!Array} */
                me._legendItemPos = [this.itemX, this.itemY];
                if (horizontal) {
                    this.itemX += options;
                } else {
                    this.itemY += avatarTop + height + px;
                    this.lastLineHeight = height;
                }
                this.offsetWidth = this.widthOption || Math.max((horizontal ? this.itemX - padding - (me.checkbox ? 0 : type) : options) + padding, this.offsetWidth);
            },
            getAllItems: function () {
                /** @type {!Array} */
                var allItems = [];
                this.chart.series.forEach(function (series) {
                    var seriesOptions = series && series.options;
                    if (series && pick(seriesOptions.showInLegend, defined(seriesOptions.linkedTo) ? false : void 0, true)) {
                        allItems = allItems.concat(series.legendItems || ("point" === seriesOptions.legendType ? series.data : series));
                    }
                });
                each(this, "afterGetAllItems", {
                    allItems: allItems
                });
                return allItems;
            },
            getAlignment: function () {
                var options = this.options;
                return this.proximate ? options.align.charAt(0) + "tv" : options.floating ? "" : options.align.charAt(0) + options.verticalAlign.charAt(0) + options.layout.charAt(0);
            },
            adjustMargins: function (margin, spacing) {
                var chart = this.chart;
                var options = this.options;
                var f = this.getAlignment();
                if (f) {
                    [/(lth|ct|rth)/, /(rtv|rm|rbv)/, /(rbh|cb|lbh)/, /(lbv|lm|ltv)/].forEach(function (r_tag, side) {
                        if (r_tag.test(f) && !defined(margin[side])) {
                            /** @type {number} */
                            chart[marginNames[side]] = Math.max(chart[marginNames[side]], chart.legend[(side + 1) % 2 ? "legendHeight" : "legendWidth"] + [1, -1, -1, 1][side] * options[side % 2 ? "x" : "y"] + pick(options.margin, 12) + spacing[side] + (chart.titleOffset[side] || 0));
                        }
                    });
                }
            },
            proximatePositions: function () {
                var chart = this.chart;
                /** @type {!Array} */
                var positions = [];
                /** @type {boolean} */
                var enableAutoPurchase = "left" === this.options.align;
                this.allItems.forEach(function (item) {
                    /** @type {boolean} */
                    var value = enableAutoPurchase;
                    if (item.yAxis && item.points) {
                        if (item.xAxis.options.reversed) {
                            /** @type {boolean} */
                            value = !value;
                        }
                        var h = H.find(value ? item.points : item.points.slice(0).reverse(), function (point) {
                            return isNumber(point.plotY);
                        });
                        value = this.itemMarginTop + item.legendItem.getBBox().height + this.itemMarginBottom;
                        /** @type {number} */
                        var height = item.yAxis.top - chart.plotTop;
                        if (item.visible) {
                            h = h ? h.plotY : item.yAxis.height;
                            h = h + (height - .3 * value);
                        } else {
                            h = height + item.yAxis.height;
                        }
                        positions.push({
                            target: h,
                            size: value,
                            item: item
                        });
                    }
                }, this);
                H.distribute(positions, chart.plotHeight);
                positions.forEach(function (a) {
                    a.item._legendItemPos[1] = chart.plotTop - chart.spacing[0] + a.pos;
                });
            },
            render: function () {
                var chart = this.chart;
                var data = chart.renderer;
                var element = this.group;
                var display;
                var box = this.box;
                var options = this.options;
                var i = this.padding;
                this.itemX = i;
                this.itemY = this.initialItemY;
                /** @type {number} */
                this.lastItemY = this.offsetWidth = 0;
                this.widthOption = _isFunction(options.width, chart.spacingBox.width - i);
                /** @type {number} */
                var r = chart.spacingBox.width - 2 * i - options.x;
                if (-1 < ["rm", "lm"].indexOf(this.getAlignment().substring(0, 2))) {
                    /** @type {number} */
                    r = r / 2;
                }
                this.maxLegendWidth = this.widthOption || r;
                if (!element) {
                    this.group = element = data.g("legend").attr({
                        zIndex: 7
                    }).add();
                    this.contentGroup = data.g().attr({
                        zIndex: 1
                    }).add(element);
                    this.scrollGroup = data.g().add(this.contentGroup);
                }
                this.renderTitle();
                r = this.getAllItems();
                stableSort(r, function (a, b) {
                    return (a.options && a.options.legendIndex || 0) - (b.options && b.options.legendIndex || 0);
                });
                if (options.reversed) {
                    r.reverse();
                }
                this.allItems = r;
                /** @type {boolean} */
                this.display = display = !!r.length;
                /** @type {number} */
                this.itemHeight = this.totalItemWidth = this.maxItemWidth = this.lastLineHeight = 0;
                r.forEach(this.renderItem, this);
                r.forEach(this.layoutItem, this);
                r = (this.widthOption || this.offsetWidth) + i;
                var e = this.lastItemY + this.lastLineHeight + this.titleHeight;
                e = this.handleOverflow(e);
                e = e + i;
                if (!box) {
                    this.box = box = data.rect().addClass("highcharts-legend-box").attr({
                        r: options.borderRadius
                    }).add(element);
                    /** @type {boolean} */
                    box.isNew = true;
                }
                if (!chart.styledMode) {
                    box.attr({
                        stroke: options.borderColor,
                        "stroke-width": options.borderWidth || 0,
                        fill: options.backgroundColor || "none"
                    }).shadow(options.shadow);
                }
                if (0 < r && 0 < e) {
                    box[box.isNew ? "attr" : "animate"](box.crisp.call({}, {
                        x: 0,
                        y: 0,
                        width: r,
                        height: e
                    }, box.strokeWidth()));
                    /** @type {boolean} */
                    box.isNew = false;
                }
                box[display ? "show" : "hide"]();
                if (chart.styledMode && "none" === element.getStyle("display")) {
                    /** @type {number} */
                    r = e = 0;
                }
                this.legendWidth = r;
                this.legendHeight = e;
                if (display) {
                    data = chart.spacingBox;
                    box = data.y;
                    if (/(lth|ct|rth)/.test(this.getAlignment()) && 0 < chart.titleOffset[0]) {
                        box = box + chart.titleOffset[0];
                    } else {
                        if (/(lbh|cb|rbh)/.test(this.getAlignment()) && 0 < chart.titleOffset[2]) {
                            /** @type {number} */
                            box = box - chart.titleOffset[2];
                        }
                    }
                    if (box !== data.y) {
                        data = merge(data, {
                            y: box
                        });
                    }
                    element.align(merge(options, {
                        width: r,
                        height: e,
                        verticalAlign: this.proximate ? "top" : options.verticalAlign
                    }), true, data);
                }
                if (!this.proximate) {
                    this.positionItems();
                }
                each(this, "afterRender");
            },
            handleOverflow: function (text) {
                var legend = this;
                var chart = this.chart;
                var renderer = chart.renderer;
                var options = this.options;
                var value = options.y;
                var padding = this.padding;
                /** @type {number} */
                value = chart.spacingBox.height + ("top" === options.verticalAlign ? -value : value) - padding;
                var h = options.maxHeight;
                var clipHeight;
                var d = this.clipRect;
                var navOptions = options.navigation;
                var animation = pick(navOptions.animation, true);
                var height = navOptions.arrowSize || 12;
                var nav = this.nav;
                var pages = this.pages;
                var lastY;
                var cells = this.allItems;
                /**
                 * @param {!Object} height
                 * @return {undefined}
                 */
                var clipToHeight = function (height) {
                    if ("number" === typeof height) {
                        d.attr({
                            height: height
                        });
                    } else {
                        if (d) {
                            legend.clipRect = d.destroy();
                            legend.contentGroup.clip();
                        }
                    }
                    if (legend.contentGroup.div) {
                        /** @type {string} */
                        legend.contentGroup.div.style.clip = height ? "rect(" + padding + "px,9999px," + (padding + height) + "px,0)" : "auto";
                    }
                };
                /**
                 * @param {string} name
                 * @return {?}
                 */
                var render = function (name) {
                    legend[name] = renderer.circle(0, 0, 1.3 * height).translate(height / 2, height / 2).add(nav);
                    if (!chart.styledMode) {
                        legend[name].attr("fill", "rgba(0,0,0,0.0001)");
                    }
                    return legend[name];
                };
                if (!("horizontal" !== options.layout || "middle" === options.verticalAlign || options.floating)) {
                    /** @type {number} */
                    value = value / 2;
                }
                if (h) {
                    /** @type {number} */
                    value = Math.min(value, h);
                }
                /** @type {number} */
                pages.length = 0;
                if (text > value && false !== navOptions.enabled) {
                    /** @type {number} */
                    this.clipHeight = clipHeight = Math.max(value - 20 - this.titleHeight - padding, 0);
                    this.currentPage = pick(this.currentPage, 1);
                    /** @type {!Object} */
                    this.fullHeight = text;
                    cells.forEach(function (item, lastIndex) {
                        var y = item._legendItemPos[1];
                        /** @type {number} */
                        var h = Math.round(item.legendItem.getBBox().height);
                        var i = pages.length;
                        if (!i || y - pages[i - 1] > clipHeight && (lastY || y) !== pages[i - 1]) {
                            pages.push(lastY || y);
                            i++;
                        }
                        /** @type {number} */
                        item.pageIx = i - 1;
                        if (lastY) {
                            /** @type {number} */
                            cells[lastIndex - 1].pageIx = i - 1;
                        }
                        if (lastIndex === cells.length - 1 && y + h - pages[i - 1] > clipHeight && y !== lastY) {
                            pages.push(y);
                            item.pageIx = i;
                        }
                        if (y !== lastY) {
                            lastY = y;
                        }
                    });
                    if (!d) {
                        d = legend.clipRect = renderer.clipRect(0, padding, 9999, 0);
                        legend.contentGroup.clip(d);
                    }
                    clipToHeight(clipHeight);
                    if (!nav) {
                        this.nav = nav = renderer.g().attr({
                            zIndex: 1
                        }).add(this.group);
                        this.up = renderer.symbol("triangle", 0, 0, height, height).add(nav);
                        render("upTracker").on("click", function () {
                            legend.scroll(-1, animation);
                        });
                        this.pager = renderer.text("", 15, 10).addClass("highcharts-legend-navigation");
                        if (!chart.styledMode) {
                            this.pager.css(navOptions.style);
                        }
                        this.pager.add(nav);
                        this.down = renderer.symbol("triangle-down", 0, 0, height, height).add(nav);
                        render("downTracker").on("click", function () {
                            legend.scroll(1, animation);
                        });
                    }
                    legend.scroll(0);
                    /** @type {number} */
                    text = value;
                } else {
                    if (nav) {
                        clipToHeight();
                        this.nav = nav.destroy();
                        this.scrollGroup.attr({
                            translateY: 1
                        });
                        /** @type {number} */
                        this.clipHeight = 0;
                    }
                }
                return text;
            },
            scroll: function (scrollBy, options) {
                var extraCheckers = this;
                var chart = this.chart;
                var pages = this.pages;
                var pageCount = pages.length;
                var currentPage = this.currentPage + scrollBy;
                scrollBy = this.clipHeight;
                var navOptions = this.options.navigation;
                var pager = this.pager;
                var left = this.padding;
                if (currentPage > pageCount) {
                    currentPage = pageCount;
                }
                if (0 < currentPage) {
                    if ("undefined" !== typeof options) {
                        callback(options, chart);
                    }
                    this.nav.attr({
                        translateX: left,
                        translateY: scrollBy + this.padding + 7 + this.titleHeight,
                        visibility: "visible"
                    });
                    [this.up, this.upTracker].forEach(function ($this) {
                        $this.attr({
                            "class": 1 === currentPage ? "highcharts-legend-nav-inactive" : "highcharts-legend-nav-active"
                        });
                    });
                    pager.attr({
                        text: currentPage + "/" + pageCount
                    });
                    [this.down, this.downTracker].forEach(function (a) {
                        a.attr({
                            x: 18 + this.pager.getBBox().width,
                            "class": currentPage === pageCount ? "highcharts-legend-nav-inactive" : "highcharts-legend-nav-active"
                        });
                    }, this);
                    if (!chart.styledMode) {
                        this.up.attr({
                            fill: 1 === currentPage ? navOptions.inactiveColor : navOptions.activeColor
                        });
                        this.upTracker.css({
                            cursor: 1 === currentPage ? "default" : "pointer"
                        });
                        this.down.attr({
                            fill: currentPage === pageCount ? navOptions.inactiveColor : navOptions.activeColor
                        });
                        this.downTracker.css({
                            cursor: currentPage === pageCount ? "default" : "pointer"
                        });
                    }
                    this.scrollOffset = -pages[currentPage - 1] + this.initialItemY;
                    this.scrollGroup.animate({
                        translateY: this.scrollOffset
                    });
                    this.currentPage = currentPage;
                    this.positionCheckboxes();
                    options = H.animObject(pick(options, chart.renderer.globalAnimation, true));
                    range(function () {
                        each(extraCheckers, "afterScroll", {
                            currentPage: currentPage
                        });
                    }, options.duration || 0);
                }
            }
        };
        H.LegendSymbolMixin = {
            drawRectangle: function (legend, item) {
                var symbolHeight = legend.symbolHeight;
                var square = legend.options.squareSymbol;
                item.legendSymbol = this.chart.renderer.rect(square ? (legend.symbolWidth - symbolHeight) / 2 : 0, legend.baseline - symbolHeight + 1, square ? symbolHeight : legend.symbolWidth, symbolHeight, pick(legend.options.symbolRadius, symbolHeight / 2)).addClass("highcharts-point").attr({
                    zIndex: 3
                }).add(item.legendGroup);
            },
            drawLineMarker: function (legend) {
                var radius = this.options;
                var markerOptions = radius.marker;
                var symbolWidth = legend.symbolWidth;
                var symbolHeight = legend.symbolHeight;
                /** @type {number} */
                var x = symbolHeight / 2;
                var renderer = this.chart.renderer;
                var group = this.legendGroup;
                /** @type {number} */
                legend = legend.baseline - Math.round(.3 * legend.fontMetrics.b);
                var attr = {};
                if (!this.chart.styledMode) {
                    attr = {
                        "stroke-width": radius.lineWidth || 0
                    };
                    if (radius.dashStyle) {
                        attr.dashstyle = radius.dashStyle;
                    }
                }
                this.legendLine = renderer.path(["M", 0, legend, "L", symbolWidth, legend]).addClass("highcharts-graph").attr(attr).add(group);
                if (markerOptions && false !== markerOptions.enabled && symbolWidth) {
                    /** @type {number} */
                    radius = Math.min(pick(markerOptions.radius, x), x);
                    if (0 === this.symbol.indexOf("url")) {
                        markerOptions = merge(markerOptions, {
                            width: symbolHeight,
                            height: symbolHeight
                        });
                        /** @type {number} */
                        radius = 0;
                    }
                    this.legendSymbol = markerOptions = renderer.symbol(this.symbol, symbolWidth / 2 - radius, legend - radius, 2 * radius, 2 * radius, markerOptions).addClass("highcharts-point").add(group);
                    /** @type {boolean} */
                    markerOptions.isMarker = true;
                }
            }
        };
        if (/Trident\/7\.0/.test(win.navigator && win.navigator.userAgent) || isFirefox) {
            _(H.Legend.prototype, "positionItem", function (b, item) {
                var d = this;
                /**
                 * @return {undefined}
                 */
                var runPositionItem = function () {
                    if (item._legendItemPos) {
                        b.call(d, item);
                    }
                };
                runPositionItem();
                if (!d.bubbleLegend) {
                    setTimeout(runPositionItem);
                }
            });
        }
    });
    set(x1, "parts/Chart.js", [x1["parts/Globals.js"], x1["parts/Utilities.js"]], function (me, H) {
        var animObject = H.animObject;
        var attr = H.attr;
        var defined = H.defined;
        var discardElement = H.discardElement;
        var erase = H.erase;
        var extend = H.extend;
        var isArray = H.isArray;
        var isNumber = H.isNumber;
        var isObject = H.isObject;
        var isString = H.isString;
        var numberFormat = H.numberFormat;
        var objectEach = H.objectEach;
        var pick = H.pick;
        var pInt = H.pInt;
        var getStyle = H.relativeLength;
        var callback = H.setAnimation;
        var splat = H.splat;
        var syncTimeout = H.syncTimeout;
        var addEvent = me.addEvent;
        var animate = me.animate;
        var doc = me.doc;
        var Axis = me.Axis;
        var createElement = me.createElement;
        var defaults = me.defaultOptions;
        var charts = me.charts;
        var css = me.css;
        var find = me.find;
        var fireEvent = me.fireEvent;
        var Legend = me.Legend;
        var marginNames = me.marginNames;
        var merge = me.merge;
        var Pointer = me.Pointer;
        var removeEvent = me.removeEvent;
        var seriesTypes = me.seriesTypes;
        var win = me.win;
        /** @type {function(): undefined} */
        var Chart = me.Chart = function () {
            this.getArgs.apply(this, arguments);
        };
        /**
         * @param {?} name
         * @param {?} data
         * @param {!Function} c
         * @return {?}
         */
        me.chart = function (name, data, c) {
            return new Chart(name, data, c);
        };
        extend(Chart.prototype, {
            callbacks: [],
            getArgs: function () {
                /** @type {!Array<?>} */
                var args = [].slice.call(arguments);
                if (isString(args[0]) || args[0].nodeName) {
                    this.renderTo = args.shift();
                }
                this.init(args[0], args[1]);
            },
            init: function (userOptions, callback) {
                var options;
                var seriesOptions = userOptions.series;
                var userPlotOptions = userOptions.plotOptions || {};
                fireEvent(this, "init", {
                    args: arguments
                }, function () {
                    /** @type {null} */
                    userOptions.series = null;
                    options = merge(defaults, userOptions);
                    objectEach(options.plotOptions, function (a, type) {
                        if (isObject(a)) {
                            a.tooltip = userPlotOptions[type] && merge(userPlotOptions[type].tooltip) || void 0;
                        }
                    });
                    options.tooltip.userOptions = userOptions.chart && userOptions.chart.forExport && userOptions.tooltip.userOptions || userOptions.tooltip;
                    options.series = userOptions.series = seriesOptions;
                    /** @type {!Object} */
                    this.userOptions = userOptions;
                    var optionsChart = options.chart;
                    var chartEvents = optionsChart.events;
                    /** @type {!Array} */
                    this.margin = [];
                    /** @type {!Array} */
                    this.spacing = [];
                    this.bounds = {
                        h: {},
                        v: {}
                    };
                    /** @type {!Array} */
                    this.labelCollectors = [];
                    /** @type {!Object} */
                    this.callback = callback;
                    /** @type {number} */
                    this.isResizing = 0;
                    this.options = options;
                    /** @type {!Array} */
                    this.axes = [];
                    /** @type {!Array} */
                    this.series = [];
                    this.time = userOptions.time && Object.keys(userOptions.time).length ? new me.Time(userOptions.time) : me.time;
                    this.numberFormatter = optionsChart.numberFormatter || numberFormat;
                    this.styledMode = optionsChart.styledMode;
                    this.hasCartesianSeries = optionsChart.showAxes;
                    var chart = this;
                    chart.index = charts.length;
                    charts.push(chart);
                    me.chartCount++;
                    if (chartEvents) {
                        objectEach(chartEvents, function (a, play) {
                            if (me.isFunction(a)) {
                                addEvent(chart, play, a);
                            }
                        });
                    }
                    /** @type {!Array} */
                    chart.xAxis = [];
                    /** @type {!Array} */
                    chart.yAxis = [];
                    /** @type {number} */
                    chart.pointCount = chart.colorCounter = chart.symbolCounter = 0;
                    fireEvent(chart, "afterInit");
                    chart.firstRender();
                });
            },
            initSeries: function (options) {
                var series = this.options.chart;
                series = options.type || series.type || series.defaultSeriesType;
                var Constr = seriesTypes[series];
                if (!Constr) {
                    me.error(17, true, this, {
                        missingModuleFor: series
                    });
                }
                series = new Constr;
                series.init(this, options);
                return series;
            },
            setSeriesData: function () {
                this.getSeriesOrderByLinks().forEach(function (node) {
                    if (!(node.points || node.data || !node.enabledDataSorting)) {
                        node.setData(node.options.data, false);
                    }
                });
            },
            getSeriesOrderByLinks: function () {
                return this.series.concat().sort(function (series, harvestContext) {
                    return series.linkedSeries.length || harvestContext.linkedSeries.length ? harvestContext.linkedSeries.length - series.linkedSeries.length : 0;
                });
            },
            orderSeries: function (i) {
                var regions = this.series;
                i = i || 0;
                for (; i < regions.length; i++) {
                    if (regions[i]) {
                        /** @type {number} */
                        regions[i].index = i;
                        regions[i].name = regions[i].getName();
                    }
                }
            },
            isInsidePlot: function (y, plotY, inverted) {
                var x = inverted ? plotY : y;
                y = inverted ? y : plotY;
                return 0 <= x && x <= this.plotWidth && 0 <= y && y <= this.plotHeight;
            },
            redraw: function (id) {
                fireEvent(this, "beforeRedraw");
                var a = this.axes;
                var s = this.series;
                var pointer = this.pointer;
                var obj = this.legend;
                var legend = this.userOptions.legend;
                var isScrolling = this.isDirtyLegend;
                var t = this.hasCartesianSeries;
                var isDirtyBox = this.isDirtyBox;
                var renderer = this.renderer;
                var l = renderer.isHidden();
                /** @type {!Array} */
                var failureRecaps = [];
                if (this.setResponsive) {
                    this.setResponsive(false);
                }
                callback(id, this);
                if (l) {
                    this.temporaryDisplay();
                }
                this.layOutTitles();
                id = s.length;
                for (; id--;) {
                    var t = s[id];
                    if (t.options.stacking) {
                        /** @type {boolean} */
                        var hasStackedSeries = true;
                        if (t.isDirty) {
                            /** @type {boolean} */
                            var z = true;
                            break;
                        }
                    }
                }
                if (z) {
                    id = s.length;
                    for (; id--;) {
                        t = s[id];
                        if (t.options.stacking) {
                            /** @type {boolean} */
                            t.isDirty = true;
                        }
                    }
                }
                s.forEach(function (serie) {
                    if (serie.isDirty) {
                        if ("point" === serie.options.legendType) {
                            if (serie.updateTotals) {
                                serie.updateTotals();
                            }
                            /** @type {boolean} */
                            isScrolling = true;
                        } else {
                            if (legend && (legend.labelFormatter || legend.labelFormat)) {
                                /** @type {boolean} */
                                isScrolling = true;
                            }
                        }
                    }
                    if (serie.isDirtyData) {
                        fireEvent(serie, "updatedData");
                    }
                });
                if (isScrolling && obj && obj.options.enabled) {
                    obj.render();
                    /** @type {boolean} */
                    this.isDirtyLegend = false;
                }
                if (hasStackedSeries) {
                    this.getStacks();
                }
                if (t) {
                    a.forEach(function (axis) {
                        axis.updateNames();
                        axis.setScale();
                    });
                }
                this.getMargins();
                if (t) {
                    a.forEach(function (cur) {
                        if (cur.isDirty) {
                            /** @type {boolean} */
                            isDirtyBox = true;
                        }
                    });
                    a.forEach(function (axis) {
                        /** @type {string} */
                        var key = axis.min + "," + axis.max;
                        if (axis.extKey !== key) {
                            /** @type {string} */
                            axis.extKey = key;
                            failureRecaps.push(function () {
                                fireEvent(axis, "afterSetExtremes", extend(axis.eventArgs, axis.getExtremes()));
                                delete axis.eventArgs;
                            });
                        }
                        if (isDirtyBox || hasStackedSeries) {
                            axis.redraw();
                        }
                    });
                }
                if (isDirtyBox) {
                    this.drawChartBox();
                }
                fireEvent(this, "predraw");
                s.forEach(function (serie) {
                    if ((isDirtyBox || serie.isDirty) && serie.visible) {
                        serie.redraw();
                    }
                    /** @type {boolean} */
                    serie.isDirtyData = false;
                });
                if (pointer) {
                    pointer.reset(true);
                }
                renderer.draw();
                fireEvent(this, "redraw");
                fireEvent(this, "render");
                if (l) {
                    this.temporaryDisplay(true);
                }
                failureRecaps.forEach(function (realPrint) {
                    realPrint.call();
                });
            },
            get: function (name) {
                /**
                 * @param {!Object} item
                 * @return {?}
                 */
                function itemById(item) {
                    return item.id === name || item.options && item.options.id === name;
                }
                var series = this.series;
                var i;
                var ret = find(this.axes, itemById) || find(this.series, itemById);
                /** @type {number} */
                i = 0;
                for (; !ret && i < series.length; i++) {
                    ret = find(series[i].points || [], itemById);
                }
                return ret;
            },
            getAxes: function () {
                var $$ = this;
                var options = this.options;
                var g = options.xAxis = splat(options.xAxis || {});
                options = options.yAxis = splat(options.yAxis || {});
                fireEvent(this, "getAxes");
                g.forEach(function (axisOptions, i) {
                    /** @type {number} */
                    axisOptions.index = i;
                    /** @type {boolean} */
                    axisOptions.isX = true;
                });
                options.forEach(function (a, b) {
                    /** @type {number} */
                    a.index = b;
                });
                g.concat(options).forEach(function (axisArgs) {
                    new Axis($$, axisArgs);
                });
                fireEvent(this, "afterGetAxes");
            },
            getSelectedPoints: function () {
                /** @type {!Array} */
                var arr = [];
                this.series.forEach(function (params) {
                    arr = arr.concat((params[params.hasGroupedData ? "points" : "data"] || []).filter(function (series) {
                        return pick(series.selectedStaging, series.selected);
                    }));
                });
                return arr;
            },
            getSelectedSeries: function () {
                return this.series.filter(function (cbCollection) {
                    return cbCollection.selected;
                });
            },
            setTitle: function (s, h, redraw) {
                this.applyDescription("title", s);
                this.applyDescription("subtitle", h);
                this.applyDescription("caption", void 0);
                this.layOutTitles(redraw);
            },
            applyDescription: function (name, value) {
                var container = this;
                /** @type {({color: string, fontSize: string}|{color: string})} */
                var options = "title" === name ? {
                    color: "#333333",
                    fontSize: this.options.isStock ? "16px" : "18px"
                } : {
                    color: "#666666"
                };
                options = this.options[name] = merge(!this.styledMode && {
                    style: options
                }, this.options[name], value);
                var instance = this[name];
                if (instance && value) {
                    this[name] = instance = instance.destroy();
                }
                if (options && !instance) {
                    instance = this.renderer.text(options.text, 0, 0, options.useHTML).attr({
                        align: options.align,
                        "class": "highcharts-" + name,
                        zIndex: options.zIndex || 4
                    }).add();
                    /**
                     * @param {!Object} data
                     * @return {undefined}
                     */
                    instance.update = function (data) {
                        container[{
                            title: "setTitle",
                            subtitle: "setSubtitle",
                            caption: "setCaption"
                        }[name]](data);
                    };
                    if (!this.styledMode) {
                        instance.css(options.style);
                    }
                    this[name] = instance;
                }
            },
            layOutTitles: function (redraw) {
                /** @type {!Array} */
                var b = [0, 0, 0];
                var renderer = this.renderer;
                var spacingBox = this.spacingBox;
                ["title", "subtitle", "caption"].forEach(function (key) {
                    var title = this[key];
                    var titleOptions = this.options[key];
                    var location = titleOptions.verticalAlign || "top";
                    key = "title" === key ? -3 : "top" === location ? b[0] + 2 : 0;
                    if (title) {
                        if (!this.styledMode) {
                            var fontSize = titleOptions.style.fontSize;
                        }
                        fontSize = renderer.fontMetrics(fontSize, title).b;
                        title.css({
                            width: (titleOptions.width || spacingBox.width + (titleOptions.widthAdjust || 0)) + "px"
                        });
                        /** @type {number} */
                        var h = Math.round(title.getBBox(titleOptions.useHTML).height);
                        title.align(extend({
                            y: "bottom" === location ? fontSize : key + fontSize,
                            height: h
                        }, titleOptions), false, "spacingBox");
                        if (!titleOptions.floating) {
                            if ("top" === location) {
                                /** @type {number} */
                                b[0] = Math.ceil(b[0] + h);
                            } else {
                                if ("bottom" === location) {
                                    /** @type {number} */
                                    b[2] = Math.ceil(b[2] + h);
                                }
                            }
                        }
                    }
                }, this);
                if (b[0] && "top" === (this.options.title.verticalAlign || "top")) {
                    b[0] += this.options.title.margin;
                }
                if (b[2] && "bottom" === this.options.caption.verticalAlign) {
                    b[2] += this.options.caption.margin;
                }
                /** @type {boolean} */
                var requiresDirtyBox = !this.titleOffset || this.titleOffset.join(",") !== b.join(",");
                /** @type {!Array} */
                this.titleOffset = b;
                fireEvent(this, "afterLayOutTitles");
                if (!this.isDirtyBox && requiresDirtyBox) {
                    /** @type {boolean} */
                    this.isDirtyBox = this.isDirtyLegend = requiresDirtyBox;
                    if (this.hasRendered && pick(redraw, true) && this.isDirtyBox) {
                        this.redraw();
                    }
                }
            },
            getChartSize: function () {
                var v = this.options.chart;
                var w = v.width;
                v = v.height;
                var node = this.renderTo;
                if (!defined(w)) {
                    this.containerWidth = me.getStyle(node, "width");
                }
                if (!defined(v)) {
                    this.containerHeight = me.getStyle(node, "height");
                }
                /** @type {number} */
                this.chartWidth = Math.max(0, w || this.containerWidth || 600);
                /** @type {number} */
                this.chartHeight = Math.max(0, getStyle(v, this.chartWidth) || (1 < this.containerHeight ? this.containerHeight : 400));
            },
            temporaryDisplay: function (css) {
                var node = this.renderTo;
                if (css) {
                    for (; node && node.style;) {
                        if (node.hcOrigStyle) {
                            me.css(node, node.hcOrigStyle);
                            delete node.hcOrigStyle;
                        }
                        if (node.hcOrigDetached) {
                            doc.body.removeChild(node);
                            /** @type {boolean} */
                            node.hcOrigDetached = false;
                        }
                        node = node.parentNode;
                    }
                } else {
                    for (; node && node.style;) {
                        if (!(doc.body.contains(node) || node.parentNode)) {
                            /** @type {boolean} */
                            node.hcOrigDetached = true;
                            doc.body.appendChild(node);
                        }
                        if ("none" === me.getStyle(node, "display", false) || node.hcOricDetached) {
                            node.hcOrigStyle = {
                                display: node.style.display,
                                height: node.style.height,
                                overflow: node.style.overflow
                            };
                            css = {
                                display: "block",
                                overflow: "hidden"
                            };
                            if (node !== this.renderTo) {
                                /** @type {number} */
                                css.height = 0;
                            }
                            me.css(node, css);
                            if (!node.offsetWidth) {
                                node.style.setProperty("display", "block", "important");
                            }
                        }
                        node = node.parentNode;
                        if (node === doc.body) {
                            break;
                        }
                    }
                }
            },
            setClassName: function (new_value) {
                /** @type {string} */
                this.container.className = "highcharts-container " + (new_value || "");
            },
            getContainer: function () {
                var options = this.options;
                var optionsChart = options.chart;
                var el = this.renderTo;
                var CAPTURE_ID = me.uniqueKey();
                var data;
                var key;
                if (!el) {
                    this.renderTo = el = optionsChart.renderTo;
                }
                if (isString(el)) {
                    this.renderTo = el = doc.getElementById(el);
                }
                if (!el) {
                    me.error(13, true, this);
                }
                var oldChartIndex = pInt(attr(el, "data-highcharts-chart"));
                if (isNumber(oldChartIndex) && charts[oldChartIndex] && charts[oldChartIndex].hasRendered) {
                    charts[oldChartIndex].destroy();
                }
                attr(el, "data-highcharts-chart", this.index);
                /** @type {string} */
                el.innerHTML = "";
                if (!(optionsChart.skipClone || el.offsetWidth)) {
                    this.temporaryDisplay();
                }
                this.getChartSize();
                oldChartIndex = this.chartWidth;
                var _listItemHeight = this.chartHeight;
                css(el, {
                    overflow: "hidden"
                });
                if (!this.styledMode) {
                    data = extend({
                        position: "relative",
                        overflow: "hidden",
                        width: oldChartIndex + "px",
                        height: _listItemHeight + "px",
                        textAlign: "left",
                        lineHeight: "normal",
                        zIndex: 0,
                        "-webkit-tap-highlight-color": "rgba(0,0,0,0)"
                    }, optionsChart.style);
                }
                this.container = el = createElement("div", {
                    id: CAPTURE_ID
                }, data, el);
                this._cursor = el.style.cursor;
                this.renderer = new (me[optionsChart.renderer] || me.Renderer)(el, oldChartIndex, _listItemHeight, null, optionsChart.forExport, options.exporting && options.exporting.allowHTML, this.styledMode);
                this.setClassName(optionsChart.className);
                if (this.styledMode) {
                    for (key in options.defs) {
                        this.renderer.definition(options.defs[key]);
                    }
                } else {
                    this.renderer.setStyle(optionsChart.style);
                }
                this.renderer.chartIndex = this.index;
                fireEvent(this, "afterGetContainer");
            },
            getMargins: function (skipAxes) {
                var spacing = this.spacing;
                var margin = this.margin;
                var replace = this.titleOffset;
                this.resetMargins();
                if (replace[0] && !defined(margin[0])) {
                    /** @type {number} */
                    this.plotTop = Math.max(this.plotTop, replace[0] + spacing[0]);
                }
                if (replace[2] && !defined(margin[2])) {
                    /** @type {number} */
                    this.marginBottom = Math.max(this.marginBottom, replace[2] + spacing[2]);
                }
                if (this.legend && this.legend.display) {
                    this.legend.adjustMargins(margin, spacing);
                }
                fireEvent(this, "getMargins");
                if (!skipAxes) {
                    this.getAxisMargins();
                }
            },
            getAxisMargins: function () {
                var chart = this;
                /** @type {!Array} */
                var axisOffset = chart.axisOffset = [0, 0, 0, 0];
                var data = chart.colorAxis;
                var margin = chart.margin;
                /**
                 * @param {!Array} expr
                 * @return {undefined}
                 */
                var each = function (expr) {
                    expr.forEach(function (bl) {
                        if (bl.visible) {
                            bl.getOffset();
                        }
                    });
                };
                if (chart.hasCartesianSeries) {
                    each(chart.axes);
                } else {
                    if (data && data.length) {
                        each(data);
                    }
                }
                marginNames.forEach(function (m, side) {
                    if (!defined(margin[side])) {
                        chart[m] += axisOffset[side];
                    }
                });
                chart.setChartSize();
            },
            reflow: function (e) {
                var self = this;
                var options = self.options.chart;
                var node = self.renderTo;
                var opts = defined(options.width) && defined(options.height);
                var width = options.width || me.getStyle(node, "width");
                options = options.height || me.getStyle(node, "height");
                node = e ? e.target : win;
                if (!opts && !self.isPrinting && width && options && (node === win || node === doc)) {
                    if (width !== self.containerWidth || options !== self.containerHeight) {
                        me.clearTimeout(self.reflowTimeout);
                        self.reflowTimeout = syncTimeout(function () {
                            if (self.container) {
                                self.setSize(void 0, void 0, false);
                            }
                        }, e ? 100 : 0);
                    }
                    self.containerWidth = width;
                    self.containerHeight = options;
                }
            },
            setReflow: function (a) {
                var chart = this;
                if (false === a || this.unbindReflow) {
                    if (false === a && this.unbindReflow) {
                        this.unbindReflow = this.unbindReflow();
                    }
                } else {
                    this.unbindReflow = addEvent(win, "resize", function (e) {
                        if (chart.options) {
                            chart.reflow(e);
                        }
                    });
                    addEvent(this, "destroy", this.unbindReflow);
                }
            },
            setSize: function (value, options, type) {
                var chart = this;
                var renderer = chart.renderer;
                chart.isResizing += 1;
                callback(type, chart);
                chart.oldChartHeight = chart.chartHeight;
                chart.oldChartWidth = chart.chartWidth;
                if ("undefined" !== typeof value) {
                    /** @type {string} */
                    chart.options.chart.width = value;
                }
                if ("undefined" !== typeof options) {
                    /** @type {number} */
                    chart.options.chart.height = options;
                }
                chart.getChartSize();
                if (!chart.styledMode) {
                    var globalAnimation = renderer.globalAnimation;
                    (globalAnimation ? animate : css)(chart.container, {
                        width: chart.chartWidth + "px",
                        height: chart.chartHeight + "px"
                    }, globalAnimation);
                }
                chart.setChartSize(true);
                renderer.setSize(chart.chartWidth, chart.chartHeight, type);
                chart.axes.forEach(function (person) {
                    /** @type {boolean} */
                    person.isDirty = true;
                    person.setScale();
                });
                /** @type {boolean} */
                chart.isDirtyLegend = true;
                /** @type {boolean} */
                chart.isDirtyBox = true;
                chart.layOutTitles();
                chart.getMargins();
                chart.redraw(type);
                /** @type {null} */
                chart.oldChartHeight = null;
                fireEvent(chart, "resize");
                syncTimeout(function () {
                    if (chart) {
                        fireEvent(chart, "endResize", null, function () {
                            --chart.isResizing;
                        });
                    }
                }, animObject(globalAnimation).duration || 0);
            },
            setChartSize: function (skipAxes) {
                var e = this.inverted;
                var renderer = this.renderer;
                var w = this.chartWidth;
                var chartWidth = this.chartHeight;
                var chart = this.options.chart;
                var spacing = this.spacing;
                var cloneLengths = this.clipOffset;
                var border;
                var x;
                var block;
                var undefined;
                /** @type {number} */
                this.plotLeft = border = Math.round(this.plotLeft);
                /** @type {number} */
                this.plotTop = x = Math.round(this.plotTop);
                /** @type {number} */
                this.plotWidth = block = Math.max(0, Math.round(w - border - this.marginRight));
                /** @type {number} */
                this.plotHeight = undefined = Math.max(0, Math.round(chartWidth - x - this.marginBottom));
                /** @type {number} */
                this.plotSizeX = e ? undefined : block;
                /** @type {number} */
                this.plotSizeY = e ? block : undefined;
                this.plotBorderWidth = chart.plotBorderWidth || 0;
                this.spacingBox = renderer.spacingBox = {
                    x: spacing[3],
                    y: spacing[0],
                    width: w - spacing[3] - spacing[1],
                    height: chartWidth - spacing[0] - spacing[2]
                };
                this.plotBox = renderer.plotBox = {
                    x: border,
                    y: x,
                    width: block,
                    height: undefined
                };
                /** @type {number} */
                w = 2 * Math.floor(this.plotBorderWidth / 2);
                /** @type {number} */
                e = Math.ceil(Math.max(w, cloneLengths[3]) / 2);
                /** @type {number} */
                renderer = Math.ceil(Math.max(w, cloneLengths[0]) / 2);
                this.clipBox = {
                    x: e,
                    y: renderer,
                    width: Math.floor(this.plotSizeX - Math.max(w, cloneLengths[1]) / 2 - e),
                    height: Math.max(0, Math.floor(this.plotSizeY - Math.max(w, cloneLengths[2]) / 2 - renderer))
                };
                if (!skipAxes) {
                    this.axes.forEach(function (axis) {
                        axis.setAxisSize();
                        axis.setAxisTranslation();
                    });
                }
                fireEvent(this, "afterSetChartSize", {
                    skipAxes: skipAxes
                });
            },
            resetMargins: function () {
                fireEvent(this, "resetMargins");
                var chart = this;
                var chartOptions = chart.options.chart;
                ["margin", "spacing"].forEach(function (target) {
                    var value = chartOptions[target];
                    var values = isObject(value) ? value : [value, value, value, value];
                    ["Top", "Right", "Bottom", "Left"].forEach(function (sideName, side) {
                        chart[target][side] = pick(chartOptions[target + sideName], values[side]);
                    });
                });
                marginNames.forEach(function (m, side) {
                    chart[m] = pick(chart.margin[side], chart.spacing[side]);
                });
                /** @type {!Array} */
                chart.axisOffset = [0, 0, 0, 0];
                /** @type {!Array} */
                chart.clipOffset = [0, 0, 0, 0];
            },
            drawChartBox: function () {
                var optionsChart = this.options.chart;
                var renderer = this.renderer;
                var chartWidth = this.chartWidth;
                var chartHeight = this.chartHeight;
                var chartBackground = this.chartBackground;
                var self = this.plotBackground;
                var plotBorder = this.plotBorder;
                var h = this.styledMode;
                var node = this.plotBGImage;
                var bgAttr = optionsChart.backgroundColor;
                var plotBackgroundColor = optionsChart.plotBackgroundColor;
                var x = optionsChart.plotBackgroundImage;
                var mgn;
                var context = this.plotLeft;
                var plotTop = this.plotTop;
                var width = this.plotWidth;
                var plotHeight = this.plotHeight;
                var value = this.plotBox;
                var clipRect = this.clipRect;
                var clipBox = this.clipBox;
                /** @type {string} */
                var verb = "animate";
                if (!chartBackground) {
                    this.chartBackground = chartBackground = renderer.rect().addClass("highcharts-background").add();
                    /** @type {string} */
                    verb = "attr";
                }
                if (h) {
                    var chartBorderWidth = mgn = chartBackground.strokeWidth();
                } else {
                    chartBorderWidth = optionsChart.borderWidth || 0;
                    mgn = chartBorderWidth + (optionsChart.shadow ? 8 : 0);
                    bgAttr = {
                        fill: bgAttr || "none"
                    };
                    if (chartBorderWidth || chartBackground["stroke-width"]) {
                        bgAttr.stroke = optionsChart.borderColor;
                        bgAttr["stroke-width"] = chartBorderWidth;
                    }
                    chartBackground.attr(bgAttr).shadow(optionsChart.shadow);
                }
                chartBackground[verb]({
                    x: mgn / 2,
                    y: mgn / 2,
                    width: chartWidth - mgn - chartBorderWidth % 2,
                    height: chartHeight - mgn - chartBorderWidth % 2,
                    r: optionsChart.borderRadius
                });
                /** @type {string} */
                verb = "animate";
                if (!self) {
                    /** @type {string} */
                    verb = "attr";
                    this.plotBackground = self = renderer.rect().addClass("highcharts-plot-background").add();
                }
                self[verb](value);
                if (!h) {
                    self.attr({
                        fill: plotBackgroundColor || "none"
                    }).shadow(optionsChart.plotShadow);
                    if (x) {
                        if (node) {
                            if (x !== node.attr("href")) {
                                node.attr("href", x);
                            }
                            node.animate(value);
                        } else {
                            this.plotBGImage = renderer.image(x, context, plotTop, width, plotHeight).add();
                        }
                    }
                }
                if (clipRect) {
                    clipRect.animate({
                        width: clipBox.width,
                        height: clipBox.height
                    });
                } else {
                    this.clipRect = renderer.clipRect(clipBox);
                }
                /** @type {string} */
                verb = "animate";
                if (!plotBorder) {
                    /** @type {string} */
                    verb = "attr";
                    this.plotBorder = plotBorder = renderer.rect().addClass("highcharts-plot-border").attr({
                        zIndex: 1
                    }).add();
                }
                if (!h) {
                    plotBorder.attr({
                        stroke: optionsChart.plotBorderColor,
                        "stroke-width": optionsChart.plotBorderWidth || 0,
                        fill: "none"
                    });
                }
                plotBorder[verb](plotBorder.crisp({
                    x: context,
                    y: plotTop,
                    width: width,
                    height: plotHeight
                }, -plotBorder.strokeWidth()));
                /** @type {boolean} */
                this.isDirtyBox = false;
                fireEvent(this, "afterDrawChartBox");
            },
            propFromSeries: function () {
                var me = this;
                var optionsChart = me.options.chart;
                var klass;
                var seriesOptions = me.options.series;
                var i;
                var value;
                ["inverted", "angular", "polar"].forEach(function (key) {
                    klass = seriesTypes[optionsChart.type || optionsChart.defaultSeriesType];
                    value = optionsChart[key] || klass && klass.prototype[key];
                    i = seriesOptions && seriesOptions.length;
                    for (; !value && i--;) {
                        if ((klass = seriesTypes[seriesOptions[i].type]) && klass.prototype[key]) {
                            /** @type {boolean} */
                            value = true;
                        }
                    }
                    me[key] = value;
                });
            },
            linkSeries: function () {
                var plot = this;
                var series = plot.series;
                series.forEach(function (series) {
                    /** @type {number} */
                    series.linkedSeries.length = 0;
                });
                series.forEach(function (axis) {
                    var series = axis.options.linkedTo;
                    if (isString(series) && (series = ":previous" === series ? plot.series[axis.index - 1] : plot.get(series)) && series.linkedParent !== axis) {
                        series.linkedSeries.push(axis);
                        axis.linkedParent = series;
                        if (series.enabledDataSorting) {
                            axis.setDataSortingOptions();
                        }
                        axis.visible = pick(axis.options.visible, series.options.visible, axis.visible);
                    }
                });
                fireEvent(this, "afterLinkSeries");
            },
            renderSeries: function () {
                this.series.forEach(function (a) {
                    a.translate();
                    a.render();
                });
            },
            renderLabels: function () {
                var chart = this;
                var labels = chart.options.labels;
                if (labels.items) {
                    labels.items.forEach(function (msg) {
                        var style = extend(labels.style, msg.style);
                        var c = pInt(style.left) + chart.plotLeft;
                        var label = pInt(style.top) + chart.plotTop + 12;
                        delete style.left;
                        delete style.top;
                        chart.renderer.text(msg.html, c, label).attr({
                            zIndex: 2
                        }).css(style).add();
                    });
                }
            },
            render: function () {
                var a = this.axes;
                var buffer = this.colorAxis;
                var renderer = this.renderer;
                var options = this.options;
                /** @type {number} */
                var maxViewCount = 0;
                /**
                 * @param {!Array} d
                 * @return {undefined}
                 */
                var f = function (d) {
                    d.forEach(function (a) {
                        if (a.visible) {
                            a.render();
                        }
                    });
                };
                this.setTitle();
                this.legend = new Legend(this, options.legend);
                if (this.getStacks) {
                    this.getStacks();
                }
                this.getMargins(true);
                this.setChartSize();
                options = this.plotWidth;
                a.some(function (axis) {
                    if (axis.horiz && axis.visible && axis.options.labels.enabled && axis.series.length) {
                        return maxViewCount = 21, true;
                    }
                });
                /** @type {number} */
                var e = this.plotHeight = Math.max(this.plotHeight - maxViewCount, 0);
                a.forEach(function (size) {
                    size.setScale();
                });
                this.getAxisMargins();
                /** @type {boolean} */
                var redoHorizontal = 1.1 < options / this.plotWidth;
                /** @type {boolean} */
                var redoVertical = 1.05 < e / this.plotHeight;
                if (redoHorizontal || redoVertical) {
                    a.forEach(function (axis) {
                        if (axis.horiz && redoHorizontal || !axis.horiz && redoVertical) {
                            axis.setTickInterval(true);
                        }
                    });
                    this.getMargins();
                }
                this.drawChartBox();
                if (this.hasCartesianSeries) {
                    f(a);
                } else {
                    if (buffer && buffer.length) {
                        f(buffer);
                    }
                }
                if (!this.seriesGroup) {
                    this.seriesGroup = renderer.g("series-group").attr({
                        zIndex: 3
                    }).add();
                }
                this.renderSeries();
                this.renderLabels();
                this.addCredits();
                if (this.setResponsive) {
                    this.setResponsive();
                }
                this.updateContainerScaling();
                /** @type {boolean} */
                this.hasRendered = true;
            },
            addCredits: function (credits) {
                var chart = this;
                credits = merge(true, this.options.credits, credits);
                if (credits.enabled && !this.credits) {
                    this.credits = this.renderer.text(credits.text + (this.mapCredits || ""), 0, 0).addClass("highcharts-credits").on("click", function () {
                        if (credits.href) {
                            win.location.href = credits.href;
                        }
                    }).attr({
                        align: credits.position.align,
                        zIndex: 8
                    });
                    if (!chart.styledMode) {
                        this.credits.css(credits.style);
                    }
                    this.credits.add().align(credits.position);
                    /**
                     * @param {!Object} options
                     * @return {undefined}
                     */
                    this.credits.update = function (options) {
                        chart.credits = chart.credits.destroy();
                        chart.addCredits(options);
                    };
                }
            },
            updateContainerScaling: function () {
                var element = this.container;
                if (element.offsetWidth && element.offsetHeight && element.getBoundingClientRect) {
                    var originNodeRect = element.getBoundingClientRect();
                    /** @type {number} */
                    var scale = originNodeRect.width / element.offsetWidth;
                    /** @type {number} */
                    element = originNodeRect.height / element.offsetHeight;
                    if (1 !== scale || 1 !== element) {
                        this.containerScaling = {
                            scaleX: scale,
                            scaleY: element
                        };
                    } else {
                        delete this.containerScaling;
                    }
                }
            },
            destroy: function () {
                var chart = this;
                var axes = chart.axes;
                var series = chart.series;
                var container = chart.container;
                var i;
                var metabar = container && container.parentNode;
                fireEvent(chart, "destroy");
                if (chart.renderer.forExport) {
                    erase(charts, chart);
                } else {
                    charts[chart.index] = void 0;
                }
                me.chartCount--;
                chart.renderTo.removeAttribute("data-highcharts-chart");
                removeEvent(chart);
                i = axes.length;
                for (; i--;) {
                    axes[i] = axes[i].destroy();
                }
                if (this.scroller && this.scroller.destroy) {
                    this.scroller.destroy();
                }
                i = series.length;
                for (; i--;) {
                    series[i] = series[i].destroy();
                }
                "title subtitle chartBackground plotBackground plotBGImage plotBorder seriesGroup clipRect credits pointer rangeSelector legend resetZoomButton tooltip renderer".split(" ").forEach(function (key) {
                    var model = chart[key];
                    if (model && model.destroy) {
                        chart[key] = model.destroy();
                    }
                });
                if (container) {
                    /** @type {string} */
                    container.innerHTML = "";
                    removeEvent(container);
                    if (metabar) {
                        discardElement(container);
                    }
                }
                objectEach(chart, function (b, seriesType) {
                    delete chart[seriesType];
                });
            },
            firstRender: function () {
                var chart = this;
                var options = chart.options;
                if (!chart.isReadyToRender || chart.isReadyToRender()) {
                    chart.getContainer();
                    chart.resetMargins();
                    chart.setChartSize();
                    chart.propFromSeries();
                    chart.getAxes();
                    (isArray(options.series) ? options.series : []).forEach(function (serieOptions) {
                        chart.initSeries(serieOptions);
                    });
                    chart.linkSeries();
                    chart.setSeriesData();
                    fireEvent(chart, "beforeRender");
                    if (Pointer) {
                        chart.pointer = new Pointer(chart, options);
                    }
                    chart.render();
                    if (!chart.renderer.imgCount && chart.onload) {
                        chart.onload();
                    }
                    chart.temporaryDisplay(true);
                }
            },
            onload: function () {
                this.callbacks.concat([this.callback]).forEach(function (source) {
                    if (source && "undefined" !== typeof this.index) {
                        source.apply(this, [this]);
                    }
                }, this);
                fireEvent(this, "load");
                fireEvent(this, "render");
                if (defined(this.index)) {
                    this.setReflow(this.options.chart.reflow);
                }
                /** @type {null} */
                this.onload = null;
            }
        });
    });
    set(x1, "parts/ScrollablePlotArea.js", [x1["parts/Globals.js"], x1["parts/Utilities.js"]], function (window, _) {
        var pick = _.pick;
        var addEvent = window.addEvent;
        _ = window.Chart;
        "";
        addEvent(_, "afterSetChartSize", function (canCreateDiscussions) {
            var row = this.options.chart.scrollablePlotArea;
            var x = row && row.minWidth;
            row = row && row.minHeight;
            if (!this.renderer.forExport) {
                if (x) {
                    if (this.scrollablePixelsX = x = Math.max(0, x - this.chartWidth)) {
                        this.plotWidth += x;
                        if (this.inverted) {
                            this.clipBox.height += x;
                            this.plotBox.height += x;
                        } else {
                            this.clipBox.width += x;
                            this.plotBox.width += x;
                        }
                        var directions = {
                            1: {
                                name: "right",
                                value: x
                            }
                        };
                    }
                } else {
                    if (row && (this.scrollablePixelsY = x = Math.max(0, row - this.chartHeight))) {
                        this.plotHeight += x;
                        if (this.inverted) {
                            this.clipBox.width += x;
                            this.plotBox.width += x;
                        } else {
                            this.clipBox.height += x;
                            this.plotBox.height += x;
                        }
                        directions = {
                            2: {
                                name: "bottom",
                                value: x
                            }
                        };
                    }
                }
                if (directions && !canCreateDiscussions.skipAxes) {
                    this.axes.forEach(function (axis) {
                        if (directions[axis.side]) {
                            /**
                             * @return {?}
                             */
                            axis.getPlotLinePath = function () {
                                var name = directions[axis.side].name;
                                var i = this[name];
                                /** @type {number} */
                                this[name] = i - directions[axis.side].value;
                                var ret = window.Axis.prototype.getPlotLinePath.apply(this, arguments);
                                this[name] = i;
                                return ret;
                            };
                        } else {
                            axis.setAxisSize();
                            axis.setAxisTranslation();
                        }
                    });
                }
            }
        });
        addEvent(_, "render", function () {
            if (this.scrollablePixelsX || this.scrollablePixelsY) {
                if (this.setUpScrolling) {
                    this.setUpScrolling();
                }
                this.applyFixed();
            } else {
                if (this.fixedDiv) {
                    this.applyFixed();
                }
            }
        });
        /**
         * @return {undefined}
         */
        _.prototype.setUpScrolling = function () {
            var options = {
                WebkitOverflowScrolling: "touch",
                overflowX: "hidden",
                overflowY: "hidden"
            };
            if (this.scrollablePixelsX) {
                /** @type {string} */
                options.overflowX = "auto";
            }
            if (this.scrollablePixelsY) {
                /** @type {string} */
                options.overflowY = "auto";
            }
            this.scrollingContainer = window.createElement("div", {
                className: "highcharts-scrolling"
            }, options, this.renderTo);
            this.innerContainer = window.createElement("div", {
                className: "highcharts-inner-container"
            }, null, this.scrollingContainer);
            this.innerContainer.appendChild(this.container);
            /** @type {null} */
            this.setUpScrolling = null;
        };
        /**
         * @return {undefined}
         */
        _.prototype.moveFixedElements = function () {
            var el = this.container;
            var wrapper = this.fixedRenderer;
            /** @type {!Array<string>} */
            var g = ".highcharts-contextbutton .highcharts-credits .highcharts-legend .highcharts-legend-checkbox .highcharts-navigator-series .highcharts-navigator-xaxis .highcharts-navigator-yaxis .highcharts-navigator .highcharts-reset-zoom .highcharts-scrollbar .highcharts-subtitle .highcharts-title".split(" ");
            var id;
            if (this.scrollablePixelsX && !this.inverted) {
                /** @type {string} */
                id = ".highcharts-yaxis";
            } else {
                if (this.scrollablePixelsX && this.inverted) {
                    /** @type {string} */
                    id = ".highcharts-xaxis";
                } else {
                    if (this.scrollablePixelsY && !this.inverted) {
                        /** @type {string} */
                        id = ".highcharts-xaxis";
                    } else {
                        if (this.scrollablePixelsY && this.inverted) {
                            /** @type {string} */
                            id = ".highcharts-yaxis";
                        }
                    }
                }
            }
            g.push(id, id + "-labels");
            g.forEach(function (selector) {
                [].forEach.call(el.querySelectorAll(selector), function (element) {
                    (element.namespaceURI === wrapper.SVG_NS ? wrapper.box : wrapper.box.parentNode).appendChild(element);
                    /** @type {string} */
                    element.style.pointerEvents = "auto";
                });
            });
        };
        /**
         * @return {undefined}
         */
        _.prototype.applyFixed = function () {
            var slidesWidth;
            /** @type {boolean} */
            var denom1High = !this.fixedDiv;
            var params = this.options.chart.scrollablePlotArea;
            if (denom1High) {
                this.fixedDiv = window.createElement("div", {
                    className: "highcharts-fixed"
                }, {
                    position: "absolute",
                    overflow: "hidden",
                    pointerEvents: "none",
                    zIndex: 2
                }, null, true);
                this.renderTo.insertBefore(this.fixedDiv, this.renderTo.firstChild);
                /** @type {string} */
                this.renderTo.style.overflow = "visible";
                this.fixedRenderer = slidesWidth = new window.Renderer(this.fixedDiv, this.chartWidth, this.chartHeight);
                this.scrollableMask = slidesWidth.path().attr({
                    fill: this.options.chart.backgroundColor || "#fff",
                    "fill-opacity": pick(params.opacity, .85),
                    zIndex: -1
                }).addClass("highcharts-scrollable-mask").add();
                this.moveFixedElements();
                addEvent(this, "afterShowResetZoom", this.moveFixedElements);
                addEvent(this, "afterLayOutTitles", this.moveFixedElements);
            } else {
                this.fixedRenderer.setSize(this.chartWidth, this.chartHeight);
            }
            slidesWidth = this.chartWidth + (this.scrollablePixelsX || 0);
            var quickfixBoxHeight = this.chartHeight + (this.scrollablePixelsY || 0);
            window.stop(this.container);
            /** @type {string} */
            this.container.style.width = slidesWidth + "px";
            /** @type {string} */
            this.container.style.height = quickfixBoxHeight + "px";
            this.renderer.boxWrapper.attr({
                width: slidesWidth,
                height: quickfixBoxHeight,
                viewBox: [0, 0, slidesWidth, quickfixBoxHeight].join(" ")
            });
            this.chartBackground.attr({
                width: slidesWidth,
                height: quickfixBoxHeight
            });
            if (this.scrollablePixelsY) {
                /** @type {string} */
                this.scrollingContainer.style.height = this.chartHeight + "px";
            }
            if (denom1High) {
                if (params.scrollPositionX) {
                    /** @type {number} */
                    this.scrollingContainer.scrollLeft = this.scrollablePixelsX * params.scrollPositionX;
                }
                if (params.scrollPositionY) {
                    /** @type {number} */
                    this.scrollingContainer.scrollTop = this.scrollablePixelsY * params.scrollPositionY;
                }
            }
            quickfixBoxHeight = this.axisOffset;
            /** @type {number} */
            denom1High = this.plotTop - quickfixBoxHeight[0] - 1;
            /** @type {number} */
            params = this.plotLeft - quickfixBoxHeight[3] - 1;
            slidesWidth = this.plotTop + this.plotHeight + quickfixBoxHeight[2] + 1;
            quickfixBoxHeight = this.plotLeft + this.plotWidth + quickfixBoxHeight[1] + 1;
            /** @type {number} */
            var C = this.plotLeft + this.plotWidth - (this.scrollablePixelsX || 0);
            /** @type {number} */
            var B = this.plotTop + this.plotHeight - (this.scrollablePixelsY || 0);
            /** @type {!Array} */
            denom1High = this.scrollablePixelsX ? ["M", 0, denom1High, "L", this.plotLeft - 1, denom1High, "L", this.plotLeft - 1, slidesWidth, "L", 0, slidesWidth, "Z", "M", C, denom1High, "L", this.chartWidth, denom1High, "L", this.chartWidth, slidesWidth, "L", C, slidesWidth, "Z"] : this.scrollablePixelsY ? ["M", params, 0, "L", params, this.plotTop - 1, "L", quickfixBoxHeight, this.plotTop - 1, "L", quickfixBoxHeight, 0, "Z", "M", params, B, "L", params, this.chartHeight, "L", quickfixBoxHeight, this.chartHeight,
                "L", quickfixBoxHeight, B, "Z"] : ["M", 0, 0];
            if ("adjustHeight" !== this.redrawTrigger) {
                this.scrollableMask.attr({
                    d: denom1High
                });
            }
        };
    });
    set(x1, "parts/Point.js", [x1["parts/Globals.js"], x1["parts/Utilities.js"]], function (Highcharts, H) {
        var animObject = H.animObject;
        var defined = H.defined;
        var erase = H.erase;
        var extend = H.extend;
        var isArray = H.isArray;
        var isNumber = H.isNumber;
        var isObject = H.isObject;
        var trigger = H.syncTimeout;
        var pick = H.pick;
        var Point;
        var fireEvent = Highcharts.fireEvent;
        var format = Highcharts.format;
        var objectEach = Highcharts.uniqueKey;
        var removeEvent = Highcharts.removeEvent;
        /** @type {function(): undefined} */
        Highcharts.Point = Point = function () {
        };
        Highcharts.Point.prototype = {
            init: function (series, options, a) {
                /** @type {!Object} */
                this.series = series;
                this.applyOptions(options, a);
                this.id = defined(this.id) ? this.id : objectEach();
                this.resolveColor();
                series.chart.pointCount++;
                fireEvent(this, "afterInit");
                return this;
            },
            resolveColor: function () {
                var series = this.series;
                var colorCount = series.chart.options.chart.colorCount;
                var colorIndex = series.chart.styledMode;
                if (!(colorIndex || this.options.color)) {
                    this.color = series.color;
                }
                if (series.options.colorByPoint) {
                    if (!colorIndex) {
                        colorCount = series.options.colors || series.chart.options.colors;
                        this.color = this.color || colorCount[series.colorCounter];
                        colorCount = colorCount.length;
                    }
                    colorIndex = series.colorCounter;
                    series.colorCounter++;
                    if (series.colorCounter === colorCount) {
                        /** @type {number} */
                        series.colorCounter = 0;
                    }
                } else {
                    colorIndex = series.colorIndex;
                }
                this.colorIndex = pick(this.colorIndex, colorIndex);
            },
            applyOptions: function (options, x) {
                var series = this.series;
                var indexLookupKey = series.options.pointValKey || series.pointValKey;
                options = Point.prototype.optionsToObject.call(this, options);
                extend(this, options);
                this.options = this.options ? extend(this.options, options) : options;
                if (options.group) {
                    delete this.group;
                }
                if (options.dataLabels) {
                    delete this.dataLabels;
                }
                if (indexLookupKey) {
                    this.y = this[indexLookupKey];
                }
                /** @type {string} */
                this.formatPrefix = (this.isNull = pick(this.isValid && !this.isValid(), null === this.x || !isNumber(this.y))) ? "null" : "point";
                if (this.selected) {
                    /** @type {string} */
                    this.state = "select";
                }
                if ("name" in this && "undefined" === typeof x && series.xAxis && series.xAxis.hasNames) {
                    this.x = series.xAxis.nameToX(this);
                }
                if ("undefined" === typeof this.x && series) {
                    this.x = "undefined" === typeof x ? series.autoIncrement(this) : x;
                }
                return this;
            },
            setNestedProperty: function (object, property, value) {
                value.split(".").reduce(function (value, prop, string, inRevIdx) {
                    value[prop] = inRevIdx.length - 1 === string ? property : isObject(value[prop], true) ? value[prop] : {};
                    return value[prop];
                }, object);
                return object;
            },
            optionsToObject: function (data) {
                var item = {};
                var series = this.series;
                var keys = series.options.keys;
                var value = keys || series.pointArrayMap || ["y"];
                var missing = value.length;
                /** @type {number} */
                var variable = 0;
                /** @type {number} */
                var j = 0;
                if (isNumber(data) || null === data) {
                    /** @type {!Object} */
                    item[value[0]] = data;
                } else {
                    if (isArray(data)) {
                        if (!keys && data.length > missing) {
                            /** @type {string} */
                            series = typeof data[0];
                            if ("string" === series) {
                                item.name = data[0];
                            } else {
                                if ("number" === series) {
                                    item.x = data[0];
                                }
                            }
                            variable++;
                        }
                        for (; j < missing;) {
                            if (!(keys && "undefined" === typeof data[variable])) {
                                if (0 < value[j].indexOf(".")) {
                                    Highcharts.Point.prototype.setNestedProperty(item, data[variable], value[j]);
                                } else {
                                    item[value[j]] = data[variable];
                                }
                            }
                            variable++;
                            j++;
                        }
                    } else {
                        if ("object" === typeof data) {
                            /** @type {!Object} */
                            item = data;
                            if (data.dataLabels) {
                                /** @type {boolean} */
                                series._hasPointLabels = true;
                            }
                            if (data.marker) {
                                /** @type {boolean} */
                                series._hasPointMarkers = true;
                            }
                        }
                    }
                }
                return item;
            },
            getClassName: function () {
                return "highcharts-point" + (this.selected ? " highcharts-point-select" : "") + (this.negative ? " highcharts-negative" : "") + (this.isNull ? " highcharts-null-point" : "") + ("undefined" !== typeof this.colorIndex ? " highcharts-color-" + this.colorIndex : "") + (this.options.className ? " " + this.options.className : "") + (this.zone && this.zone.className ? " " + this.zone.className.replace("highcharts-negative", "") : "");
            },
            getZone: function () {
                var series = this.series;
                var zones = series.zones;
                series = series.zoneAxis || "y";
                /** @type {number} */
                var i = 0;
                var zone;
                zone = zones[i];
                for (; this[series] >= zone.value;) {
                    zone = zones[++i];
                }
                if (!this.nonZonedColor) {
                    this.nonZonedColor = this.color;
                }
                this.color = zone && zone.color && !this.options.color ? zone.color : this.nonZonedColor;
                return zone;
            },
            hasNewShapeType: function () {
                return (this.graphic && (this.graphic.symbolName || this.graphic.element.nodeName)) !== this.shapeType;
            },
            destroy: function () {
                /**
                 * @return {undefined}
                 */
                function update() {
                    if (hoverPoints) {
                        point.setState();
                        erase(hoverPoints, point);
                        if (!hoverPoints.length) {
                            /** @type {null} */
                            chart.hoverPoints = null;
                        }
                    }
                    if (point === chart.hoverPoint) {
                        point.onMouseOut();
                    }
                    if (point.graphic || point.dataLabel || point.dataLabels) {
                        removeEvent(point);
                        point.destroyElements();
                    }
                    for (prop in point) {
                        /** @type {null} */
                        point[prop] = null;
                    }
                }
                var point = this;
                var series = point.series;
                var chart = series.chart;
                series = series.options.dataSorting;
                var hoverPoints = chart.hoverPoints;
                var k = animObject(point.series.chart.renderer.globalAnimation);
                var prop;
                if (series && series.enabled) {
                    this.animateBeforeDestroy();
                    trigger(update, k.duration);
                } else {
                    update();
                }
                chart.pointCount--;
                if (point.legendItem) {
                    chart.legend.destroyItem(point);
                }
            },
            animateBeforeDestroy: function () {
                var q = this;
                var from = {
                    x: q.startXPos,
                    opacity: 0
                };
                var isVertical;
                var translation = q.getGraphicalProps();
                translation.singular.forEach(function (i) {
                    /** @type {boolean} */
                    isVertical = "dataLabel" === i;
                    q[i] = q[i].animate(isVertical ? {
                        x: q[i].startXPos,
                        y: q[i].startYPos,
                        opacity: 0
                    } : from);
                });
                translation.plural.forEach(function (verb) {
                    q[verb].forEach(function (target) {
                        if (target.element) {
                            target.animate(extend({
                                x: q.startXPos
                            }, target.startYPos ? {
                                x: target.startXPos,
                                y: target.startYPos
                            } : {}));
                        }
                    });
                });
            },
            destroyElements: function (rules) {
                var b = this;
                rules = b.getGraphicalProps(rules);
                rules.singular.forEach(function (as) {
                    b[as] = b[as].destroy();
                });
                rules.plural.forEach(function (paramName) {
                    b[paramName].forEach(function (a) {
                        if (a.element) {
                            a.destroy();
                        }
                    });
                    delete b[paramName];
                });
            },
            getGraphicalProps: function (data) {
                var prev = this;
                /** @type {!Array} */
                var result = [];
                var length;
                var model = {
                    singular: [],
                    plural: []
                };
                data = data || {
                    graphic: 1,
                    dataLabel: 1
                };
                if (data.graphic) {
                    result.push("graphic", "shadowGroup");
                }
                if (data.dataLabel) {
                    result.push("dataLabel", "dataLabelUpper", "connector");
                }
                /** @type {number} */
                length = result.length;
                for (; length--;) {
                    var key = result[length];
                    if (prev[key]) {
                        model.singular.push(key);
                    }
                }
                ["dataLabel", "connector"].forEach(function (i) {
                    /** @type {string} */
                    var key = i + "s";
                    if (data[i] && prev[key]) {
                        model.plural.push(key);
                    }
                });
                return model;
            },
            getLabelConfig: function () {
                return {
                    x: this.category,
                    y: this.y,
                    color: this.color,
                    colorIndex: this.colorIndex,
                    key: this.name || this.category,
                    series: this.series,
                    point: this,
                    percentage: this.percentage,
                    total: this.total || this.stackTotal
                };
            },
            tooltipFormatter: function (args) {
                var series = this.series;
                var seriesTooltipOptions = series.tooltipOptions;
                var valueDecimals = pick(seriesTooltipOptions.valueDecimals, "");
                var type = seriesTooltipOptions.valuePrefix || "";
                var i = seriesTooltipOptions.valueSuffix || "";
                if (series.chart.styledMode) {
                    args = series.chart.tooltip.styledModeFormat(args);
                }
                (series.pointArrayMap || ["y"]).forEach(function (key) {
                    /** @type {string} */
                    key = "{point." + key;
                    if (type || i) {
                        args = args.replace(RegExp(key + "}", "g"), type + key + "}" + i);
                    }
                    args = args.replace(RegExp(key + "}", "g"), key + ":,." + valueDecimals + "f}");
                });
                return format(args, {
                    point: this,
                    series: this.series
                }, series.chart);
            },
            firePointEvent: function (name, eventArgs, defaultFunction) {
                var options = this;
                var seriesOptions = this.series.options;
                if (seriesOptions.point.events[name] || options.options && options.options.events && options.options.events[name]) {
                    this.importEvents();
                }
                if ("click" === name && seriesOptions.allowPointSelect) {
                    /**
                     * @param {!Event} event
                     * @return {undefined}
                     */
                    defaultFunction = function (event) {
                        if (options.select) {
                            options.select(null, event.ctrlKey || event.metaKey || event.shiftKey);
                        }
                    };
                }
                fireEvent(this, name, eventArgs, defaultFunction);
            },
            visible: true
        };
    });
    set(x1, "parts/Series.js", [x1["parts/Globals.js"], x1["parts/Utilities.js"]], function (Highcharts, H) {
        var animObject = H.animObject;
        var arrayMax = H.arrayMax;
        var arrayMin = H.arrayMin;
        var parseFloat = H.clamp;
        var correctFloat = H.correctFloat;
        var defined = H.defined;
        var erase = H.erase;
        var extend = H.extend;
        var isArray = H.isArray;
        var isNumber = H.isNumber;
        var isString = H.isString;
        var objectEach = H.objectEach;
        var pick = H.pick;
        var splat = H.splat;
        var syncTimeout = H.syncTimeout;
        var addEvent = Highcharts.addEvent;
        var defaultOptions = Highcharts.defaultOptions;
        var defaultPlotOptions = Highcharts.defaultPlotOptions;
        var fireEvent = Highcharts.fireEvent;
        var merge = Highcharts.merge;
        var each = Highcharts.removeEvent;
        var SVGElement = Highcharts.SVGElement;
        var win = Highcharts.win;
        Highcharts.Series = Highcharts.seriesType("line", null, {
            lineWidth: 2,
            allowPointSelect: false,
            showCheckbox: false,
            animation: {
                duration: 1E3
            },
            events: {},
            marker: {
                enabledThreshold: 2,
                lineColor: "#ffffff",
                lineWidth: 0,
                radius: 4,
                states: {
                    normal: {
                        animation: true
                    },
                    hover: {
                        animation: {
                            duration: 50
                        },
                        enabled: true,
                        radiusPlus: 2,
                        lineWidthPlus: 1
                    },
                    select: {
                        fillColor: "#cccccc",
                        lineColor: "#000000",
                        lineWidth: 2
                    }
                }
            },
            point: {
                events: {}
            },
            dataLabels: {
                align: "center",
                formatter: function () {
                    var isNumber = this.series.chart.numberFormatter;
                    return null === this.y ? "" : isNumber(this.y, -1);
                },
                padding: 5,
                style: {
                    fontSize: "11px",
                    fontWeight: "bold",
                    color: "contrast",
                    textOutline: "1px contrast"
                },
                verticalAlign: "bottom",
                x: 0,
                y: 0
            },
            cropThreshold: 300,
            opacity: 1,
            pointRange: 0,
            softThreshold: true,
            states: {
                normal: {
                    animation: true
                },
                hover: {
                    animation: {
                        duration: 50
                    },
                    lineWidthPlus: 1,
                    marker: {},
                    halo: {
                        size: 10,
                        opacity: .25
                    }
                },
                select: {
                    animation: {
                        duration: 0
                    }
                },
                inactive: {
                    animation: {
                        duration: 50
                    },
                    opacity: .2
                }
            },
            stickyTracking: true,
            turboThreshold: 1E3,
            findNearestPointBy: "x"
        }, {
            axisTypes: ["xAxis", "yAxis"],
            coll: "series",
            colorCounter: 0,
            cropShoulder: 1,
            directTouch: false,
            eventsToUnbind: [],
            isCartesian: true,
            parallelArrays: ["x", "y"],
            pointClass: Highcharts.Point,
            requireSorting: true,
            sorted: true,
            init: function (chart, options) {
                fireEvent(this, "init", {
                    options: options
                });
                var series = this;
                var chartSeries = chart.series;
                var lastSeries;
                this.eventOptions = this.eventOptions || {};
                /** @type {!Object} */
                series.chart = chart;
                series.options = options = series.setOptions(options);
                /** @type {!Array} */
                series.linkedSeries = [];
                series.bindAxes();
                extend(series, {
                    name: options.name,
                    state: "",
                    visible: false !== options.visible,
                    selected: true === options.selected
                });
                var events = options.events;
                objectEach(events, function (value, i) {
                    if (Highcharts.isFunction(value) && series.eventOptions[i] !== value) {
                        if (Highcharts.isFunction(series.eventOptions[i])) {
                            each(series, i, series.eventOptions[i]);
                        }
                        /** @type {!Function} */
                        series.eventOptions[i] = value;
                        addEvent(series, i, value);
                    }
                });
                if (events && events.click || options.point && options.point.events && options.point.events.click || options.allowPointSelect) {
                    /** @type {boolean} */
                    chart.runTrackerClick = true;
                }
                series.getColor();
                series.getSymbol();
                series.parallelArrays.forEach(function (key) {
                    if (!series[key + "Data"]) {
                        /** @type {!Array} */
                        series[key + "Data"] = [];
                    }
                });
                if (series.isCartesian) {
                    /** @type {boolean} */
                    chart.hasCartesianSeries = true;
                }
                if (chartSeries.length) {
                    lastSeries = chartSeries[chartSeries.length - 1];
                }
                series._i = pick(lastSeries && lastSeries._i, -1) + 1;
                chart.orderSeries(this.insert(chartSeries));
                if (options.dataSorting && options.dataSorting.enabled) {
                    series.setDataSortingOptions();
                } else {
                    if (!(series.points || series.data)) {
                        series.setData(options.data, false);
                    }
                }
                fireEvent(this, "afterInit");
            },
            insert: function (collection) {
                var b = this.options.index;
                var i;
                if (isNumber(b)) {
                    i = collection.length;
                    for (; i--;) {
                        if (b >= pick(collection[i].options.index, collection[i]._i)) {
                            collection.splice(i + 1, 0, this);
                            break;
                        }
                    }
                    if (-1 === i) {
                        collection.unshift(this);
                    }
                    i = i + 1;
                } else {
                    collection.push(this);
                }
                return pick(i, collection.length - 1);
            },
            bindAxes: function () {
                var series = this;
                var seriesOptions = series.options;
                var options = series.chart;
                var axisOptions;
                fireEvent(this, "bindAxes", null, function () {
                    (series.axisTypes || []).forEach(function (i) {
                        options[i].forEach(function (axis) {
                            axisOptions = axis.options;
                            if (seriesOptions[i] === axisOptions.index || "undefined" !== typeof seriesOptions[i] && seriesOptions[i] === axisOptions.id || "undefined" === typeof seriesOptions[i] && 0 === axisOptions.index) {
                                series.insert(axis.series);
                                /** @type {!Object} */
                                series[i] = axis;
                                /** @type {boolean} */
                                axis.isDirty = true;
                            }
                        });
                        if (!(series[i] || series.optionalAxis === i)) {
                            Highcharts.error(18, true, options);
                        }
                    });
                });
            },
            updateParallelArrays: function (point, i) {
                var series = point.series;
                /** @type {!Arguments} */
                var outerArguments = arguments;
                /** @type {function(string): undefined} */
                var forceDetachLink = isNumber(i) ? function (key) {
                    var objectiveF = "y" === key && series.toYData ? series.toYData(point) : point[key];
                    series[key + "Data"][i] = objectiveF;
                } : function (key) {
                    Array.prototype[i].apply(series[key + "Data"], Array.prototype.slice.call(outerArguments, 2));
                };
                series.parallelArrays.forEach(forceDetachLink);
            },
            hasData: function () {
                return this.visible && "undefined" !== typeof this.dataMax && "undefined" !== typeof this.dataMin || this.visible && this.yData && 0 < this.yData.length;
            },
            autoIncrement: function () {
                var options = this.options;
                var xIncrement = this.xIncrement;
                var pointInterval;
                var value = options.pointIntervalUnit;
                var res = this.chart.time;
                xIncrement = pick(xIncrement, options.pointStart, 0);
                this.pointInterval = pointInterval = pick(this.pointInterval, options.pointInterval, 1);
                if (value) {
                    options = new res.Date(xIncrement);
                    if ("day" === value) {
                        res.set("Date", options, res.get("Date", options) + pointInterval);
                    } else {
                        if ("month" === value) {
                            res.set("Month", options, res.get("Month", options) + pointInterval);
                        } else {
                            if ("year" === value) {
                                res.set("FullYear", options, res.get("FullYear", options) + pointInterval);
                            }
                        }
                    }
                    /** @type {number} */
                    pointInterval = options.getTime() - xIncrement;
                }
                this.xIncrement = xIncrement + pointInterval;
                return xIncrement;
            },
            setDataSortingOptions: function () {
                var options = this.options;
                extend(this, {
                    requireSorting: false,
                    sorted: false,
                    enabledDataSorting: true,
                    allowDG: false
                });
                if (!defined(options.pointRange)) {
                    /** @type {number} */
                    options.pointRange = 1;
                }
            },
            setOptions: function (params) {
                var instance = this.chart;
                var config = instance.options;
                var data = config.plotOptions;
                var options = instance.userOptions || {};
                params = merge(params);
                instance = instance.styledMode;
                var self = {
                    plotOptions: data,
                    userOptions: params
                };
                fireEvent(this, "setOptions", self);
                var typeOptions = self.plotOptions[this.type];
                var userPlotOptions = options.plotOptions || {};
                this.userOptions = self.userOptions;
                options = merge(typeOptions, data.series, options.plotOptions && options.plotOptions[this.type], params);
                this.tooltipOptions = merge(defaultOptions.tooltip, defaultOptions.plotOptions.series && defaultOptions.plotOptions.series.tooltip, defaultOptions.plotOptions[this.type].tooltip, config.tooltip.userOptions, data.series && data.series.tooltip, data[this.type].tooltip, params.tooltip);
                this.stickyTracking = pick(params.stickyTracking, userPlotOptions[this.type] && userPlotOptions[this.type].stickyTracking, userPlotOptions.series && userPlotOptions.series.stickyTracking, this.tooltipOptions.shared && !this.noSharedTooltip ? true : options.stickyTracking);
                if (null === typeOptions.marker) {
                    delete options.marker;
                }
                this.zoneAxis = options.zoneAxis;
                config = this.zones = (options.zones || []).slice();
                if (!(!options.negativeColor && !options.negativeFillColor || options.zones)) {
                    data = {
                        value: options[this.zoneAxis + "Threshold"] || options.threshold || 0,
                        className: "highcharts-negative"
                    };
                    if (!instance) {
                        data.color = options.negativeColor;
                        data.fillColor = options.negativeFillColor;
                    }
                    config.push(data);
                }
                if (config.length && defined(config[config.length - 1].value)) {
                    config.push(instance ? {} : {
                        color: this.color,
                        fillColor: this.fillColor
                    });
                }
                fireEvent(this, "afterSetOptions", {
                    options: options
                });
                return options;
            },
            getName: function () {
                return pick(this.options.name, "Series " + (this.index + 1));
            },
            getCyclic: function (prop, value, defaults) {
                var chart = this.chart;
                var userOptions = this.userOptions;
                /** @type {string} */
                var indexName = prop + "Index";
                /** @type {string} */
                var counterName = prop + "Counter";
                var len = defaults ? defaults.length : pick(chart.options.chart[prop + "Count"], chart[prop + "Count"]);
                if (!value) {
                    var i = pick(userOptions[indexName], userOptions["_" + indexName]);
                    if (!defined(i)) {
                        if (!chart.series.length) {
                            /** @type {number} */
                            chart[counterName] = 0;
                        }
                        /** @type {number} */
                        userOptions["_" + indexName] = i = chart[counterName] % len;
                        chart[counterName] += 1;
                    }
                    if (defaults) {
                        value = defaults[i];
                    }
                }
                if ("undefined" !== typeof i) {
                    this[indexName] = i;
                }
                this[prop] = value;
            },
            getColor: function () {
                if (this.chart.styledMode) {
                    this.getCyclic("color");
                } else {
                    if (this.options.colorByPoint) {
                        /** @type {null} */
                        this.options.color = null;
                    } else {
                        this.getCyclic("color", this.options.color || defaultPlotOptions[this.type].color, this.chart.options.colors);
                    }
                }
            },
            getSymbol: function () {
                this.getCyclic("symbol", this.options.marker.symbol, this.chart.options.symbols);
            },
            findPointIndex: function (params, end) {
                var dir = params.id;
                var file = params.x;
                var points = this.points;
                var wakeUp;
                var name = this.options.dataSorting;
                if (dir) {
                    var data = this.chart.get(dir);
                } else {
                    if (this.linkedParent || this.enabledDataSorting) {
                        /** @type {string} */
                        var key = name && name.matchByName ? "name" : "index";
                        data = Highcharts.find(points, function (d) {
                            return !d.touched && d[key] === params[key];
                        });
                        if (!data) {
                            return;
                        }
                    }
                }
                if (data) {
                    var id = data && data.index;
                    if ("undefined" !== typeof id) {
                        /** @type {boolean} */
                        wakeUp = true;
                    }
                }
                if ("undefined" === typeof id && isNumber(file)) {
                    id = this.xData.indexOf(file, end);
                }
                if (-1 !== id && "undefined" !== typeof id && this.cropped) {
                    id = id >= this.cropStart ? id - this.cropStart : id;
                }
                if (!wakeUp && points[id] && points[id].touched) {
                    id = void 0;
                }
                return id;
            },
            drawLegendSymbol: Highcharts.LegendSymbolMixin.drawLineMarker,
            updateData: function (d, item) {
                var options = this.options;
                var stackLabelOptions = options.dataSorting;
                var data = this.points;
                /** @type {!Array} */
                var f = [];
                var e;
                var p;
                var key;
                var skipKeyedNodes = this.requireSorting;
                /** @type {boolean} */
                var ignoreLast = d.length === data.length;
                /** @type {boolean} */
                var m = true;
                /** @type {null} */
                this.xIncrement = null;
                d.forEach(function (value, i) {
                    var record = defined(value) && this.pointClass.prototype.optionsToObject.call({
                        series: this
                    }, value) || {};
                    var id = record.x;
                    if (record.id || isNumber(id)) {
                        if (id = this.findPointIndex(record, key), -1 === id || "undefined" === typeof id ? f.push(value) : data[id] && value !== options.data[id] ? (data[id].update(value, false, null, false), data[id].touched = true, skipKeyedNodes && (key = id + 1)) : data[id] && (data[id].touched = true), !ignoreLast || i !== id || stackLabelOptions && stackLabelOptions.enabled || this.hasDerivedData) {
                            /** @type {boolean} */
                            e = true;
                        }
                    } else {
                        f.push(value);
                    }
                }, this);
                if (e) {
                    d = data.length;
                    for (; d--;) {
                        if ((p = data[d]) && !p.touched && p.remove) {
                            p.remove(false, item);
                        }
                    }
                } else {
                    if (!ignoreLast || stackLabelOptions && stackLabelOptions.enabled) {
                        /** @type {boolean} */
                        m = false;
                    } else {
                        d.forEach(function (y, k) {
                            if (data[k].update && y !== data[k].y) {
                                data[k].update(y, false, null, false);
                            }
                        });
                        /** @type {number} */
                        f.length = 0;
                    }
                }
                data.forEach(function (event) {
                    if (event) {
                        /** @type {boolean} */
                        event.touched = false;
                    }
                });
                if (!m) {
                    return false;
                }
                f.forEach(function (x1) {
                    this.addPoint(x1, false, null, null, false);
                }, this);
                if (null === this.xIncrement && this.xData && this.xData.length) {
                    this.xIncrement = arrayMax(this.xData);
                    this.autoIncrement();
                }
                return true;
            },
            setData: function (data, record, i, pt) {
                var series = this;
                var oldData = series.points;
                var index = oldData && oldData.length || 0;
                var value;
                var options = series.options;
                var chart = series.chart;
                var stackLabelOptions = options.dataSorting;
                /** @type {null} */
                var max = null;
                var xAxis = series.xAxis;
                max = options.turboThreshold;
                var xData = this.xData;
                var yData = this.yData;
                var valueCount = (value = series.pointArrayMap) && value.length;
                var init = options.keys;
                /** @type {number} */
                var min = 0;
                /** @type {number} */
                var start = 1;
                var dataExists;
                data = data || [];
                value = data.length;
                record = pick(record, true);
                if (stackLabelOptions && stackLabelOptions.enabled) {
                    data = this.sortData(data);
                }
                if (false !== pt && value && index && !series.cropped && !series.hasGroupedData && series.visible && !series.isSeriesBoosting) {
                    dataExists = this.updateData(data, i);
                }
                if (!dataExists) {
                    /** @type {null} */
                    series.xIncrement = null;
                    /** @type {number} */
                    series.colorCounter = 0;
                    this.parallelArrays.forEach(function (key) {
                        /** @type {number} */
                        series[key + "Data"].length = 0;
                    });
                    if (max && value > max) {
                        if (max = series.getFirstValidPoint(data), isNumber(max)) {
                            /** @type {number} */
                            i = 0;
                            for (; i < value; i++) {
                                xData[i] = this.autoIncrement();
                                yData[i] = data[i];
                            }
                        } else {
                            if (isArray(max)) {
                                if (valueCount) {
                                    /** @type {number} */
                                    i = 0;
                                    for (; i < value; i++) {
                                        pt = data[i];
                                        xData[i] = pt[0];
                                        yData[i] = pt.slice(1, valueCount + 1);
                                    }
                                } else {
                                    if (init) {
                                        min = init.indexOf("x");
                                        start = init.indexOf("y");
                                        min = 0 <= min ? min : 0;
                                        start = 0 <= start ? start : 1;
                                    }
                                    /** @type {number} */
                                    i = 0;
                                    for (; i < value; i++) {
                                        pt = data[i];
                                        xData[i] = pt[min];
                                        yData[i] = pt[start];
                                    }
                                }
                            } else {
                                Highcharts.error(12, false, chart);
                            }
                        }
                    } else {
                        /** @type {number} */
                        i = 0;
                        for (; i < value; i++) {
                            if ("undefined" !== typeof data[i]) {
                                pt = {
                                    series: series
                                };
                                series.pointClass.prototype.applyOptions.apply(pt, [data[i]]);
                                series.updateParallelArrays(pt, i);
                            }
                        }
                    }
                    if (yData && isString(yData[0])) {
                        Highcharts.error(14, true, chart);
                    }
                    /** @type {!Array} */
                    series.data = [];
                    series.options.data = series.userOptions.data = data;
                    i = index;
                    for (; i--;) {
                        if (oldData[i] && oldData[i].destroy) {
                            oldData[i].destroy();
                        }
                    }
                    if (xAxis) {
                        xAxis.minRange = xAxis.userMinRange;
                    }
                    /** @type {boolean} */
                    series.isDirty = chart.isDirtyBox = true;
                    /** @type {boolean} */
                    series.isDirtyData = !!oldData;
                    /** @type {boolean} */
                    i = false;
                }
                if ("point" === options.legendType) {
                    this.processData();
                    this.generatePoints();
                }
                if (record) {
                    chart.redraw(i);
                }
            },
            sortData: function (records) {
                var attrs = this;
                var key = attrs.options.dataSorting.sortKey || "y";
                /**
                 * @param {!Object} model
                 * @param {!Object} length
                 * @return {?}
                 */
                var f = function (model, length) {
                    return defined(length) && model.pointClass.prototype.optionsToObject.call({
                        series: model
                    }, length) || {};
                };
                records.forEach(function (b, i) {
                    records[i] = f(attrs, b);
                    /** @type {number} */
                    records[i].index = i;
                }, this);
                records.concat().sort(function (a, b) {
                    return isNumber(b[key]) ? b[key] - a[key] : -1;
                }).forEach(function (a, b) {
                    /** @type {number} */
                    a.x = b;
                }, this);
                if (attrs.linkedSeries) {
                    attrs.linkedSeries.forEach(function (item) {
                        var options = item.options;
                        var data = options.data;
                        if (!(options.dataSorting && options.dataSorting.enabled || !data)) {
                            data.forEach(function (b, i) {
                                data[i] = f(item, b);
                                if (records[i]) {
                                    data[i].x = records[i].x;
                                    /** @type {number} */
                                    data[i].index = i;
                                }
                            });
                            item.setData(data, false);
                        }
                    });
                }
                return records;
            },
            processData: function (counter) {
                var processedXData = this.xData;
                var processedYData = this.yData;
                var len = processedXData.length;
                /** @type {number} */
                var croppedData = 0;
                var xAxis = this.xAxis;
                var val2lin = this.options;
                var i = val2lin.cropThreshold;
                var isHTML5Video = this.getExtremesFromAll || val2lin.getExtremesFromAll;
                var m = this.isCartesian;
                val2lin = xAxis && xAxis.val2lin;
                var tick = xAxis && xAxis.isLog;
                var value = this.requireSorting;
                if (m && !this.isDirty && !xAxis.isDirty && !this.yAxis.isDirty && !counter) {
                    return false;
                }
                if (xAxis) {
                    counter = xAxis.getExtremes();
                    var min = counter.min;
                    var max = counter.max;
                }
                if (m && this.sorted && !isHTML5Video && (!i || len > i || this.forceCrop)) {
                    if (processedXData[len - 1] < min || processedXData[0] > max) {
                        /** @type {!Array} */
                        processedXData = [];
                        /** @type {!Array} */
                        processedYData = [];
                    } else {
                        if (this.yData && (processedXData[0] < min || processedXData[len - 1] > max)) {
                            croppedData = this.cropData(this.xData, this.yData, min, max);
                            processedXData = croppedData.xData;
                            processedYData = croppedData.yData;
                            croppedData = croppedData.start;
                            /** @type {boolean} */
                            var TRUE = true;
                        }
                    }
                }
                i = processedXData.length || 1;
                for (; --i;) {
                    if (len = tick ? val2lin(processedXData[i]) - val2lin(processedXData[i - 1]) : processedXData[i] - processedXData[i - 1], 0 < len && ("undefined" === typeof max || len < max)) {
                        /** @type {number} */
                        var max = len;
                    } else {
                        if (0 > len && value) {
                            Highcharts.error(15, false, this.chart);
                            /** @type {boolean} */
                            value = false;
                        }
                    }
                }
                /** @type {(boolean|undefined)} */
                this.cropped = TRUE;
                this.cropStart = croppedData;
                this.processedXData = processedXData;
                this.processedYData = processedYData;
                /** @type {(number|undefined)} */
                this.closestPointRange = this.basePointRange = max;
            },
            cropData: function (xData, yData, min, max, x) {
                var dataLength = xData.length;
                /** @type {number} */
                var cropStart = 0;
                var cropEnd = dataLength;
                var i;
                x = pick(x, this.cropShoulder);
                /** @type {number} */
                i = 0;
                for (; i < dataLength; i++) {
                    if (xData[i] >= min) {
                        /** @type {number} */
                        cropStart = Math.max(0, i - x);
                        break;
                    }
                }
                /** @type {number} */
                min = i;
                for (; min < dataLength; min++) {
                    if (xData[min] > max) {
                        cropEnd = min + x;
                        break;
                    }
                }
                return {
                    xData: xData.slice(cropStart, cropEnd),
                    yData: yData.slice(cropStart, cropEnd),
                    start: cropStart,
                    end: cropEnd
                };
            },
            generatePoints: function () {
                var options = this.options;
                var args = options.data;
                var data = this.data;
                var dataLength;
                var processedXData = this.processedXData;
                var processedYData = this.processedYData;
                var PointClass = this.pointClass;
                var processedDataLength = processedXData.length;
                var _ = this.cropStart || 0;
                var hasGroupedData = this.hasGroupedData;
                options = options.keys;
                /** @type {!Array} */
                var points = [];
                var i;
                if (!(data || hasGroupedData)) {
                    /** @type {!Array} */
                    data = [];
                    data.length = args.length;
                    /** @type {!Array} */
                    data = this.data = data;
                }
                if (options && hasGroupedData) {
                    /** @type {boolean} */
                    this.options.keys = false;
                }
                /** @type {number} */
                i = 0;
                for (; i < processedDataLength; i++) {
                    var index = _ + i;
                    if (hasGroupedData) {
                        var point = (new PointClass).init(this, [processedXData[i]].concat(splat(processedYData[i])));
                        point.dataGroup = this.groupMap[i];
                        if (point.dataGroup.options) {
                            point.options = point.dataGroup.options;
                            extend(point, point.dataGroup.options);
                            delete point.dataLabels;
                        }
                    } else {
                        if (!((point = data[index]) || "undefined" === typeof args[index])) {
                            data[index] = point = (new PointClass).init(this, args[index], processedXData[i]);
                        }
                    }
                    if (point) {
                        point.index = index;
                        points[i] = point;
                    }
                }
                this.options.keys = options;
                if (data && (processedDataLength !== (dataLength = data.length) || hasGroupedData)) {
                    /** @type {number} */
                    i = 0;
                    for (; i < dataLength; i++) {
                        if (!(i !== _ || hasGroupedData)) {
                            i = i + processedDataLength;
                        }
                        if (data[i]) {
                            data[i].destroyElements();
                            data[i].plotX = void 0;
                        }
                    }
                }
                this.data = data;
                /** @type {!Array} */
                this.points = points;
                fireEvent(this, "afterGeneratePoints");
            },
            getXExtremes: function (values) {
                return {
                    min: arrayMin(values),
                    max: arrayMax(values)
                };
            },
            getExtremes: function (yData) {
                var xAxis = this.xAxis;
                var value = this.yAxis;
                var a = this.processedXData || this.xData;
                /** @type {!Array} */
                var activeYData = [];
                /** @type {number} */
                var activeCounter = 0;
                /** @type {number} */
                var xMin = 0;
                /** @type {number} */
                var p = 0;
                var step = this.requireSorting ? this.cropShoulder : 0;
                var filteredValue = value ? value.positiveValuesOnly : false;
                var i;
                yData = yData || this.stackedYData || this.processedYData || [];
                value = yData.length;
                if (xAxis) {
                    p = xAxis.getExtremes();
                    xMin = p.min;
                    p = p.max;
                }
                /** @type {number} */
                i = 0;
                for (; i < value; i++) {
                    var b = a[i];
                    var y = yData[i];
                    var j = (isNumber(y) || isArray(y)) && (y.length || 0 < y || !filteredValue);
                    b = this.getExtremesFromAll || this.options.getExtremesFromAll || this.cropped || !xAxis || (a[i + step] || b) >= xMin && (a[i - step] || b) <= p;
                    if (j && b) {
                        if (j = y.length) {
                            for (; j--;) {
                                if (isNumber(y[j])) {
                                    activeYData[activeCounter++] = y[j];
                                }
                            }
                        } else {
                            activeYData[activeCounter++] = y;
                        }
                    }
                }
                this.dataMin = arrayMin(activeYData);
                this.dataMax = arrayMax(activeYData);
                fireEvent(this, "afterGetExtremes");
            },
            getFirstValidPoint: function (imgDataArr) {
                /** @type {null} */
                var PENDING = null;
                var length = imgDataArr.length;
                /** @type {number} */
                var i = 0;
                for (; null === PENDING && i < length;) {
                    PENDING = imgDataArr[i];
                    i++;
                }
                return PENDING;
            },
            translate: function () {
                if (!this.processedXData) {
                    this.processData();
                }
                this.generatePoints();
                var options = this.options;
                var stacking = options.stacking;
                var xAxis = this.xAxis;
                var categories = xAxis.categories;
                var f = this.enabledDataSorting;
                var yAxis = this.yAxis;
                var points = this.points;
                var numPts = points.length;
                /** @type {boolean} */
                var k = !!this.modifyValue;
                var i;
                var pointPlacement = this.pointPlacementToXValue();
                var dynamicallyPlaced = isNumber(pointPlacement);
                var threshold = options.threshold;
                var stackThreshold = options.startFromThreshold ? threshold : 0;
                var plotX;
                var type = this.zoneAxis || "y";
                /** @type {number} */
                var index = Number.MAX_VALUE;
                /** @type {number} */
                i = 0;
                for (; i < numPts; i++) {
                    var point = points[i];
                    var x = point.x;
                    var y = point.y;
                    var value = point.low;
                    var stack = stacking && yAxis.stacks[(this.negStacks && y < (stackThreshold ? 0 : threshold) ? "-" : "") + this.stackKey];
                    if (yAxis.positiveValuesOnly && null !== y && 0 >= y) {
                        /** @type {boolean} */
                        point.isNull = true;
                    }
                    point.plotX = plotX = correctFloat(parseFloat(xAxis.translate(x, 0, 0, 0, 1, pointPlacement, "flags" === this.type), -1E5, 1E5));
                    if (stacking && this.visible && stack && stack[x]) {
                        var stackIndicator = this.getStackIndicator(stackIndicator, x, this.index);
                        if (!point.isNull) {
                            var pointStack = stack[x];
                            var array = pointStack.points[stackIndicator.key];
                        }
                    }
                    if (isArray(array)) {
                        value = array[0];
                        y = array[1];
                        if (value === stackThreshold && stackIndicator.key === stack[x].base) {
                            value = pick(isNumber(threshold) && threshold, yAxis.min);
                        }
                        if (yAxis.positiveValuesOnly && 0 >= value) {
                            /** @type {null} */
                            value = null;
                        }
                        point.total = point.stackTotal = pointStack.total;
                        point.percentage = pointStack.total && point.y / pointStack.total * 100;
                        point.stackY = y;
                        if (!this.irregularWidths) {
                            pointStack.setOffset(this.pointXOffset || 0, this.barW || 0);
                        }
                    }
                    point.yBottom = defined(value) ? parseFloat(yAxis.translate(value, 0, 1, 0, 1), -1E5, 1E5) : null;
                    if (k) {
                        y = this.modifyValue(y, point);
                    }
                    point.plotY = y = "number" === typeof y && Infinity !== y ? parseFloat(yAxis.translate(y, 0, 1, 0, 1), -1E5, 1E5) : void 0;
                    /** @type {boolean} */
                    point.isInside = "undefined" !== typeof y && 0 <= y && y <= yAxis.len && 0 <= plotX && plotX <= xAxis.len;
                    point.clientX = dynamicallyPlaced ? correctFloat(xAxis.translate(x, 0, 0, 0, 1, pointPlacement)) : plotX;
                    /** @type {boolean} */
                    point.negative = point[type] < (options[type + "Threshold"] || threshold || 0);
                    point.category = categories && "undefined" !== typeof categories[point.x] ? categories[point.x] : point.x;
                    if (!point.isNull && false !== point.visible) {
                        if ("undefined" !== typeof lastPlotX) {
                            /** @type {number} */
                            index = Math.min(index, Math.abs(plotX - lastPlotX));
                        }
                        var lastPlotX = plotX;
                    }
                    point.zone = this.zones.length && point.getZone();
                    if (!point.graphic && this.group && f) {
                        /** @type {boolean} */
                        point.isNew = true;
                    }
                }
                /** @type {number} */
                this.closestPointRangePx = index;
                fireEvent(this, "afterTranslate");
            },
            getValidPoints: function (p, points, insideOnly) {
                var chart = this.chart;
                return (p || this.points || []).filter(function (point) {
                    return points && !chart.isInsidePlot(point.plotX, point.plotY, chart.inverted) ? false : false !== point.visible && (insideOnly || !point.isNull);
                });
            },
            getClipBox: function (value, inverted) {
                var o = this.options;
                var chart = this.chart;
                var column = chart.inverted;
                var xAxis = this.xAxis;
                var field = xAxis && this.yAxis;
                if (value && false === o.clip && field) {
                    /** @type {({height: ?, width: ?, x: ?, y: ?}|{height: ?, width: ?, x: number, y: number})} */
                    value = column ? {
                        y: -chart.chartWidth + field.len + field.pos,
                        height: chart.chartWidth,
                        width: chart.chartHeight,
                        x: -chart.chartHeight + xAxis.len + xAxis.pos
                    } : {
                        y: -field.pos,
                        height: chart.chartHeight,
                        width: chart.chartWidth,
                        x: -xAxis.pos
                    };
                } else {
                    value = this.clipBox || chart.clipBox;
                    if (inverted) {
                        value.width = chart.plotSizeX;
                        /** @type {number} */
                        value.x = 0;
                    }
                }
                return inverted ? {
                    width: value.width,
                    x: value.x
                } : value;
            },
            setClip: function (animation) {
                var chart = this.chart;
                var o = this.options;
                var renderer = chart.renderer;
                var inverted = chart.inverted;
                var seriesClipBox = this.clipBox;
                var left = this.getClipBox(animation);
                var sharedClipKey = this.sharedClipKey || ["_sharedClip", animation && animation.duration, animation && animation.easing, left.height, o.xAxis, o.yAxis].join();
                var clipRect = chart[sharedClipKey];
                var title = chart[sharedClipKey + "m"];
                if (!clipRect) {
                    if (animation) {
                        /** @type {number} */
                        left.width = 0;
                        if (inverted) {
                            left.x = chart.plotSizeX + (false !== o.clip ? 0 : chart.plotTop);
                        }
                        chart[sharedClipKey + "m"] = title = renderer.clipRect(inverted ? chart.plotSizeX + 99 : -99, inverted ? -chart.plotLeft : -chart.plotTop, 99, inverted ? chart.chartWidth : chart.chartHeight);
                    }
                    chart[sharedClipKey] = clipRect = renderer.clipRect(left);
                    clipRect.count = {
                        length: 0
                    };
                }
                if (animation && !clipRect.count[this.index]) {
                    /** @type {boolean} */
                    clipRect.count[this.index] = true;
                    clipRect.count.length += 1;
                }
                if (false !== o.clip || animation) {
                    this.group.clip(animation || seriesClipBox ? clipRect : chart.clipRect);
                    this.markerGroup.clip(title);
                    this.sharedClipKey = sharedClipKey;
                }
                if (!animation) {
                    if (clipRect.count[this.index]) {
                        delete clipRect.count[this.index];
                        --clipRect.count.length;
                    }
                    if (0 === clipRect.count.length && sharedClipKey && chart[sharedClipKey]) {
                        if (!seriesClipBox) {
                            chart[sharedClipKey] = chart[sharedClipKey].destroy();
                        }
                        if (chart[sharedClipKey + "m"]) {
                            chart[sharedClipKey + "m"] = chart[sharedClipKey + "m"].destroy();
                        }
                    }
                }
            },
            animate: function (data) {
                var chart = this.chart;
                var name = animObject(this.options.animation);
                if (data) {
                    this.setClip(name);
                } else {
                    var sharedClipKey = this.sharedClipKey;
                    data = chart[sharedClipKey];
                    var g = this.getClipBox(name, true);
                    if (data) {
                        data.animate(g, name);
                    }
                    if (chart[sharedClipKey + "m"]) {
                        chart[sharedClipKey + "m"].animate({
                            width: g.width + 99,
                            x: g.x - (chart.inverted ? 0 : 99)
                        }, name);
                    }
                    /** @type {null} */
                    this.animate = null;
                }
            },
            afterAnimate: function () {
                this.setClip();
                fireEvent(this, "afterAnimate");
                /** @type {boolean} */
                this.finishedAnimating = true;
            },
            drawPoints: function () {
                var points = this.points;
                var chart = this.chart;
                var i;
                var graphic;
                var seriesMarkerOptions = this.options.marker;
                var feature = this[this.specialGroup] || this.markerGroup;
                var sel = this.xAxis;
                var globallyEnabled = pick(seriesMarkerOptions.enabled, !sel || sel.isRadial ? true : null, this.closestPointRangePx >= seriesMarkerOptions.enabledThreshold * seriesMarkerOptions.radius);
                if (false !== seriesMarkerOptions.enabled || this._hasPointMarkers) {
                    /** @type {number} */
                    i = 0;
                    for (; i < points.length; i++) {
                        var point = points[i];
                        /** @type {string} */
                        var verb = (graphic = point.graphic) ? "animate" : "attr";
                        var pointMarkerOptions = point.marker || {};
                        /** @type {boolean} */
                        var hasPointMarker = !!point.marker;
                        if ((globallyEnabled && "undefined" === typeof pointMarkerOptions.enabled || pointMarkerOptions.enabled) && !point.isNull && false !== point.visible) {
                            var key = pick(pointMarkerOptions.symbol, this.symbol);
                            var el = this.markerAttribs(point, point.selected && "select");
                            if (this.enabledDataSorting) {
                                point.startXPos = sel.reversed ? -el.width : sel.width;
                            }
                            /** @type {boolean} */
                            var html = false !== point.isInside;
                            if (graphic) {
                                graphic[html ? "show" : "hide"](html).animate(el);
                            } else {
                                if (html && (0 < el.width || point.hasImage)) {
                                    point.graphic = graphic = chart.renderer.symbol(key, el.x, el.y, el.width, el.height, hasPointMarker ? pointMarkerOptions : seriesMarkerOptions).add(feature);
                                    if (this.enabledDataSorting && chart.hasRendered) {
                                        graphic.attr({
                                            x: point.startXPos
                                        });
                                        /** @type {string} */
                                        verb = "animate";
                                    }
                                }
                            }
                            if (graphic && "animate" === verb) {
                                graphic[html ? "show" : "hide"](html).animate(el);
                            }
                            if (graphic && !chart.styledMode) {
                                graphic[verb](this.pointAttribs(point, point.selected && "select"));
                            }
                            if (graphic) {
                                graphic.addClass(point.getClassName(), true);
                            }
                        } else {
                            if (graphic) {
                                point.graphic = graphic.destroy();
                            }
                        }
                    }
                }
            },
            markerAttribs: function (a, s) {
                var options = this.options.marker;
                var params = a.marker || {};
                var urlHosts = params.symbol || options.symbol;
                var radius = pick(params.radius, options.radius);
                if (s) {
                    options = options.states[s];
                    s = params.states && params.states[s];
                    radius = pick(s && s.radius, options && options.radius, radius + (options && options.radiusPlus || 0));
                }
                a.hasImage = urlHosts && 0 === urlHosts.indexOf("url");
                if (a.hasImage) {
                    /** @type {number} */
                    radius = 0;
                }
                a = {
                    x: Math.floor(a.plotX) - radius,
                    y: a.plotY - radius
                };
                if (radius) {
                    /** @type {number} */
                    a.width = a.height = 2 * radius;
                }
                return a;
            },
            pointAttribs: function (point, state) {
                var options = this.options.marker;
                var pointOptions = point && point.options;
                var pointMarkerOptions = pointOptions && pointOptions.marker || {};
                var color = this.color;
                var borderColor = pointOptions && pointOptions.color;
                var pointColor = point && point.color;
                pointOptions = pick(pointMarkerOptions.lineWidth, options.lineWidth);
                var eeEEee = point && point.zone && point.zone.color;
                /** @type {number} */
                point = 1;
                color = borderColor || eeEEee || pointColor || color;
                borderColor = pointMarkerOptions.fillColor || options.fillColor || color;
                color = pointMarkerOptions.lineColor || options.lineColor || color;
                state = state || "normal";
                options = options.states[state];
                state = pointMarkerOptions.states && pointMarkerOptions.states[state] || {};
                pointOptions = pick(state.lineWidth, options.lineWidth, pointOptions + pick(state.lineWidthPlus, options.lineWidthPlus, 0));
                borderColor = state.fillColor || options.fillColor || borderColor;
                color = state.lineColor || options.lineColor || color;
                point = pick(state.opacity, options.opacity, point);
                return {
                    stroke: color,
                    "stroke-width": pointOptions,
                    fill: borderColor,
                    opacity: point
                };
            },
            destroy: function (key) {
                var series = this;
                var chart = series.chart;
                /** @type {boolean} */
                var issue134 = /AppleWebKit\/533/.test(win.navigator.userAgent);
                var destroy;
                var i;
                var textareas = series.data || [];
                var el;
                var axis;
                fireEvent(series, "destroy");
                this.removeEvents(key);
                (series.axisTypes || []).forEach(function (name) {
                    if ((axis = series[name]) && axis.series) {
                        erase(axis.series, series);
                        /** @type {boolean} */
                        axis.isDirty = axis.forceRedraw = true;
                    }
                });
                if (series.legendItem) {
                    series.chart.legend.destroyItem(series);
                }
                i = textareas.length;
                for (; i--;) {
                    if ((el = textareas[i]) && el.destroy) {
                        el.destroy();
                    }
                }
                /** @type {null} */
                series.points = null;
                Highcharts.clearTimeout(series.animationTimeout);
                objectEach(series, function (val, group) {
                    if (val instanceof SVGElement && !val.survive) {
                        /** @type {string} */
                        destroy = issue134 && "group" === group ? "hide" : "destroy";
                        val[destroy]();
                    }
                });
                if (chart.hoverSeries === series) {
                    /** @type {null} */
                    chart.hoverSeries = null;
                }
                erase(chart.series, series);
                chart.orderSeries();
                objectEach(series, function (canCreateDiscussions, name) {
                    if (!(key && "hcEvents" === name)) {
                        delete series[name];
                    }
                });
            },
            getGraphPath: function (points, nullsAsZeroes, connectCliffs) {
                var series = this;
                var options = series.options;
                var step = options.step;
                var reversed;
                /** @type {!Array} */
                var graphPath = [];
                /** @type {!Array} */
                var xMap = [];
                var p;
                points = points || series.points;
                if (reversed = points.reversed) {
                    points.reverse();
                }
                if ((step = {
                    right: 1,
                    center: 2
                }[step] || step && 3) && reversed) {
                    /** @type {number} */
                    step = 4 - step;
                }
                points = this.getValidPoints(points, false, !(options.connectNulls && !nullsAsZeroes && !connectCliffs));
                points.forEach(function (point, pathToPoint) {
                    var plotX = point.plotX;
                    var plotY = point.plotY;
                    var lastPoint = points[pathToPoint - 1];
                    if ((point.leftCliff || lastPoint && lastPoint.rightCliff) && !connectCliffs) {
                        /** @type {boolean} */
                        p = true;
                    }
                    if (point.isNull && !defined(nullsAsZeroes) && 0 < pathToPoint) {
                        /** @type {boolean} */
                        p = !options.connectNulls;
                    } else {
                        if (point.isNull && !nullsAsZeroes) {
                            /** @type {boolean} */
                            p = true;
                        } else {
                            if (0 === pathToPoint || p) {
                                /** @type {!Array} */
                                pathToPoint = ["M", point.plotX, point.plotY];
                            } else {
                                if (series.getPointSpline) {
                                    pathToPoint = series.getPointSpline(points, point, pathToPoint);
                                } else {
                                    if (step) {
                                        /** @type {!Array} */
                                        pathToPoint = 1 === step ? ["L", lastPoint.plotX, plotY] : 2 === step ? ["L", (lastPoint.plotX + plotX) / 2, lastPoint.plotY, "L", (lastPoint.plotX + plotX) / 2, plotY] : ["L", plotX, lastPoint.plotY];
                                        pathToPoint.push("L", plotX, plotY);
                                    } else {
                                        /** @type {!Array} */
                                        pathToPoint = ["L", plotX, plotY];
                                    }
                                }
                            }
                            xMap.push(point.x);
                            if (step) {
                                xMap.push(point.x);
                                if (2 === step) {
                                    xMap.push(point.x);
                                }
                            }
                            graphPath.push.apply(graphPath, pathToPoint);
                            /** @type {boolean} */
                            p = false;
                        }
                    }
                });
                /** @type {!Array} */
                graphPath.xMap = xMap;
                return series.graphPath = graphPath;
            },
            drawGraph: function () {
                var series = this;
                var options = this.options;
                var graphPath = (this.gappedPath || this.getGraphPath).call(this);
                var slots = this.chart.styledMode;
                /** @type {!Array} */
                var index = [["graph", "highcharts-graph"]];
                if (!slots) {
                    index[0].push(options.lineColor || this.color || "#cccccc", options.dashStyle);
                }
                index = series.getZonesGraphs(index);
                index.forEach(function (prop, cols) {
                    var attribs = prop[0];
                    var graph = series[attribs];
                    /** @type {string} */
                    var ani = graph ? "animate" : "attr";
                    if (graph) {
                        graph.endX = series.preventGraphAnimation ? null : graphPath.xMap;
                        graph.animate({
                            d: graphPath
                        });
                    } else {
                        if (graphPath.length) {
                            series[attribs] = graph = series.chart.renderer.path(graphPath).addClass(prop[1]).attr({
                                zIndex: 1
                            }).add(series.group);
                        }
                    }
                    if (graph && !slots) {
                        attribs = {
                            stroke: prop[2],
                            "stroke-width": options.lineWidth,
                            fill: series.fillGraph && series.color || "none"
                        };
                        if (prop[3]) {
                            attribs.dashstyle = prop[3];
                        } else {
                            if ("square" !== options.linecap) {
                                /** @type {string} */
                                attribs["stroke-linecap"] = attribs["stroke-linejoin"] = "round";
                            }
                        }
                        graph[ani](attribs).shadow(2 > cols && options.shadow);
                    }
                    if (graph) {
                        graph.startX = graphPath.xMap;
                        graph.isArea = graphPath.isArea;
                    }
                });
            },
            getZonesGraphs: function (tpl) {
                this.zones.forEach(function (options, context) {
                    /** @type {!Array} */
                    context = ["zone-graph-" + context, "highcharts-graph highcharts-zone-graph-" + context + " " + (options.className || "")];
                    if (!this.chart.styledMode) {
                        context.push(options.color || this.color, options.dashStyle || this.options.dashStyle);
                    }
                    tpl.push(context);
                }, this);
                return tpl;
            },
            applyZones: function () {
                var series = this;
                var chart = this.chart;
                var renderer = chart.renderer;
                var zones = this.zones;
                var a;
                var b;
                var clips = this.clips || [];
                var size;
                var graph = this.graph;
                var area = this.area;
                /** @type {number} */
                var max = Math.max(chart.chartWidth, chart.chartHeight);
                var axis = this[(this.zoneAxis || "y") + "Axis"];
                var inverted = chart.inverted;
                var dxdydust;
                var pxPosMin;
                var pxPosMax;
                /** @type {boolean} */
                var v = false;
                if (zones.length && (graph || area) && axis && "undefined" !== typeof axis.min) {
                    var reversed = axis.reversed;
                    var horiz = axis.horiz;
                    if (graph && !this.showLine) {
                        graph.hide();
                    }
                    if (area) {
                        area.hide();
                    }
                    var extremes = axis.getExtremes();
                    zones.forEach(function (threshold, i) {
                        a = reversed ? horiz ? chart.plotWidth : 0 : horiz ? 0 : axis.toPixels(extremes.min) || 0;
                        a = parseFloat(pick(b, a), 0, max);
                        b = parseFloat(Math.round(axis.toPixels(pick(threshold.value, extremes.max), true) || 0), 0, max);
                        if (v) {
                            a = b = axis.toPixels(extremes.max);
                        }
                        /** @type {number} */
                        dxdydust = Math.abs(a - b);
                        /** @type {number} */
                        pxPosMin = Math.min(a, b);
                        /** @type {number} */
                        pxPosMax = Math.max(a, b);
                        if (axis.isXAxis) {
                            size = {
                                x: inverted ? pxPosMax : pxPosMin,
                                y: 0,
                                width: dxdydust,
                                height: max
                            };
                            if (!horiz) {
                                /** @type {number} */
                                size.x = chart.plotHeight - size.x;
                            }
                        } else {
                            size = {
                                x: 0,
                                y: inverted ? pxPosMax : pxPosMin,
                                width: max,
                                height: dxdydust
                            };
                            if (horiz) {
                                /** @type {number} */
                                size.y = chart.plotWidth - size.y;
                            }
                        }
                        if (inverted && renderer.isVML) {
                            /** @type {({height: ?, width: ?, x: number, y: number})} */
                            size = axis.isXAxis ? {
                                x: 0,
                                y: reversed ? pxPosMin : pxPosMax,
                                height: size.width,
                                width: chart.chartWidth
                            } : {
                                x: size.y - chart.plotLeft - chart.spacingBox.x,
                                y: 0,
                                width: size.height,
                                height: chart.chartHeight
                            };
                        }
                        if (clips[i]) {
                            clips[i].animate(size);
                        } else {
                            clips[i] = renderer.clipRect(size);
                        }
                        if (graph) {
                            series["zone-graph-" + i].clip(clips[i]);
                        }
                        if (area) {
                            series["zone-area-" + i].clip(clips[i]);
                        }
                        /** @type {boolean} */
                        v = threshold.value > extremes.max;
                        if (series.resetZones && 0 === b) {
                            b = void 0;
                        }
                    });
                    this.clips = clips;
                } else {
                    if (series.visible) {
                        if (graph) {
                            graph.show(true);
                        }
                        if (area) {
                            area.show(true);
                        }
                    }
                }
            },
            invertGroups: function (inverted) {
                /**
                 * @return {undefined}
                 */
                function setInvert() {
                    ["group", "markerGroup"].forEach(function (groupName) {
                        if (series[groupName]) {
                            if (chart.renderer.isVML) {
                                series[groupName].attr({
                                    width: series.yAxis.len,
                                    height: series.xAxis.len
                                });
                            }
                            series[groupName].width = series.yAxis.len;
                            series[groupName].height = series.xAxis.len;
                            series[groupName].invert(series.isRadialSeries ? false : inverted);
                        }
                    });
                }
                var series = this;
                var chart = series.chart;
                if (series.xAxis) {
                    series.eventsToUnbind.push(addEvent(chart, "resize", setInvert));
                    setInvert();
                    /** @type {function(): undefined} */
                    series.invertGroups = setInvert;
                }
            },
            plotGroup: function (prop, name, visibility, zIndex, parent) {
                var group = this[prop];
                /** @type {boolean} */
                var isNew = !group;
                if (isNew) {
                    this[prop] = group = this.chart.renderer.g().attr({
                        zIndex: zIndex || .1
                    }).add(parent);
                }
                group.addClass("highcharts-" + name + " highcharts-series-" + this.index + " highcharts-" + this.type + "-series " + (defined(this.colorIndex) ? "highcharts-color-" + this.colorIndex + " " : "") + (this.options.className || "") + (group.hasClass("highcharts-tracker") ? " highcharts-tracker" : ""), true);
                group.attr({
                    visibility: visibility
                })[isNew ? "attr" : "animate"](this.getPlotBox());
                return group;
            },
            getPlotBox: function () {
                var chart = this.chart;
                var xAxis = this.xAxis;
                var yAxis = this.yAxis;
                if (chart.inverted) {
                    xAxis = yAxis;
                    yAxis = this.xAxis;
                }
                return {
                    translateX: xAxis ? xAxis.left : chart.plotLeft,
                    translateY: yAxis ? yAxis.top : chart.plotTop,
                    scaleX: 1,
                    scaleY: 1
                };
            },
            removeEvents: function (elem) {
                if (elem) {
                    if (this.eventsToUnbind.length) {
                        this.eventsToUnbind.forEach(function (unbind) {
                            unbind();
                        });
                        /** @type {number} */
                        this.eventsToUnbind.length = 0;
                    }
                } else {
                    each(this);
                }
            },
            render: function () {
                var series = this;
                var chart = series.chart;
                var options = series.options;
                var c = !!series.animate && chart.renderer.isSVG && animObject(options.animation).duration;
                /** @type {string} */
                var visibility = series.visible ? "inherit" : "hidden";
                var zIndex = options.zIndex;
                var hasRendered = series.hasRendered;
                var chartSeriesGroup = chart.seriesGroup;
                var inverted = chart.inverted;
                fireEvent(this, "render");
                var group = series.plotGroup("group", "series", visibility, zIndex, chartSeriesGroup);
                series.markerGroup = series.plotGroup("markerGroup", "markers", visibility, zIndex, chartSeriesGroup);
                if (c) {
                    series.animate(true);
                }
                group.inverted = series.isCartesian || series.invertable ? inverted : false;
                if (series.drawGraph) {
                    series.drawGraph();
                    series.applyZones();
                }
                if (series.visible) {
                    series.drawPoints();
                }
                if (series.drawDataLabels) {
                    series.drawDataLabels();
                }
                if (series.redrawPoints) {
                    series.redrawPoints();
                }
                if (series.drawTracker && false !== series.options.enableMouseTracking) {
                    series.drawTracker();
                }
                series.invertGroups(inverted);
                if (!(false === options.clip || series.sharedClipKey || hasRendered)) {
                    group.clip(chart.clipRect);
                }
                if (c) {
                    series.animate();
                }
                if (!hasRendered) {
                    series.animationTimeout = syncTimeout(function () {
                        series.afterAnimate();
                    }, c || 0);
                }
                /** @type {boolean} */
                series.isDirty = false;
                /** @type {boolean} */
                series.hasRendered = true;
                fireEvent(series, "afterRender");
            },
            redraw: function () {
                var chart = this.chart;
                var b = this.isDirty || this.isDirtyData;
                var group = this.group;
                var xAxis = this.xAxis;
                var yAxis = this.yAxis;
                if (group) {
                    if (chart.inverted) {
                        group.attr({
                            width: chart.plotWidth,
                            height: chart.plotHeight
                        });
                    }
                    group.animate({
                        translateX: pick(xAxis && xAxis.left, chart.plotLeft),
                        translateY: pick(yAxis && yAxis.top, chart.plotTop)
                    });
                }
                this.translate();
                this.render();
                if (b) {
                    delete this.kdTree;
                }
            },
            kdAxisArray: ["clientX", "plotY"],
            searchPoint: function (e, compareX) {
                var xAxis = this.xAxis;
                var yAxis = this.yAxis;
                var inverted = this.chart.inverted;
                return this.searchKDTree({
                    clientX: inverted ? xAxis.len - e.chartY + xAxis.pos : e.chartX - xAxis.pos,
                    plotY: inverted ? yAxis.len - e.chartX + yAxis.pos : e.chartY - yAxis.pos
                }, compareX, e);
            },
            buildKDTree: function (fn) {
                /**
                 * @param {!Object} points
                 * @param {number} depth
                 * @param {number} dimensions
                 * @return {?}
                 */
                function _kdtree(points, depth, dimensions) {
                    var i;
                    if (i = points && points.length) {
                        var param = series.kdAxisArray[depth % dimensions];
                        points.sort(function (elementOffset, containerOffset) {
                            return elementOffset[param] - containerOffset[param];
                        });
                        /** @type {number} */
                        i = Math.floor(i / 2);
                        return {
                            point: points[i],
                            left: _kdtree(points.slice(0, i), depth + 1, dimensions),
                            right: _kdtree(points.slice(i + 1), depth + 1, dimensions)
                        };
                    }
                }
                /** @type {boolean} */
                this.buildingKdTree = true;
                var series = this;
                /** @type {number} */
                var dimensions = -1 < series.options.findNearestPointBy.indexOf("y") ? 2 : 1;
                delete series.kdTree;
                syncTimeout(function () {
                    series.kdTree = _kdtree(series.getValidPoints(null, !series.directTouch), dimensions, dimensions);
                    /** @type {boolean} */
                    series.buildingKdTree = false;
                }, series.options.kdNow || fn && "touchstart" === fn.type ? 0 : 1);
            },
            searchKDTree: function (point, compareX, e) {
                /**
                 * @param {(Object|string)} point
                 * @param {!Object} tree
                 * @param {number} depth
                 * @param {number} dimensions
                 * @return {?}
                 */
                function _search(point, tree, depth, dimensions) {
                    var pos = tree.point;
                    var i = series.kdAxisArray[depth % dimensions];
                    var min = pos;
                    /** @type {(null|number)} */
                    var r = defined(point[Y]) && defined(pos[Y]) ? Math.pow(point[Y] - pos[Y], 2) : null;
                    /** @type {(null|number)} */
                    var x = defined(point[axis]) && defined(pos[axis]) ? Math.pow(point[axis] - pos[axis], 2) : null;
                    /** @type {number} */
                    x = (r || 0) + (x || 0);
                    /** @type {number} */
                    pos.dist = defined(x) ? Math.sqrt(x) : Number.MAX_VALUE;
                    /** @type {number} */
                    pos.distX = defined(r) ? Math.sqrt(r) : Number.MAX_VALUE;
                    /** @type {number} */
                    i = point[i] - pos[i];
                    /** @type {string} */
                    x = 0 > i ? "left" : "right";
                    /** @type {string} */
                    r = 0 > i ? "right" : "left";
                    if (tree[x]) {
                        x = _search(point, tree[x], depth + 1, dimensions);
                        min = x[j] < min[j] ? x : pos;
                    }
                    if (tree[r] && Math.sqrt(i * i) < min[j]) {
                        point = _search(point, tree[r], depth + 1, dimensions);
                        min = point[j] < min[j] ? point : min;
                    }
                    return min;
                }
                var series = this;
                var Y = this.kdAxisArray[0];
                var axis = this.kdAxisArray[1];
                /** @type {string} */
                var j = compareX ? "distX" : "dist";
                /** @type {number} */
                compareX = -1 < series.options.findNearestPointBy.indexOf("y") ? 2 : 1;
                if (!(this.kdTree || this.buildingKdTree)) {
                    this.buildKDTree(e);
                }
                if (this.kdTree) {
                    return _search(point, this.kdTree, compareX, compareX);
                }
            },
            pointPlacementToXValue: function () {
                var xAxis = this.xAxis;
                var pointPlacement = this.options.pointPlacement;
                if ("between" === pointPlacement) {
                    /** @type {number} */
                    pointPlacement = xAxis.reversed ? -.5 : .5;
                }
                if (isNumber(pointPlacement)) {
                    /** @type {number} */
                    pointPlacement = pointPlacement * pick(this.options.pointRange || xAxis.pointRange);
                }
                return pointPlacement;
            }
        });
        "";
    });
    set(x1, "parts/Stacking.js", [x1["parts/Globals.js"], x1["parts/Utilities.js"]], function (Highcharts, H) {
        var correctFloat = H.correctFloat;
        var defined = H.defined;
        var destroyObjectProperties = H.destroyObjectProperties;
        var objectEach = H.objectEach;
        var pick = H.pick;
        H = Highcharts.Axis;
        var Chart = Highcharts.Chart;
        var interpolate = Highcharts.format;
        var Series = Highcharts.Series;
        /**
         * @param {!Object} axis
         * @param {!Object} options
         * @param {boolean} isNegative
         * @param {number} x
         * @param {string} stackOption
         * @return {undefined}
         */
        Highcharts.StackItem = function (axis, options, isNegative, x, stackOption) {
            var inverted = axis.chart.inverted;
            /** @type {!Object} */
            this.axis = axis;
            /** @type {boolean} */
            this.isNegative = isNegative;
            this.options = options = options || {};
            /** @type {number} */
            this.x = x;
            /** @type {null} */
            this.total = null;
            this.points = {};
            /** @type {string} */
            this.stack = stackOption;
            /** @type {number} */
            this.rightCliff = this.leftCliff = 0;
            this.alignOptions = {
                align: options.align || (inverted ? isNegative ? "left" : "right" : "center"),
                verticalAlign: options.verticalAlign || (inverted ? "middle" : isNegative ? "bottom" : "top"),
                y: options.y,
                x: options.x
            };
            this.textAlign = options.textAlign || (inverted ? isNegative ? "right" : "left" : "center");
        };
        Highcharts.StackItem.prototype = {
            destroy: function () {
                destroyObjectProperties(this, this.axis);
            },
            render: function (val) {
                var x = this.axis.chart;
                var options = this.options;
                var value = options.format;
                value = value ? interpolate(value, this, x) : options.formatter.call(this);
                if (this.label) {
                    this.label.attr({
                        text: value,
                        visibility: "hidden"
                    });
                } else {
                    this.label = x.renderer.label(value, null, null, options.shape, null, null, options.useHTML, false, "stack-labels");
                    value = {
                        text: value,
                        align: this.textAlign,
                        rotation: options.rotation,
                        padding: pick(options.padding, 0),
                        visibility: "hidden"
                    };
                    this.label.attr(value);
                    if (!x.styledMode) {
                        this.label.css(options.style);
                    }
                    if (!this.label.added) {
                        this.label.add(val);
                    }
                }
                this.label.labelrank = x.plotHeight;
            },
            setOffset: function (v, data, o, offset, value) {
                var options = this.axis;
                var chart = options.chart;
                offset = options.translate(options.usePercentage ? 100 : offset ? offset : this.total, 0, 0, 0, 1);
                o = options.translate(o ? o : 0);
                o = defined(offset) && Math.abs(offset - o);
                v = pick(value, chart.xAxis[0].translate(this.x)) + v;
                options = defined(offset) && this.getStackBox(chart, this, v, offset, data, o, options);
                data = this.label;
                v = this.isNegative;
                /** @type {boolean} */
                value = "justify" === pick(this.options.overflow, "justify");
                if (data && options) {
                    o = data.getBBox();
                    var oX = chart.inverted ? v ? o.width : 0 : o.width / 2;
                    var oY = chart.inverted ? o.height / 2 : v ? -4 : o.height + 4;
                    this.alignOptions.x = pick(this.options.x, 0);
                    data.align(this.alignOptions, null, options);
                    offset = data.alignAttr;
                    data.show();
                    offset.y -= oY;
                    if (value) {
                        offset.x -= oX;
                        Series.prototype.justifyDataLabel.call(this.axis, data, this.alignOptions, offset, o, options);
                        offset.x += oX;
                    }
                    offset.x = data.alignAttr.x;
                    data.attr({
                        x: offset.x,
                        y: offset.y
                    });
                    if (pick(!value && this.options.crop, true)) {
                        if (!(chart = chart.isInsidePlot(data.x + (chart.inverted ? 0 : -o.width / 2), data.y) && chart.isInsidePlot(data.x + (chart.inverted ? v ? -o.width : o.width : o.width / 2), data.y + o.height))) {
                            data.hide();
                        }
                    }
                }
            },
            getStackBox: function (chart, neg, x, y, width, h, event) {
                var reversed = neg.axis.reversed;
                var inverted = chart.inverted;
                /** @type {number} */
                chart = event.height + event.pos - (inverted ? chart.plotLeft : chart.plotTop);
                neg = neg.isNegative && !reversed || !neg.isNegative && reversed;
                return {
                    x: inverted ? neg ? y : y - h : x,
                    y: inverted ? chart - x - width : neg ? chart - y - h : chart - y,
                    width: inverted ? h : width,
                    height: inverted ? width : h
                };
            }
        };
        /**
         * @return {undefined}
         */
        Chart.prototype.getStacks = function () {
            var chart = this;
            var inverted = chart.inverted;
            chart.yAxis.forEach(function (axis) {
                if (axis.stacks && axis.hasVisibleSeries) {
                    axis.oldStacks = axis.stacks;
                }
            });
            chart.series.forEach(function (series) {
                var coordinate = series.xAxis && series.xAxis.options || {};
                if (!(!series.options.stacking || true !== series.visible && false !== chart.options.chart.ignoreHiddenSeries)) {
                    /** @type {string} */
                    series.stackKey = [series.type, pick(series.options.stack, ""), inverted ? coordinate.top : coordinate.left, inverted ? coordinate.height : coordinate.width].join();
                }
            });
        };
        /**
         * @return {undefined}
         */
        H.prototype.buildStacks = function () {
            var s = this.series;
            var l = pick(this.options.reversedStacks, true);
            var size = s.length;
            var n;
            if (!this.isXAxis) {
                /** @type {boolean} */
                this.usePercentage = false;
                n = size;
                for (; n--;) {
                    var chTo = s[l ? n : size - n - 1];
                    chTo.setStackedPoints();
                }
                /** @type {number} */
                n = 0;
                for (; n < size; n++) {
                    s[n].modifyStacks();
                }
                Highcharts.fireEvent(this, "afterBuildStacks");
            }
        };
        /**
         * @return {undefined}
         */
        H.prototype.renderStackTotals = function () {
            var chart = this.chart;
            var renderer = chart.renderer;
            var stacks = this.stacks;
            var stackTotalGroup = this.stackTotalGroup;
            if (!stackTotalGroup) {
                this.stackTotalGroup = stackTotalGroup = renderer.g("stack-labels").attr({
                    visibility: "visible",
                    zIndex: 6
                }).add();
            }
            stackTotalGroup.translate(chart.plotLeft, chart.plotTop);
            objectEach(stacks, function (data) {
                objectEach(data, function (stack) {
                    stack.render(stackTotalGroup);
                });
            });
        };
        /**
         * @return {undefined}
         */
        H.prototype.resetStacks = function () {
            var axis = this;
            var stacks = axis.stacks;
            if (!axis.isXAxis) {
                objectEach(stacks, function (definitions) {
                    objectEach(definitions, function (stack, name) {
                        if (stack.touched < axis.stacksTouched) {
                            stack.destroy();
                            delete definitions[name];
                        } else {
                            /** @type {null} */
                            stack.total = null;
                            /** @type {null} */
                            stack.cumulative = null;
                        }
                    });
                });
            }
        };
        /**
         * @return {undefined}
         */
        H.prototype.cleanStacks = function () {
            if (!this.isXAxis) {
                if (this.oldStacks) {
                    var stacks = this.stacks = this.oldStacks;
                }
                objectEach(stacks, function (data) {
                    objectEach(data, function (data) {
                        data.cumulative = data.total;
                    });
                });
            }
        };
        /**
         * @return {undefined}
         */
        Series.prototype.setStackedPoints = function () {
            if (this.options.stacking && (true === this.visible || false === this.chart.options.chart.ignoreHiddenSeries)) {
                var known_x = this.processedXData;
                var result = this.processedYData;
                /** @type {!Array} */
                var stackedYData = [];
                var trlen = result.length;
                var options = this.options;
                var threshold = options.threshold;
                var stackThreshold = pick(options.startFromThreshold && threshold, 0);
                var tileset = options.stack;
                options = options.stacking;
                var h = this.stackKey;
                /** @type {string} */
                var d = "-" + h;
                var negStacks = this.negStacks;
                var yAxis = this.yAxis;
                var stacks = yAxis.stacks;
                var oldStacks = yAxis.oldStacks;
                var c;
                var i;
                yAxis.stacksTouched += 1;
                /** @type {number} */
                i = 0;
                for (; i < trlen; i++) {
                    var x = known_x[i];
                    var y = result[i];
                    var data = this.getStackIndicator(data, x, this.index);
                    var pointKey = data.key;
                    var stack = (c = negStacks && y < (stackThreshold ? 0 : threshold)) ? d : h;
                    if (!stacks[stack]) {
                        stacks[stack] = {};
                    }
                    if (!stacks[stack][x]) {
                        if (oldStacks[stack] && oldStacks[stack][x]) {
                            stacks[stack][x] = oldStacks[stack][x];
                            /** @type {null} */
                            stacks[stack][x].total = null;
                        } else {
                            stacks[stack][x] = new Highcharts.StackItem(yAxis, yAxis.options.stackLabels, c, x, tileset);
                        }
                    }
                    stack = stacks[stack][x];
                    if (null !== y) {
                        /** @type {!Array} */
                        stack.points[pointKey] = stack.points[this.index] = [pick(stack.cumulative, stackThreshold)];
                        if (!defined(stack.cumulative)) {
                            stack.base = pointKey;
                        }
                        stack.touched = yAxis.stacksTouched;
                        if (0 < data.index && false === this.singleStacks) {
                            stack.points[pointKey][0] = stack.points[this.index + "," + x + ",0"][0];
                        }
                    } else {
                        /** @type {null} */
                        stack.points[pointKey] = stack.points[this.index] = null;
                    }
                    if ("percent" === options) {
                        c = c ? h : d;
                        if (negStacks && stacks[c] && stacks[c][x]) {
                            c = stacks[c][x];
                            /** @type {number} */
                            stack.total = c.total = Math.max(c.total, stack.total) + Math.abs(y) || 0;
                        } else {
                            stack.total = correctFloat(stack.total + (Math.abs(y) || 0));
                        }
                    } else {
                        stack.total = correctFloat(stack.total + (y || 0));
                    }
                    stack.cumulative = pick(stack.cumulative, stackThreshold) + (y || 0);
                    if (null !== y) {
                        stack.points[pointKey].push(stack.cumulative);
                        stackedYData[i] = stack.cumulative;
                    }
                }
                if ("percent" === options) {
                    /** @type {boolean} */
                    yAxis.usePercentage = true;
                }
                /** @type {!Array} */
                this.stackedYData = stackedYData;
                yAxis.oldStacks = {};
            }
        };
        /**
         * @return {undefined}
         */
        Series.prototype.modifyStacks = function () {
            var series = this;
            var stackKey = series.stackKey;
            var stacks = series.yAxis.stacks;
            var processedXData = series.processedXData;
            var stackIndicator;
            var key = series.options.stacking;
            if (series[key + "Stacker"]) {
                [stackKey, "-" + stackKey].forEach(function (key) {
                    var i = processedXData.length;
                    var x;
                    var id;
                    for (; i--;) {
                        if (x = processedXData[i], stackIndicator = series.getStackIndicator(stackIndicator, x, series.index, key), id = (x = stacks[key] && stacks[key][x]) && x.points[stackIndicator.key]) {
                            series[key + "Stacker"](id, x, i);
                        }
                    }
                });
            }
        };
        /**
         * @param {!Object} b
         * @param {!Object} r
         * @param {?} i
         * @return {undefined}
         */
        Series.prototype.percentStacker = function (b, r, i) {
            /** @type {number} */
            r = r.total ? 100 / r.total : 0;
            b[0] = correctFloat(b[0] * r);
            b[1] = correctFloat(b[1] * r);
            this.stackedYData[i] = b[1];
        };
        /**
         * @param {!Object} stackIndicator
         * @param {number} x
         * @param {?} index
         * @param {!Object} key
         * @return {?}
         */
        Series.prototype.getStackIndicator = function (stackIndicator, x, index, key) {
            if (!defined(stackIndicator) || stackIndicator.x !== x || key && stackIndicator.key !== key) {
                stackIndicator = {
                    x: x,
                    index: 0,
                    key: key
                };
            } else {
                stackIndicator.index++;
            }
            /** @type {string} */
            stackIndicator.key = [index, x, stackIndicator.index].join();
            return stackIndicator;
        };
    });
    set(x1, "parts/Dynamics.js", [x1["parts/Globals.js"], x1["parts/Utilities.js"]], function (H, self) {
        var defined = self.defined;
        var erase = self.erase;
        var extend = self.extend;
        var f = self.isArray;
        var isNumber = self.isNumber;
        var isObject = self.isObject;
        var fn = self.isString;
        var _ = self.objectEach;
        var callback = self.pick;
        var w = self.relativeLength;
        var setAnimation = self.setAnimation;
        var $ = self.splat;
        var addEvent = H.addEvent;
        var animate = H.animate;
        var Axis = H.Axis;
        self = H.Chart;
        var createElement = H.createElement;
        var css = H.css;
        var fireEvent = H.fireEvent;
        var merge = H.merge;
        var Point = H.Point;
        var Series = H.Series;
        var seriesTypes = H.seriesTypes;
        /**
         * @param {!Object} data
         * @param {!Object} newData
         * @return {?}
         */
        H.cleanRecursively = function (data, newData) {
            var event = {};
            _(data, function (type, i) {
                if (isObject(data[i], true) && !data.nodeType && newData[i]) {
                    type = H.cleanRecursively(data[i], newData[i]);
                    if (Object.keys(type).length) {
                        /** @type {!Array} */
                        event[i] = type;
                    }
                } else {
                    if (isObject(data[i]) || data[i] !== newData[i]) {
                        event[i] = data[i];
                    }
                }
            });
            return event;
        };
        extend(self.prototype, {
            addSeries: function (options, data, range) {
                var series;
                var chart = this;
                if (options) {
                    data = callback(data, true);
                    fireEvent(chart, "addSeries", {
                        options: options
                    }, function () {
                        series = chart.initSeries(options);
                        /** @type {boolean} */
                        chart.isDirtyLegend = true;
                        chart.linkSeries();
                        if (series.enabledDataSorting) {
                            series.setData(options.data, false);
                        }
                        fireEvent(chart, "afterAddSeries", {
                            series: series
                        });
                        if (data) {
                            chart.redraw(range);
                        }
                    });
                }
                return series;
            },
            addAxis: function (options, isX, redraw, animation) {
                return this.createAxis(isX ? "xAxis" : "yAxis", {
                    axis: options,
                    redraw: redraw,
                    animation: animation
                });
            },
            addColorAxis: function (colors, gradient_type, aniName) {
                return this.createAxis("colorAxis", {
                    axis: colors,
                    redraw: gradient_type,
                    animation: aniName
                });
            },
            createAxis: function (type, options) {
                var opts = this.options;
                /** @type {boolean} */
                var matches = "colorAxis" === type;
                var original = options.redraw;
                var animation = options.animation;
                options = merge(options.axis, {
                    index: this[type].length,
                    isX: "xAxis" === type
                });
                var data = matches ? new H.ColorAxis(this, options) : new Axis(this, options);
                opts[type] = $(opts[type] || {});
                opts[type].push(options);
                if (matches) {
                    /** @type {boolean} */
                    this.isDirtyLegend = true;
                    this.axes.forEach(function (data) {
                        /** @type {!Array} */
                        data.series = [];
                    });
                    this.series.forEach(function (series) {
                        series.bindAxes();
                        /** @type {boolean} */
                        series.isDirtyData = true;
                    });
                }
                if (callback(original, true)) {
                    this.redraw(animation);
                }
                return data;
            },
            showLoading: function (error) {
                var chart = this;
                var options = chart.options;
                var element = chart.loadingDiv;
                var loadingOptions = options.loading;
                /**
                 * @return {undefined}
                 */
                var setLoadingSize = function () {
                    if (element) {
                        css(element, {
                            left: chart.plotLeft + "px",
                            top: chart.plotTop + "px",
                            width: chart.plotWidth + "px",
                            height: chart.plotHeight + "px"
                        });
                    }
                };
                if (!element) {
                    chart.loadingDiv = element = createElement("div", {
                        className: "highcharts-loading highcharts-loading-hidden"
                    }, null, chart.container);
                    chart.loadingSpan = createElement("span", {
                        className: "highcharts-loading-inner"
                    }, null, element);
                    addEvent(chart, "redraw", setLoadingSize);
                }
                /** @type {string} */
                element.className = "highcharts-loading";
                chart.loadingSpan.innerHTML = callback(error, options.lang.loading, "");
                if (!chart.styledMode) {
                    css(element, extend(loadingOptions.style, {
                        zIndex: 10
                    }));
                    css(chart.loadingSpan, loadingOptions.labelStyle);
                    if (!chart.loadingShown) {
                        css(element, {
                            opacity: 0,
                            display: ""
                        });
                        animate(element, {
                            opacity: loadingOptions.style.opacity || .5
                        }, {
                            duration: loadingOptions.showDuration || 0
                        });
                    }
                }
                /** @type {boolean} */
                chart.loadingShown = true;
                setLoadingSize();
            },
            hideLoading: function () {
                var options = this.options;
                var element = this.loadingDiv;
                if (element) {
                    /** @type {string} */
                    element.className = "highcharts-loading highcharts-loading-hidden";
                    if (!this.styledMode) {
                        animate(element, {
                            opacity: 0
                        }, {
                            duration: options.loading.hideDuration || 100,
                            complete: function () {
                                css(element, {
                                    display: "none"
                                });
                            }
                        });
                    }
                }
                /** @type {boolean} */
                this.loadingShown = false;
            },
            propsRequireDirtyBox: "backgroundColor borderColor borderWidth borderRadius plotBackgroundColor plotBackgroundImage plotBorderColor plotBorderWidth plotShadow shadow".split(" "),
            propsRequireReflow: "margin marginTop marginRight marginBottom marginLeft spacing spacingTop spacingRight spacingBottom spacingLeft".split(" "),
            propsRequireUpdateSeries: "chart.inverted chart.polar chart.ignoreHiddenSeries chart.type colors plotOptions time tooltip".split(" "),
            collectionsWithUpdate: ["xAxis", "yAxis", "zAxis", "series"],
            update: function (options, redraw, shift, animation) {
                var chart = this;
                var adders = {
                    credits: "addCredits",
                    title: "setTitle",
                    subtitle: "setSubtitle",
                    caption: "setCaption"
                };
                var data;
                var k;
                var m;
                var readOnlyFn = options.isResponsiveOptions;
                /** @type {!Array} */
                var previewFiles = [];
                fireEvent(chart, "update", {
                    options: options
                });
                if (!readOnlyFn) {
                    chart.setResponsive(false, true);
                }
                options = H.cleanRecursively(options, chart.options);
                merge(true, chart.userOptions, options);
                if (data = options.chart) {
                    merge(true, chart.options.chart, data);
                    if ("className" in data) {
                        chart.setClassName(data.className);
                    }
                    if ("reflow" in data) {
                        chart.setReflow(data.reflow);
                    }
                    if ("inverted" in data || "polar" in data || "type" in data) {
                        chart.propFromSeries();
                        /** @type {boolean} */
                        var newWidth = true;
                    }
                    if ("alignTicks" in data) {
                        /** @type {boolean} */
                        newWidth = true;
                    }
                    _(data, function (a, aSource) {
                        if (-1 !== chart.propsRequireUpdateSeries.indexOf("chart." + aSource)) {
                            /** @type {boolean} */
                            k = true;
                        }
                        if (-1 !== chart.propsRequireDirtyBox.indexOf(aSource)) {
                            /** @type {boolean} */
                            chart.isDirtyBox = true;
                        }
                        if (!(readOnlyFn || -1 === chart.propsRequireReflow.indexOf(aSource))) {
                            /** @type {boolean} */
                            m = true;
                        }
                    });
                    if (!chart.styledMode && "style" in data) {
                        chart.renderer.setStyle(data.style);
                    }
                }
                if (!chart.styledMode && options.colors) {
                    this.options.colors = options.colors;
                }
                if (options.plotOptions) {
                    merge(true, this.options.plotOptions, options.plotOptions);
                }
                if (options.time && this.time === H.time) {
                    this.time = new H.Time(options.time);
                }
                _(options, function (value, key) {
                    if (chart[key] && "function" === typeof chart[key].update) {
                        chart[key].update(value, false);
                    } else {
                        if ("function" === typeof chart[adders[key]]) {
                            chart[adders[key]](value);
                        }
                    }
                    if ("chart" !== key && -1 !== chart.propsRequireUpdateSeries.indexOf(key)) {
                        /** @type {boolean} */
                        k = true;
                    }
                });
                this.collectionsWithUpdate.forEach(function (key) {
                    if (options[key]) {
                        if ("series" === key) {
                            /** @type {!Array} */
                            var results = [];
                            chart[key].forEach(function (item, type) {
                                if (!item.options.isInternal) {
                                    results.push(callback(item.options.index, type));
                                }
                            });
                        }
                        $(options[key]).forEach(function (options, item) {
                            if ((item = defined(options.id) && chart.get(options.id) || chart[key][results ? results[item] : item]) && item.coll === key) {
                                item.update(options, false);
                                if (shift) {
                                    /** @type {boolean} */
                                    item.touched = true;
                                }
                            }
                            if (!item && shift && chart.collectionsWithInit[key]) {
                                /** @type {boolean} */
                                chart.collectionsWithInit[key][0].apply(chart, [options].concat(chart.collectionsWithInit[key][1] || []).concat([false])).touched = true;
                            }
                        });
                        if (shift) {
                            chart[key].forEach(function (item) {
                                if (item.touched || item.options.isInternal) {
                                    delete item.touched;
                                } else {
                                    previewFiles.push(item);
                                }
                            });
                        }
                    }
                });
                previewFiles.forEach(function (inventoryService) {
                    if (inventoryService.remove) {
                        inventoryService.remove(false);
                    }
                });
                if (newWidth) {
                    chart.axes.forEach(function (VTodoService) {
                        VTodoService.update({}, false);
                    });
                }
                if (k) {
                    chart.getSeriesOrderByLinks().forEach(function (box) {
                        if (box.chart) {
                            box.update({}, false);
                        }
                    }, this);
                }
                if (options.loading) {
                    merge(true, chart.options.loading, options.loading);
                }
                newWidth = data && data.width;
                data = data && data.height;
                if (fn(data)) {
                    data = w(data, newWidth || chart.chartWidth);
                }
                if (m || isNumber(newWidth) && newWidth !== chart.chartWidth || isNumber(data) && data !== chart.chartHeight) {
                    chart.setSize(newWidth, data, animation);
                } else {
                    if (callback(redraw, true)) {
                        chart.redraw(animation);
                    }
                }
                fireEvent(chart, "afterUpdate", {
                    options: options,
                    redraw: redraw,
                    animation: animation
                });
            },
            setSubtitle: function (value, count) {
                this.applyDescription("subtitle", value);
                this.layOutTitles(count);
            },
            setCaption: function (isError, errorArg) {
                this.applyDescription("caption", isError);
                this.layOutTitles(errorArg);
            }
        });
        self.prototype.collectionsWithInit = {
            xAxis: [self.prototype.addAxis, [true]],
            yAxis: [self.prototype.addAxis, [false]],
            series: [self.prototype.addSeries]
        };
        extend(Point.prototype, {
            update: function (options, fn, data, c) {
                /**
                 * @return {undefined}
                 */
                function update() {
                    point.applyOptions(options);
                    if (null === point.y && graphic) {
                        point.graphic = graphic.destroy();
                    }
                    if (isObject(options, true)) {
                        if (graphic && graphic.element && options && options.marker && "undefined" !== typeof options.marker.symbol) {
                            point.graphic = graphic.destroy();
                        }
                        if (options && options.dataLabels && point.dataLabel) {
                            point.dataLabel = point.dataLabel.destroy();
                        }
                        if (point.connector) {
                            point.connector = point.connector.destroy();
                        }
                    }
                    i = point.index;
                    series.updateParallelArrays(point, i);
                    seriesOptions.data[i] = isObject(seriesOptions.data[i], true) || isObject(options, true) ? point.options : callback(options, seriesOptions.data[i]);
                    /** @type {boolean} */
                    series.isDirty = series.isDirtyData = true;
                    if (!series.fixedBox && series.hasCartesianSeries) {
                        /** @type {boolean} */
                        chart.isDirtyBox = true;
                    }
                    if ("point" === seriesOptions.legendType) {
                        /** @type {boolean} */
                        chart.isDirtyLegend = true;
                    }
                    if (fn) {
                        chart.redraw(data);
                    }
                }
                var point = this;
                var series = point.series;
                var graphic = point.graphic;
                var i;
                var chart = series.chart;
                var seriesOptions = series.options;
                fn = callback(fn, true);
                if (false === c) {
                    update();
                } else {
                    point.firePointEvent("update", {
                        options: options
                    }, update);
                }
            },
            remove: function (redraw, animation) {
                this.series.removePoint(this.series.data.indexOf(this), redraw, animation);
            }
        });
        extend(Series.prototype, {
            addPoint: function (p, model, index, range, id) {
                var options = this.options;
                var data = this.data;
                var chart = this.chart;
                var xAxis = this.xAxis;
                xAxis = xAxis && xAxis.hasNames && xAxis.names;
                var result = options.data;
                var counts = this.xData;
                var t;
                model = callback(model, true);
                var cur = {
                    series: this
                };
                this.pointClass.prototype.applyOptions.apply(cur, [p]);
                var i = cur.x;
                var n = counts.length;
                if (this.requireSorting && i < counts[n - 1]) {
                    /** @type {boolean} */
                    t = true;
                    for (; n && counts[n - 1] > i;) {
                        n--;
                    }
                }
                this.updateParallelArrays(cur, "splice", n, 0, 0);
                this.updateParallelArrays(cur, n);
                if (xAxis && cur.name) {
                    xAxis[i] = cur.name;
                }
                result.splice(n, 0, p);
                if (t) {
                    this.data.splice(n, 0, null);
                    this.processData();
                }
                if ("point" === options.legendType) {
                    this.generatePoints();
                }
                if (index) {
                    if (data[0] && data[0].remove) {
                        data[0].remove(false);
                    } else {
                        data.shift();
                        this.updateParallelArrays(cur, "shift");
                        result.shift();
                    }
                }
                if (false !== id) {
                    fireEvent(this, "addPoint", {
                        point: cur
                    });
                }
                /** @type {boolean} */
                this.isDirtyData = this.isDirty = true;
                if (model) {
                    chart.redraw(range);
                }
            },
            removePoint: function (i, redraw, animation) {
                var series = this;
                var data = series.data;
                var point = data[i];
                var points = series.points;
                var chart = series.chart;
                /**
                 * @return {undefined}
                 */
                var remove = function () {
                    if (points && points.length === data.length) {
                        points.splice(i, 1);
                    }
                    data.splice(i, 1);
                    series.options.data.splice(i, 1);
                    series.updateParallelArrays(point || {
                        series: series
                    }, "splice", i, 1);
                    if (point) {
                        point.destroy();
                    }
                    /** @type {boolean} */
                    series.isDirty = true;
                    /** @type {boolean} */
                    series.isDirtyData = true;
                    if (redraw) {
                        chart.redraw();
                    }
                };
                setAnimation(animation, chart);
                redraw = callback(redraw, true);
                if (point) {
                    point.firePointEvent("remove", null, remove);
                } else {
                    remove();
                }
            },
            remove: function (annotation, data, skip, f) {
                /**
                 * @return {undefined}
                 */
                function remove() {
                    e.destroy(f);
                    /** @type {null} */
                    e.remove = null;
                    /** @type {boolean} */
                    chart.isDirtyLegend = chart.isDirtyBox = true;
                    chart.linkSeries();
                    if (callback(annotation, true)) {
                        chart.redraw(data);
                    }
                }
                var e = this;
                var chart = e.chart;
                if (false !== skip) {
                    fireEvent(e, "remove", null, remove);
                } else {
                    remove();
                }
            },
            update: function (options, b) {
                options = H.cleanRecursively(options, this.userOptions);
                fireEvent(this, "update", {
                    options: options
                });
                var series = this;
                var chart = series.chart;
                var self = series.userOptions;
                var oldType = series.initialType || series.type;
                var scope = options.type || self.type || chart.options.chart.type;
                /** @type {boolean} */
                var response = !(this.hasDerivedData || options.dataGrouping || scope && scope !== this.type || "undefined" !== typeof options.pointStart || options.pointInterval || options.pointIntervalUnit || options.keys);
                var collection = seriesTypes[oldType].prototype;
                var i;
                /** @type {!Array} */
                var parts = ["group", "markerGroup", "dataLabelsGroup", "transformGroup"];
                /** @type {!Array} */
                var data = ["eventOptions", "navigatorSeries", "baseSeries"];
                var REDSHIFT_OPTIONS = series.finishedAnimating && {
                    animation: false
                };
                var e = {};
                if (response) {
                    data.push("data", "isDirtyData", "points", "processedXData", "processedYData", "xIncrement", "_hasPointMarkers", "_hasPointLabels", "mapMap", "mapData", "minY", "maxY", "minX", "maxX");
                    if (false !== options.visible) {
                        data.push("area", "graph");
                    }
                    series.parallelArrays.forEach(function (name) {
                        data.push(name + "Data");
                    });
                    if (options.data) {
                        if (options.dataSorting) {
                            extend(series.options.dataSorting, options.dataSorting);
                        }
                        this.setData(options.data, false);
                    }
                }
                options = merge(self, REDSHIFT_OPTIONS, {
                    index: "undefined" === typeof self.index ? series.index : self.index,
                    pointStart: callback(self.pointStart, series.xData[0])
                }, !response && {
                    data: series.options.data
                }, options);
                if (response && options.data) {
                    options.data = series.options.data;
                }
                /** @type {!Array<?>} */
                data = parts.concat(data);
                data.forEach(function (i) {
                    data[i] = series[i];
                    delete series[i];
                });
                series.remove(false, null, false, true);
                for (i in collection) {
                    series[i] = void 0;
                }
                if (seriesTypes[scope || oldType]) {
                    extend(series, seriesTypes[scope || oldType].prototype);
                } else {
                    H.error(17, true, chart, {
                        missingModuleFor: scope || oldType
                    });
                }
                data.forEach(function (prop) {
                    series[prop] = data[prop];
                });
                series.init(chart, options);
                if (response && this.points) {
                    var options = series.options;
                    if (false === options.visible) {
                        /** @type {number} */
                        e.graphic = 1;
                        /** @type {number} */
                        e.dataLabel = 1;
                    } else {
                        if (!series._hasPointLabels) {
                            scope = options.marker;
                            collection = options.dataLabels;
                            if (scope && (false === scope.enabled || "symbol" in scope)) {
                                /** @type {number} */
                                e.graphic = 1;
                            }
                            if (collection && false === collection.enabled) {
                                /** @type {number} */
                                e.dataLabel = 1;
                            }
                        }
                    }
                    this.points.forEach(function (point) {
                        if (point && point.series) {
                            point.resolveColor();
                            if (Object.keys(e).length) {
                                point.destroyElements(e);
                            }
                            if (false === options.showInLegend && point.legendItem) {
                                chart.legend.destroyItem(point);
                            }
                        }
                    }, this);
                }
                if (options.zIndex !== self.zIndex) {
                    parts.forEach(function (groupName) {
                        if (series[groupName]) {
                            series[groupName].attr({
                                zIndex: options.zIndex
                            });
                        }
                    });
                }
                series.initialType = oldType;
                chart.linkSeries();
                fireEvent(this, "afterUpdate");
                if (callback(b, true)) {
                    chart.redraw(response ? void 0 : false);
                }
            },
            setName: function (name) {
                this.name = this.options.name = this.userOptions.name = name;
                /** @type {boolean} */
                this.chart.isDirtyLegend = true;
            }
        });
        extend(Axis.prototype, {
            update: function (options, b) {
                var chart = this.chart;
                var events = options && options.events || {};
                options = merge(this.userOptions, options);
                if (chart.options[this.coll].indexOf) {
                    /** @type {!Object} */
                    chart.options[this.coll][chart.options[this.coll].indexOf(this.userOptions)] = options;
                }
                _(chart.options[this.coll].events, function (a, p_type) {
                    if ("undefined" === typeof events[p_type]) {
                        events[p_type] = void 0;
                    }
                });
                this.destroy(true);
                this.init(chart, extend(options, {
                    events: events
                }));
                /** @type {boolean} */
                chart.isDirtyBox = true;
                if (callback(b, true)) {
                    chart.redraw();
                }
            },
            remove: function (a) {
                var chart = this.chart;
                var key = this.coll;
                var axisSeries = this.series;
                var i = axisSeries.length;
                for (; i--;) {
                    if (axisSeries[i]) {
                        axisSeries[i].remove(false);
                    }
                }
                erase(chart.axes, this);
                erase(chart[key], this);
                if (f(chart.options[key])) {
                    chart.options[key].splice(this.options.index, 1);
                } else {
                    delete chart.options[key];
                }
                chart[key].forEach(function (service, len) {
                    service.options.index = service.userOptions.index = len;
                });
                this.destroy();
                /** @type {boolean} */
                chart.isDirtyBox = true;
                if (callback(a, true)) {
                    chart.redraw();
                }
            },
            setTitle: function (value, options) {
                this.update({
                    title: value
                }, options);
            },
            setCategories: function (categories, options) {
                this.update({
                    categories: categories
                }, options);
            }
        });
    });
    set(x1, "parts/AreaSeries.js", [x1["parts/Globals.js"], x1["parts/Utilities.js"]], function (H, seriesType) {
        var each = seriesType.objectEach;
        var pick = seriesType.pick;
        var color = H.color;
        var Series = H.Series;
        seriesType = H.seriesType;
        seriesType("area", "line", {
            softThreshold: false,
            threshold: 0
        }, {
            singleStacks: false,
            getStackPoints: function (points) {
                /** @type {!Array} */
                var segment = [];
                /** @type {!Array} */
                var elements = [];
                var xAxis = this.xAxis;
                var yAxis = this.yAxis;
                var stack = yAxis.stacks[this.stackKey];
                var pointMap = {};
                var index = this.index;
                var s = yAxis.series;
                var end = s.length;
                /** @type {number} */
                var GROUPSIZE = pick(yAxis.options.reversedStacks, true) ? 1 : -1;
                var i;
                points = points || this.points;
                if (this.options.stacking) {
                    /** @type {number} */
                    i = 0;
                    for (; i < points.length; i++) {
                        points[i].leftNull = points[i].rightNull = void 0;
                        pointMap[points[i].x] = points[i];
                    }
                    each(stack, function (saveRoll, cur) {
                        if (null !== saveRoll.total) {
                            elements.push(cur);
                        }
                    });
                    elements.sort(function (b, a) {
                        return b - a;
                    });
                    var pairs = s.map(function (oPresentationNode) {
                        return oPresentationNode.visible;
                    });
                    elements.forEach(function (x, y) {
                        /** @type {number} */
                        var y = 0;
                        var pathSegment;
                        var o;
                        if (pointMap[x] && !pointMap[x].isNull) {
                            segment.push(pointMap[x]);
                            [-1, 1].forEach(function (increment) {
                                /** @type {string} */
                                var nullName = 1 === increment ? "rightNull" : "leftNull";
                                /** @type {number} */
                                var Y4 = 0;
                                var line = stack[elements[y + increment]];
                                if (line) {
                                    i = index;
                                    for (; 0 <= i && i < end;) {
                                        pathSegment = line.points[i];
                                        if (!pathSegment) {
                                            if (i === index) {
                                                /** @type {boolean} */
                                                pointMap[x][nullName] = true;
                                            } else {
                                                if (pairs[i] && (o = stack[x].points[i])) {
                                                    /** @type {number} */
                                                    Y4 = Y4 - (o[1] - o[0]);
                                                }
                                            }
                                        }
                                        i = i + GROUPSIZE;
                                    }
                                }
                                /** @type {number} */
                                pointMap[x][1 === increment ? "rightCliff" : "leftCliff"] = Y4;
                            });
                        } else {
                            i = index;
                            for (; 0 <= i && i < end;) {
                                if (pathSegment = stack[x].points[i]) {
                                    y = pathSegment[1];
                                    break;
                                }
                                i = i + GROUPSIZE;
                            }
                            y = yAxis.translate(y, 0, 1, 0, 1);
                            segment.push({
                                isNull: true,
                                plotX: xAxis.translate(x, 0, 0, 0, 1),
                                x: x,
                                plotY: y,
                                yBottom: y
                            });
                        }
                    });
                }
                return segment;
            },
            getGraphPath: function (points) {
                var getGraphPath = Series.prototype.getGraphPath;
                var options = this.options;
                var stacking = options.stacking;
                var yAxis = this.yAxis;
                var i;
                /** @type {!Array} */
                var bottomPoints = [];
                /** @type {!Array} */
                var graphPoints = [];
                var seriesIndex = this.index;
                var stack = yAxis.stacks[this.stackKey];
                var t = options.threshold;
                /** @type {number} */
                var translatedThreshold = Math.round(yAxis.getThreshold(options.threshold));
                options = pick(options.connectNulls, "percent" === stacking);
                /**
                 * @param {string} i
                 * @param {number} otherI
                 * @param {string} side
                 * @return {undefined}
                 */
                var addDummyPoints = function (i, otherI, side) {
                    var point = points[i];
                    i = stacking && stack[point.x].points[seriesIndex];
                    var none = point[side + "Null"] || 0;
                    side = point[side + "Cliff"] || 0;
                    /** @type {boolean} */
                    point = true;
                    if (side || none) {
                        var left = (none ? i[0] : i[1]) + side;
                        var top = i[0] + side;
                        /** @type {boolean} */
                        point = !!none;
                    } else {
                        if (!stacking && points[otherI] && points[otherI].isNull) {
                            left = top = t;
                        }
                    }
                    if ("undefined" !== typeof left) {
                        graphPoints.push({
                            plotX: plotX,
                            plotY: null === left ? translatedThreshold : yAxis.getThreshold(left),
                            isNull: point,
                            isCliff: true
                        });
                        bottomPoints.push({
                            plotX: plotX,
                            plotY: null === top ? translatedThreshold : yAxis.getThreshold(top),
                            doCurve: false
                        });
                    }
                };
                points = points || this.points;
                if (stacking) {
                    points = this.getStackPoints(points);
                }
                /** @type {number} */
                i = 0;
                for (; i < points.length; i++) {
                    if (!stacking) {
                        points[i].leftCliff = points[i].rightCliff = points[i].leftNull = points[i].rightNull = void 0;
                    }
                    var params = points[i].isNull;
                    var plotX = pick(points[i].rectPlotX, points[i].plotX);
                    var yBottom = pick(points[i].yBottom, translatedThreshold);
                    if (!params || options) {
                        if (!options) {
                            addDummyPoints(i, i - 1, "left");
                        }
                        if (!(params && !stacking && options)) {
                            graphPoints.push(points[i]);
                            bottomPoints.push({
                                x: i,
                                plotX: plotX,
                                plotY: yBottom
                            });
                        }
                        if (!options) {
                            addDummyPoints(i, i + 1, "right");
                        }
                    }
                }
                i = getGraphPath.call(this, graphPoints, true, true);
                /** @type {boolean} */
                bottomPoints.reversed = true;
                params = getGraphPath.call(this, bottomPoints, true, true);
                if (params.length) {
                    /** @type {string} */
                    params[0] = "L";
                }
                params = i.concat(params);
                getGraphPath = getGraphPath.call(this, graphPoints, false, options);
                params.xMap = i.xMap;
                this.areaPath = params;
                return getGraphPath;
            },
            drawGraph: function () {
                /** @type {!Array} */
                this.areaPath = [];
                Series.prototype.drawGraph.apply(this);
                var series = this;
                /** @type {!Array} */
                var areaPath = this.areaPath;
                var o = this.options;
                /** @type {!Array} */
                var failureRecaps = [["area", "highcharts-area", this.color, o.fillColor]];
                this.zones.forEach(function (options, i) {
                    failureRecaps.push(["zone-area-" + i, "highcharts-area highcharts-zone-area-" + i + " " + options.className, options.color || series.color, options.fillColor || o.fillColor]);
                });
                failureRecaps.forEach(function (prop) {
                    var name = prop[0];
                    var area = series[name];
                    /** @type {string} */
                    var method = area ? "animate" : "attr";
                    var point = {};
                    if (area) {
                        area.endX = series.preventGraphAnimation ? null : areaPath.xMap;
                        area.animate({
                            d: areaPath
                        });
                    } else {
                        /** @type {number} */
                        point.zIndex = 0;
                        area = series[name] = series.chart.renderer.path(areaPath).addClass(prop[1]).add(series.group);
                        /** @type {boolean} */
                        area.isArea = true;
                    }
                    if (!series.chart.styledMode) {
                        point.fill = pick(prop[3], color(prop[2]).setOpacity(pick(o.fillOpacity, .75)).get());
                    }
                    area[method](point);
                    area.startX = areaPath.xMap;
                    /** @type {number} */
                    area.shiftUnit = o.step ? 2 : 1;
                });
            },
            drawLegendSymbol: H.LegendSymbolMixin.drawRectangle
        });
        "";
    });
    set(x1, "parts/SplineSeries.js", [x1["parts/Globals.js"], x1["parts/Utilities.js"]], function (seriesType, $stateParams) {
        var pick = $stateParams.pick;
        seriesType = seriesType.seriesType;
        seriesType("spline", "line", {}, {
            getPointSpline: function (e, ret, m) {
                var plotX = ret.plotX;
                var n = ret.plotY;
                var point = e[m - 1];
                m = e[m + 1];
                if (point && !point.isNull && false !== point.doCurve && !ret.isCliff && m && !m.isNull && false !== m.doCurve && !ret.isCliff) {
                    e = point.plotY;
                    var rightContX = m.plotX;
                    m = m.plotY;
                    /** @type {number} */
                    var offset = 0;
                    /** @type {number} */
                    var leftContX = (1.5 * plotX + point.plotX) / 2.5;
                    /** @type {number} */
                    var i = (1.5 * n + e) / 2.5;
                    /** @type {number} */
                    rightContX = (1.5 * plotX + rightContX) / 2.5;
                    /** @type {number} */
                    var j = (1.5 * n + m) / 2.5;
                    if (rightContX !== leftContX) {
                        /** @type {number} */
                        offset = (j - i) * (rightContX - plotX) / (rightContX - leftContX) + n - j;
                    }
                    /** @type {number} */
                    i = i + offset;
                    /** @type {number} */
                    j = j + offset;
                    if (i > e && i > n) {
                        /** @type {number} */
                        i = Math.max(e, n);
                        /** @type {number} */
                        j = 2 * n - i;
                    } else {
                        if (i < e && i < n) {
                            /** @type {number} */
                            i = Math.min(e, n);
                            /** @type {number} */
                            j = 2 * n - i;
                        }
                    }
                    if (j > m && j > n) {
                        /** @type {number} */
                        j = Math.max(m, n);
                        /** @type {number} */
                        i = 2 * n - j;
                    } else {
                        if (j < m && j < n) {
                            /** @type {number} */
                            j = Math.min(m, n);
                            /** @type {number} */
                            i = 2 * n - j;
                        }
                    }
                    /** @type {number} */
                    ret.rightContX = rightContX;
                    /** @type {number} */
                    ret.rightContY = j;
                }
                /** @type {!Array} */
                ret = ["C", pick(point.rightContX, point.plotX), pick(point.rightContY, point.plotY), pick(leftContX, plotX), pick(i, n), plotX, n];
                /** @type {null} */
                point.rightContX = point.rightContY = null;
                return ret;
            }
        });
        "";
    });
    set(x1, "parts/AreaSplineSeries.js", [x1["parts/Globals.js"]], function (H) {
        var areaProto = H.seriesTypes.area.prototype;
        var seriesType = H.seriesType;
        seriesType("areaspline", "spline", H.defaultPlotOptions.area, {
            getStackPoints: areaProto.getStackPoints,
            getGraphPath: areaProto.getGraphPath,
            drawGraph: areaProto.drawGraph,
            drawLegendSymbol: H.LegendSymbolMixin.drawRectangle
        });
        "";
    });
    set(x1, "parts/ColumnSeries.js", [x1["parts/Globals.js"], x1["parts/Utilities.js"]], function (H, seriesType) {
        var animObject = seriesType.animObject;
        var clamp = seriesType.clamp;
        var defined = seriesType.defined;
        var extend = seriesType.extend;
        var isNumber = seriesType.isNumber;
        var pick = seriesType.pick;
        var color = H.color;
        var merge = H.merge;
        var Series = H.Series;
        seriesType = H.seriesType;
        var svg = H.svg;
        seriesType("column", "line", {
            borderRadius: 0,
            crisp: true,
            groupPadding: .2,
            marker: null,
            pointPadding: .1,
            minPointLength: 0,
            cropThreshold: 50,
            pointRange: null,
            states: {
                hover: {
                    halo: false,
                    brightness: .1
                },
                select: {
                    color: "#cccccc",
                    borderColor: "#000000"
                }
            },
            dataLabels: {
                align: null,
                verticalAlign: null,
                y: null
            },
            softThreshold: false,
            startFromThreshold: true,
            stickyTracking: false,
            tooltip: {
                distance: 6
            },
            threshold: 0,
            borderColor: "#ffffff"
        }, {
            cropShoulder: 0,
            directTouch: true,
            trackerGroups: ["group", "dataLabelsGroup"],
            negStacks: true,
            init: function () {
                Series.prototype.init.apply(this, arguments);
                var series = this;
                var chart = series.chart;
                if (chart.hasRendered) {
                    chart.series.forEach(function (item) {
                        if (item.type === series.type) {
                            /** @type {boolean} */
                            item.isDirty = true;
                        }
                    });
                }
            },
            getColumnMetrics: function () {
                var series = this;
                var options = series.options;
                var xAxis = series.xAxis;
                var yAxis = series.yAxis;
                var f = xAxis.options.reversedStacks;
                f = xAxis.reversed && !f || !xAxis.reversed && f;
                var stackKey;
                var stackGroups = {};
                /** @type {number} */
                var columnCount = 0;
                if (false === options.grouping) {
                    /** @type {number} */
                    columnCount = 1;
                } else {
                    series.chart.series.forEach(function (otherSeries) {
                        var otherYAxis = otherSeries.yAxis;
                        var otherOptions = otherSeries.options;
                        if (otherSeries.type === series.type && (otherSeries.visible || !series.chart.options.chart.ignoreHiddenSeries) && yAxis.len === otherYAxis.len && yAxis.pos === otherYAxis.pos) {
                            if (otherOptions.stacking) {
                                stackKey = otherSeries.stackKey;
                                if ("undefined" === typeof stackGroups[stackKey]) {
                                    /** @type {number} */
                                    stackGroups[stackKey] = columnCount++;
                                }
                                var columnIndex = stackGroups[stackKey];
                            } else {
                                if (false !== otherOptions.grouping) {
                                    /** @type {number} */
                                    columnIndex = columnCount++;
                                }
                            }
                            otherSeries.columnIndex = columnIndex;
                        }
                    });
                }
                /** @type {number} */
                var categoryWidth = Math.min(Math.abs(xAxis.transA) * (xAxis.ordinalSlope || options.pointRange || xAxis.closestPointRange || xAxis.tickInterval || 1), xAxis.len);
                /** @type {number} */
                var groupPadding = categoryWidth * options.groupPadding;
                /** @type {number} */
                var pointOffsetWidth = (categoryWidth - 2 * groupPadding) / (columnCount || 1);
                /** @type {number} */
                options = Math.min(options.maxPointWidth || xAxis.len, pick(options.pointWidth, pointOffsetWidth * (1 - 2 * options.pointPadding)));
                series.columnMetrics = {
                    width: options,
                    offset: (pointOffsetWidth - options) / 2 + (groupPadding + ((series.columnIndex || 0) + (f ? 1 : 0)) * pointOffsetWidth - categoryWidth / 2) * (f ? -1 : 1)
                };
                return series.columnMetrics;
            },
            crispCol: function (y, h, x, top) {
                var chart = this.chart;
                var px = this.borderWidth;
                /** @type {number} */
                var offset = -(px % 2 ? .5 : 0);
                /** @type {number} */
                px = px % 2 ? .5 : 1;
                if (chart.inverted && chart.renderer.isVML) {
                    /** @type {number} */
                    px = px + 1;
                }
                if (this.options.crisp) {
                    /** @type {number} */
                    x = Math.round(y + x) + offset;
                    /** @type {number} */
                    y = Math.round(y) + offset;
                    /** @type {number} */
                    x = x - y;
                }
                /** @type {number} */
                top = Math.round(h + top) + px;
                /** @type {boolean} */
                offset = .5 >= Math.abs(h) && .5 < top;
                /** @type {number} */
                h = Math.round(h) + px;
                /** @type {number} */
                top = top - h;
                if (offset && top) {
                    --h;
                    /** @type {number} */
                    top = top + 1;
                }
                return {
                    x: y,
                    y: h,
                    width: x,
                    height: top
                };
            },
            translate: function () {
                var series = this;
                var chart = series.chart;
                var options = series.options;
                /** @type {boolean} */
                var horiz = series.dense = 2 > series.closestPointRange * series.xAxis.transA;
                horiz = series.borderWidth = pick(options.borderWidth, horiz ? 0 : 1);
                var yAxis = series.yAxis;
                var threshold = options.threshold;
                var translatedThreshold = series.translatedThreshold = yAxis.getThreshold(threshold);
                var minPointLength = pick(options.minPointLength, 5);
                var metrics = series.getColumnMetrics();
                var width = metrics.width;
                /** @type {number} */
                var seriesBarW = series.barW = Math.max(width, 1 + 2 * horiz);
                var pointXOffset = series.pointXOffset = metrics.offset;
                var i = series.dataMin;
                var max = series.dataMax;
                if (chart.inverted) {
                    /** @type {number} */
                    translatedThreshold = translatedThreshold - .5;
                }
                if (options.pointPadding) {
                    /** @type {number} */
                    seriesBarW = Math.ceil(seriesBarW);
                }
                Series.prototype.translate.apply(series);
                series.points.forEach(function (point) {
                    var m = pick(point.yBottom, translatedThreshold);
                    /** @type {number} */
                    var d = 999 + Math.abs(m);
                    var pointWidth = width;
                    d = clamp(point.plotY, -d, yAxis.len + d);
                    var barX = point.plotX + pointXOffset;
                    var barW = seriesBarW;
                    /** @type {number} */
                    var barY = Math.min(d, m);
                    /** @type {number} */
                    var barH = Math.max(d, m) - barY;
                    if (minPointLength && Math.abs(barH) < minPointLength) {
                        barH = minPointLength;
                        var up = !yAxis.reversed && !point.negative || yAxis.reversed && point.negative;
                        if (point.y === threshold && series.dataMax <= threshold && yAxis.min < threshold && i !== max) {
                            /** @type {boolean} */
                            up = !up;
                        }
                        /** @type {number} */
                        barY = Math.abs(barY - translatedThreshold) > minPointLength ? m - minPointLength : translatedThreshold - (up ? minPointLength : 0);
                    }
                    if (defined(point.options.pointWidth)) {
                        /** @type {number} */
                        pointWidth = barW = Math.ceil(point.options.pointWidth);
                        /** @type {number} */
                        barX = barX - Math.round((pointWidth - width) / 2);
                    }
                    point.barX = barX;
                    point.pointWidth = pointWidth;
                    /** @type {!Array} */
                    point.tooltipPos = chart.inverted ? [yAxis.len + yAxis.pos - chart.plotLeft - d, series.xAxis.len - barX - barW / 2, barH] : [barX + barW / 2, d + yAxis.pos - chart.plotTop, barH];
                    point.shapeType = series.pointClass.prototype.shapeType || "rect";
                    point.shapeArgs = series.crispCol.apply(series, point.isNull ? [barX, translatedThreshold, barW, 0] : [barX, barY, barW, barH]);
                });
            },
            getSymbol: H.noop,
            drawLegendSymbol: H.LegendSymbolMixin.drawRectangle,
            drawGraph: function () {
                this.group[this.dense ? "addClass" : "removeClass"]("highcharts-dense-data");
            },
            pointAttribs: function (point, state) {
                var options = this.options;
                var p2o = this.pointAttrToOptions || {};
                var attr = p2o.stroke || "borderColor";
                var strokeWidthOption = p2o["stroke-width"] || "borderWidth";
                var fill = point && point.color || this.color;
                var stroke = point && point[attr] || options[attr] || this.color || fill;
                var borderWidth = point && point[strokeWidthOption] || options[strokeWidthOption] || this[strokeWidthOption] || 0;
                p2o = point && point.options.dashStyle || options.dashStyle;
                var opacity = pick(point && point.opacity, options.opacity, 1);
                if (point && this.zones.length) {
                    var options = point.getZone();
                    fill = point.options.color || options && (options.color || point.nonZonedColor) || this.color;
                    if (options) {
                        stroke = options.borderColor || stroke;
                        p2o = options.dashStyle || p2o;
                        borderWidth = options.borderWidth || borderWidth;
                    }
                }
                if (state && point) {
                    point = merge(options.states[state], point.options.states && point.options.states[state] || {});
                    state = point.brightness;
                    fill = point.color || "undefined" !== typeof state && color(fill).brighten(point.brightness).get() || fill;
                    stroke = point[attr] || stroke;
                    borderWidth = point[strokeWidthOption] || borderWidth;
                    p2o = point.dashStyle || p2o;
                    opacity = pick(point.opacity, opacity);
                }
                attr = {
                    fill: fill,
                    stroke: stroke,
                    "stroke-width": borderWidth,
                    opacity: opacity
                };
                if (p2o) {
                    attr.dashstyle = p2o;
                }
                return attr;
            },
            drawPoints: function () {
                var series = this;
                var chart = this.chart;
                var options = series.options;
                var renderer = chart.renderer;
                var animationLimit = options.animationLimit || 250;
                var shapeArgs;
                series.points.forEach(function (point) {
                    var graphic = point.graphic;
                    /** @type {boolean} */
                    var path = !!graphic;
                    /** @type {string} */
                    var verb = graphic && chart.pointCount < animationLimit ? "animate" : "attr";
                    if (isNumber(point.plotY) && null !== point.y) {
                        shapeArgs = point.shapeArgs;
                        if (graphic && point.hasNewShapeType()) {
                            graphic = graphic.destroy();
                        }
                        if (series.enabledDataSorting) {
                            point.startXPos = series.xAxis.reversed ? -(shapeArgs ? shapeArgs.width : 0) : series.xAxis.width;
                        }
                        if (!graphic) {
                            if ((point.graphic = graphic = renderer[point.shapeType](shapeArgs).add(point.group || series.group)) && series.enabledDataSorting && chart.hasRendered && chart.pointCount < animationLimit) {
                                graphic.attr({
                                    x: point.startXPos
                                });
                                /** @type {boolean} */
                                path = true;
                                /** @type {string} */
                                verb = "animate";
                            }
                        }
                        if (graphic && path) {
                            graphic[verb](merge(shapeArgs));
                        }
                        if (options.borderRadius) {
                            graphic[verb]({
                                r: options.borderRadius
                            });
                        }
                        if (!chart.styledMode) {
                            graphic[verb](series.pointAttribs(point, point.selected && "select")).shadow(false !== point.allowShadow && options.shadow, null, options.stacking && !options.borderRadius);
                        }
                        graphic.addClass(point.getClassName(), true);
                    } else {
                        if (graphic) {
                            point.graphic = graphic.destroy();
                        }
                    }
                });
            },
            animate: function (value) {
                var series = this;
                var yAxis = this.yAxis;
                var options = series.options;
                var inverted = this.chart.inverted;
                var data = {};
                /** @type {string} */
                var i = inverted ? "translateX" : "translateY";
                if (svg) {
                    if (value) {
                        /** @type {number} */
                        data.scaleY = .001;
                        value = clamp(yAxis.toPixels(options.threshold), yAxis.pos, yAxis.pos + yAxis.len);
                        if (inverted) {
                            /** @type {number} */
                            data.translateX = value - yAxis.len;
                        } else {
                            /** @type {number} */
                            data.translateY = value;
                        }
                        if (series.clipBox) {
                            series.setClip();
                        }
                        series.group.attr(data);
                    } else {
                        var r = series.group.attr(i);
                        series.group.animate({
                            scaleY: 1
                        }, extend(animObject(series.options.animation), {
                            step: function (key, x) {
                                data[i] = r + x.pos * (yAxis.pos - r);
                                series.group.attr(data);
                            }
                        }));
                        /** @type {null} */
                        series.animate = null;
                    }
                }
            },
            remove: function () {
                var series = this;
                var chart = series.chart;
                if (chart.hasRendered) {
                    chart.series.forEach(function (item) {
                        if (item.type === series.type) {
                            /** @type {boolean} */
                            item.isDirty = true;
                        }
                    });
                }
                Series.prototype.remove.apply(series, arguments);
            }
        });
        "";
    });
    set(x1, "parts/BarSeries.js", [x1["parts/Globals.js"]], function (seriesType) {
        seriesType = seriesType.seriesType;
        seriesType("bar", "column", null, {
            inverted: true
        });
        "";
    });
    set(x1, "parts/ScatterSeries.js", [x1["parts/Globals.js"]], function (H) {
        var div = H.Series;
        var seriesType = H.seriesType;
        seriesType("scatter", "line", {
            lineWidth: 0,
            findNearestPointBy: "xy",
            jitter: {
                x: 0,
                y: 0
            },
            marker: {
                enabled: true
            },
            tooltip: {
                headerFormat: '<span style="color:{point.color}">\u25cf</span> <span style="font-size: 10px"> {series.name}</span><br/>',
                pointFormat: "x: <b>{point.x}</b><br/>y: <b>{point.y}</b><br/>"
            }
        }, {
            sorted: false,
            requireSorting: false,
            noSharedTooltip: true,
            trackerGroups: ["group", "markerGroup", "dataLabelsGroup"],
            takeOrdinalPosition: false,
            drawGraph: function () {
                if (this.options.lineWidth) {
                    div.prototype.drawGraph.call(this);
                }
            },
            applyJitter: function () {
                var item = this;
                var levels = this.options.jitter;
                var length = this.points.length;
                if (levels) {
                    this.points.forEach(function (point, y1) {
                        ["x", "y"].forEach(function (k, t) {
                            var i = "plot" + k.toUpperCase();
                            if (levels[k] && !point.isNull) {
                                var data = item[k + "Axis"];
                                /** @type {number} */
                                var x = levels[k] * data.transA;
                                if (data && !data.isLog) {
                                    /** @type {number} */
                                    var min = Math.max(0, point[i] - x);
                                    /** @type {number} */
                                    data = Math.min(data.len, point[i] + x);
                                    /** @type {number} */
                                    t = 1E4 * Math.sin(y1 + t * length);
                                    /** @type {number} */
                                    point[i] = min + (data - min) * (t - Math.floor(t));
                                    if ("x" === k) {
                                        point.clientX = point.plotX;
                                    }
                                }
                            }
                        });
                    });
                }
            }
        });
        H.addEvent(div, "afterTranslate", function () {
            if (this.applyJitter) {
                this.applyJitter();
            }
        });
        "";
    });
    set(x1, "mixins/centered-series.js", [x1["parts/Globals.js"], x1["parts/Utilities.js"]], function (H, _) {
        var isNumber = _.isNumber;
        var pick = _.pick;
        var relativeLength = _.relativeLength;
        var i = H.deg2rad;
        H.CenteredSeriesMixin = {
            getCenter: function () {
                var options = this.options;
                var b = this.chart;
                /** @type {number} */
                var slicingRoom = 2 * (options.slicedOffset || 0);
                /** @type {number} */
                var a = b.plotWidth - 2 * slicingRoom;
                /** @type {number} */
                b = b.plotHeight - 2 * slicingRoom;
                var point = options.center;
                /** @type {!Array} */
                point = [pick(point[0], "50%"), pick(point[1], "50%"), options.size || "100%", options.innerSize || 0];
                /** @type {number} */
                var c = Math.min(a, b);
                var i;
                /** @type {number} */
                i = 0;
                for (; 4 > i; ++i) {
                    var value = point[i];
                    /** @type {boolean} */
                    options = 2 > i || 2 === i && /%$/.test(value);
                    point[i] = relativeLength(value, [a, b, c, point[2]][i]) + (options ? slicingRoom : 0);
                }
                if (point[3] > point[2]) {
                    point[3] = point[2];
                }
                return point;
            },
            getStartAndEndRadians: function (val, n) {
                val = isNumber(val) ? val : 0;
                n = isNumber(n) && n > val && 360 > n - val ? n : val + 360;
                return {
                    start: i * (val + -90),
                    end: i * (n + -90)
                };
            }
        };
    });
    set(x1, "parts/PieSeries.js", [x1["parts/Globals.js"], x1["parts/Utilities.js"]], function (H, _) {
        var clamp = _.clamp;
        var isArray = _.defined;
        var isNumber = _.isNumber;
        var pick = _.pick;
        var merge = _.relativeLength;
        var toArray = _.setAnimation;
        var addEvent = H.addEvent;
        _ = H.CenteredSeriesMixin;
        var parseHotspotString = _.getStartAndEndRadians;
        var u = H.merge;
        var noop = H.noop;
        var Point = H.Point;
        var Series = H.Series;
        var seriesType = H.seriesType;
        var stableSort = H.fireEvent;
        seriesType("pie", "line", {
            center: [null, null],
            clip: false,
            colorByPoint: true,
            dataLabels: {
                allowOverlap: true,
                connectorPadding: 5,
                connectorShape: "fixedOffset",
                crookDistance: "70%",
                distance: 30,
                enabled: true,
                formatter: function () {
                    return this.point.isNull ? void 0 : this.point.name;
                },
                softConnector: true,
                x: 0
            },
            fillColor: void 0,
            ignoreHiddenPoint: true,
            inactiveOtherPoints: true,
            legendType: "point",
            marker: null,
            size: null,
            showInLegend: false,
            slicedOffset: 10,
            stickyTracking: false,
            tooltip: {
                followPointer: true
            },
            borderColor: "#ffffff",
            borderWidth: 1,
            lineWidth: void 0,
            states: {
                hover: {
                    brightness: .1
                }
            }
        }, {
            isCartesian: false,
            requireSorting: false,
            directTouch: true,
            noSharedTooltip: true,
            trackerGroups: ["group", "dataLabelsGroup"],
            axisTypes: [],
            pointAttribs: H.seriesTypes.column.prototype.pointAttribs,
            animate: function (object) {
                var series = this;
                var points = series.points;
                var startAngleRad = series.startAngleRad;
                if (!object) {
                    points.forEach(function (point) {
                        var graphic = point.graphic;
                        var shapeArgs = point.shapeArgs;
                        if (graphic && shapeArgs) {
                            graphic.attr({
                                r: pick(point.startR, series.center && series.center[3] / 2),
                                start: startAngleRad,
                                end: startAngleRad
                            });
                            graphic.animate({
                                r: shapeArgs.r,
                                start: shapeArgs.start,
                                end: shapeArgs.end
                            }, series.options.animation);
                        }
                    });
                    /** @type {null} */
                    series.animate = null;
                }
            },
            hasData: function () {
                return !!this.processedXData.length;
            },
            updateTotals: function () {
                var i;
                /** @type {number} */
                var total = 0;
                var points = this.points;
                var numPts = points.length;
                var ignoreHiddenPoint = this.options.ignoreHiddenPoint;
                /** @type {number} */
                i = 0;
                for (; i < numPts; i++) {
                    var point = points[i];
                    total = total + (ignoreHiddenPoint && !point.visible ? 0 : point.isNull ? 0 : point.y);
                }
                this.total = total;
                /** @type {number} */
                i = 0;
                for (; i < numPts; i++) {
                    point = points[i];
                    /** @type {number} */
                    point.percentage = 0 < total && (point.visible || !ignoreHiddenPoint) ? point.y / total * 100 : 0;
                    point.total = total;
                }
            },
            generatePoints: function () {
                Series.prototype.generatePoints.call(this);
                this.updateTotals();
            },
            getX: function (y, matrix, point) {
                var center = this.center;
                var radius = this.radii ? this.radii[point.index] : center[2] / 2;
                /** @type {number} */
                y = Math.asin(clamp((y - center[1]) / (radius + point.labelDistance), -1, 1));
                return center[0] + (matrix ? -1 : 1) * Math.cos(y) * (radius + point.labelDistance) + (0 < point.labelDistance ? (matrix ? -1 : 1) * this.options.dataLabels.padding : 0);
            },
            translate: function (value) {
                this.generatePoints();
                /** @type {number} */
                var b = 0;
                var options = this.options;
                var slicedOffset = options.slicedOffset;
                var position = slicedOffset + (options.borderWidth || 0);
                var c = parseHotspotString(options.startAngle, options.endAngle);
                var a = this.startAngleRad = c.start;
                /** @type {number} */
                c = (this.endAngleRad = c.end) - a;
                var points = this.points;
                var labelDistance = options.dataLabels.distance;
                options = options.ignoreHiddenPoint;
                var i;
                var numPts = points.length;
                if (!value) {
                    this.center = value = this.getCenter();
                }
                /** @type {number} */
                i = 0;
                for (; i < numPts; i++) {
                    var point = points[i];
                    var x = a + b * c;
                    if (!options || point.visible) {
                        /** @type {number} */
                        b = b + point.percentage / 100;
                    }
                    var angle = a + b * c;
                    /** @type {string} */
                    point.shapeType = "arc";
                    point.shapeArgs = {
                        x: value[0],
                        y: value[1],
                        r: value[2] / 2,
                        innerR: value[3] / 2,
                        start: Math.round(1E3 * x) / 1E3,
                        end: Math.round(1E3 * angle) / 1E3
                    };
                    point.labelDistance = pick(point.options.dataLabels && point.options.dataLabels.distance, labelDistance);
                    point.labelDistance = merge(point.labelDistance, point.shapeArgs.r);
                    /** @type {number} */
                    this.maxLabelDistance = Math.max(this.maxLabelDistance || 0, point.labelDistance);
                    /** @type {number} */
                    angle = (angle + x) / 2;
                    if (angle > 1.5 * Math.PI) {
                        /** @type {number} */
                        angle = angle - 2 * Math.PI;
                    } else {
                        if (angle < -Math.PI / 2) {
                            /** @type {number} */
                            angle = angle + 2 * Math.PI;
                        }
                    }
                    point.slicedTranslation = {
                        translateX: Math.round(Math.cos(angle) * slicedOffset),
                        translateY: Math.round(Math.sin(angle) * slicedOffset)
                    };
                    /** @type {number} */
                    var px = Math.cos(angle) * value[2] / 2;
                    /** @type {number} */
                    var Gb = Math.sin(angle) * value[2] / 2;
                    /** @type {!Array} */
                    point.tooltipPos = [value[0] + .7 * px, value[1] + .7 * Gb];
                    /** @type {number} */
                    point.half = angle < -Math.PI / 2 || angle > Math.PI / 2 ? 1 : 0;
                    /** @type {number} */
                    point.angle = angle;
                    /** @type {number} */
                    x = Math.min(position, point.labelDistance / 5);
                    point.labelPosition = {
                        natural: {
                            x: value[0] + px + Math.cos(angle) * point.labelDistance,
                            y: value[1] + Gb + Math.sin(angle) * point.labelDistance
                        },
                        "final": {},
                        alignment: 0 > point.labelDistance ? "center" : point.half ? "right" : "left",
                        connectorPosition: {
                            breakAt: {
                                x: value[0] + px + Math.cos(angle) * x,
                                y: value[1] + Gb + Math.sin(angle) * x
                            },
                            touchingSliceAt: {
                                x: value[0] + px,
                                y: value[1] + Gb
                            }
                        }
                    };
                }
                stableSort(this, "afterTranslate");
            },
            drawEmpty: function () {
                var options = this.options;
                if (0 === this.total) {
                    var x = this.center[0];
                    var _y = this.center[1];
                    if (!this.graph) {
                        this.graph = this.chart.renderer.circle(x, _y, 0).addClass("highcharts-graph").add(this.group);
                    }
                    this.graph.animate({
                        "stroke-width": options.borderWidth,
                        cx: x,
                        cy: _y,
                        r: this.center[2] / 2,
                        fill: options.fillColor || "none",
                        stroke: options.color || "#cccccc"
                    });
                } else {
                    if (this.graph) {
                        this.graph = this.graph.destroy();
                    }
                }
            },
            redrawPoints: function () {
                var series = this;
                var chart = series.chart;
                var renderer = chart.renderer;
                var r;
                var graphic;
                var i;
                var a;
                var shadow = series.options.shadow;
                this.drawEmpty();
                if (!(!shadow || series.shadowGroup || chart.styledMode)) {
                    series.shadowGroup = renderer.g("shadow").attr({
                        zIndex: -1
                    }).add(series.group);
                }
                series.points.forEach(function (point) {
                    var node = {};
                    graphic = point.graphic;
                    if (!point.isNull && graphic) {
                        a = point.shapeArgs;
                        r = point.getTranslate();
                        if (!chart.styledMode) {
                            var shadowGroup = point.shadowGroup;
                            if (shadow && !shadowGroup) {
                                shadowGroup = point.shadowGroup = renderer.g("shadow").add(series.shadowGroup);
                            }
                            if (shadowGroup) {
                                shadowGroup.attr(r);
                            }
                            i = series.pointAttribs(point, point.selected && "select");
                        }
                        if (point.delayedRendering) {
                            graphic.setRadialReference(series.center).attr(a).attr(r);
                            if (!chart.styledMode) {
                                graphic.attr(i).attr({
                                    "stroke-linejoin": "round"
                                }).shadow(shadow, shadowGroup);
                            }
                            /** @type {boolean} */
                            point.delayedRendering = false;
                        } else {
                            graphic.setRadialReference(series.center);
                            if (!chart.styledMode) {
                                u(true, node, i);
                            }
                            u(true, node, a, r);
                            graphic.animate(node);
                        }
                        graphic.attr({
                            visibility: point.visible ? "inherit" : "hidden"
                        });
                        graphic.addClass(point.getClassName());
                    } else {
                        if (graphic) {
                            point.graphic = graphic.destroy();
                        }
                    }
                });
            },
            drawPoints: function () {
                var renderer = this.chart.renderer;
                this.points.forEach(function (point) {
                    if (!point.graphic) {
                        point.graphic = renderer[point.shapeType](point.shapeArgs).add(point.series.group);
                        /** @type {boolean} */
                        point.delayedRendering = true;
                    }
                });
            },
            searchPoint: noop,
            sortByAngle: function (a, b) {
                a.sort(function (elem2, elem1) {
                    return "undefined" !== typeof elem2.angle && (elem1.angle - elem2.angle) * b;
                });
            },
            drawLegendSymbol: H.LegendSymbolMixin.drawRectangle,
            getCenter: _.getCenter,
            getSymbol: noop,
            drawGraph: null
        }, {
            init: function () {
                Point.prototype.init.apply(this, arguments);
                var point = this;
                point.name = pick(point.name, "Slice");
                /**
                 * @param {!Object} data
                 * @return {undefined}
                 */
                var updateCounter = function (data) {
                    point.slice("select" === data.type);
                };
                addEvent(point, "select", updateCounter);
                addEvent(point, "unselect", updateCounter);
                return point;
            },
            isValid: function () {
                return isNumber(this.y) && 0 <= this.y;
            },
            setVisible: function (vis, redraw) {
                var point = this;
                var series = point.series;
                var chart = series.chart;
                var ignoreHiddenPoint = series.options.ignoreHiddenPoint;
                redraw = pick(redraw, ignoreHiddenPoint);
                if (vis !== point.visible) {
                    point.visible = point.options.visible = vis = "undefined" === typeof vis ? !point.visible : vis;
                    series.options.data[series.data.indexOf(point)] = point.options;
                    ["graphic", "dataLabel", "connector", "shadowGroup"].forEach(function (key) {
                        if (point[key]) {
                            point[key][vis ? "show" : "hide"](true);
                        }
                    });
                    if (point.legendItem) {
                        chart.legend.colorizeItem(point, vis);
                    }
                    if (!(vis || "hover" !== point.state)) {
                        point.setState("");
                    }
                    if (ignoreHiddenPoint) {
                        /** @type {boolean} */
                        series.isDirty = true;
                    }
                    if (redraw) {
                        chart.redraw();
                    }
                }
            },
            slice: function (a, b, start) {
                var series = this.series;
                toArray(start, series.chart);
                pick(b, true);
                this.sliced = this.options.sliced = isArray(a) ? a : !this.sliced;
                series.options.data[series.data.indexOf(this)] = this.options;
                this.graphic.animate(this.getTranslate());
                if (this.shadowGroup) {
                    this.shadowGroup.animate(this.getTranslate());
                }
            },
            getTranslate: function () {
                return this.sliced ? this.slicedTranslation : {
                    translateX: 0,
                    translateY: 0
                };
            },
            haloPath: function (key) {
                var b = this.shapeArgs;
                return this.sliced || !this.visible ? [] : this.series.chart.renderer.symbols.arc(b.x, b.y, b.r + key, b.r + key, {
                    innerR: b.r - 1,
                    start: b.start,
                    end: b.end
                });
            },
            connectorShapes: {
                fixedOffset: function (style, options, suggestedVariableValueCallback) {
                    var d = options.breakAt;
                    options = options.touchingSliceAt;
                    return ["M", style.x, style.y].concat(suggestedVariableValueCallback.softConnector ? ["C", style.x + ("left" === style.alignment ? -5 : 5), style.y, 2 * d.x - options.x, 2 * d.y - options.y, d.x, d.y] : ["L", d.x, d.y]).concat(["L", options.x, options.y]);
                },
                straight: function (i, dx) {
                    dx = dx.touchingSliceAt;
                    return ["M", i.x, i.y, "L", dx.x, dx.y];
                },
                crookedLine: function (s, b, a) {
                    b = b.touchingSliceAt;
                    var tooltip = this.series;
                    var n = tooltip.center[0];
                    var i = tooltip.chart.plotWidth;
                    var x = tooltip.chart.plotLeft;
                    tooltip = s.alignment;
                    var d = this.shapeArgs.r;
                    a = merge(a.crookDistance, 1);
                    a = "left" === tooltip ? n + d + (i + x - n - d) * (1 - a) : x + (n - d) * a;
                    /** @type {!Array} */
                    n = ["L", a, s.y];
                    if ("left" === tooltip ? a > s.x || a < b.x : a < s.x || a > b.x) {
                        /** @type {!Array} */
                        n = [];
                    }
                    return ["M", s.x, s.y].concat(n).concat(["L", b.x, b.y]);
                }
            },
            getConnectorPath: function () {
                var options = this.labelPosition;
                var scope = this.series.options.dataLabels;
                var util = scope.connectorShape;
                var testModule = this.connectorShapes;
                if (testModule[util]) {
                    util = testModule[util];
                }
                return util.call(this, {
                    x: options.final.x,
                    y: options.final.y,
                    alignment: options.alignment
                }, options.connectorPosition, scope);
            }
        });
        "";
    });
    set(x1, "parts/DataLabels.js", [x1["parts/Globals.js"], x1["parts/Utilities.js"]], function (Highcharts, H) {
        var animObject = H.animObject;
        var arrayMax = H.arrayMax;
        var map = H.clamp;
        var defined = H.defined;
        var extend = H.extend;
        var isObject = H.isArray;
        var objectEach = H.objectEach;
        var pick = H.pick;
        var relativeLength = H.relativeLength;
        var each = H.splat;
        var createElement = Highcharts.format;
        var merge = Highcharts.merge;
        H = Highcharts.noop;
        var Series = Highcharts.Series;
        var seriesTypes = Highcharts.seriesTypes;
        var find = Highcharts.stableSort;
        /**
         * @param {!Object} value
         * @param {number} len
         * @param {number} callback
         * @return {undefined}
         */
        Highcharts.distribute = function (value, len, callback) {
            /**
             * @param {!Event} a
             * @param {!Event} b
             * @return {?}
             */
            function sortByTarget(a, b) {
                return a.target - b.target;
            }
            var i;
            /** @type {boolean} */
            var options = true;
            /** @type {!Object} */
            var obj = value;
            /** @type {!Array} */
            var searchPipeline = [];
            /** @type {number} */
            var count = 0;
            var end = obj.reducedLen || len;
            i = value.length;
            for (; i--;) {
                count = count + value[i].size;
            }
            if (count > end) {
                find(value, function (awesomeThing, rankObject) {
                    return (rankObject.rank || 0) - (awesomeThing.rank || 0);
                });
                /** @type {number} */
                count = i = 0;
                for (; count <= end;) {
                    count = count + value[i].size;
                    i++;
                }
                searchPipeline = value.splice(i - 1, value.length);
            }
            find(value, sortByTarget);
            value = value.map(function (options) {
                return {
                    size: options.size,
                    targets: [options.target],
                    align: pick(options.align, .5)
                };
            });
            for (; options;) {
                i = value.length;
                for (; i--;) {
                    options = value[i];
                    /** @type {number} */
                    count = (Math.min.apply(0, options.targets) + Math.max.apply(0, options.targets)) / 2;
                    options.pos = map(count - options.size * options.align, 0, len - options.size);
                }
                i = value.length;
                /** @type {boolean} */
                options = false;
                for (; i--;) {
                    if (0 < i && value[i - 1].pos + value[i - 1].size > value[i].pos) {
                        value[i - 1].size += value[i].size;
                        value[i - 1].targets = value[i - 1].targets.concat(value[i].targets);
                        /** @type {number} */
                        value[i - 1].align = .5;
                        if (value[i - 1].pos + value[i - 1].size > len) {
                            /** @type {number} */
                            value[i - 1].pos = len - value[i - 1].size;
                        }
                        value.splice(i, 1);
                        /** @type {boolean} */
                        options = true;
                    }
                }
            }
            obj.push.apply(obj, searchPipeline);
            /** @type {number} */
            i = 0;
            value.some(function (self) {
                /** @type {number} */
                var start = 0;
                if (self.targets.some(function () {
                    obj[i].pos = self.pos + start;
                    if (Math.abs(obj[i].pos - obj[i].target) > callback) {
                        return obj.slice(0, i + 1).forEach(function (subsynset) {
                            delete subsynset.pos;
                        }), obj.reducedLen = (obj.reducedLen || len) - .1 * len, obj.reducedLen > .1 * len && Highcharts.distribute(obj, len, callback), true;
                    }
                    start = start + obj[i].size;
                    i++;
                })) {
                    return true;
                }
            });
            find(obj, sortByTarget);
        };
        /**
         * @return {undefined}
         */
        Series.prototype.drawDataLabels = function () {
            /**
             * @param {number} value
             * @param {!Object} number
             * @return {?}
             */
            function _collectLinesWithStringLiterals(value, number) {
                var i = number.filter;
                return i ? (number = i.operator, value = value[i.property], i = i.value, ">" === number && value > i || "<" === number && value < i || ">=" === number && value >= i || "<=" === number && value <= i || "==" === number && value == i || "===" === number && value === i ? true : false) : true;
            }
            /**
             * @param {!Array} a
             * @param {!Array} b
             * @return {?}
             */
            function merge(a, b) {
                /** @type {!Array} */
                var output = [];
                var key;
                if (isObject(a) && !isObject(b)) {
                    output = a.map(function (to_prototype) {
                        return merge(to_prototype, b);
                    });
                } else {
                    if (isObject(b) && !isObject(a)) {
                        output = b.map(function (rawUpdate) {
                            return merge(a, rawUpdate);
                        });
                    } else {
                        if (isObject(a) || isObject(b)) {
                            /** @type {number} */
                            key = Math.max(a.length, b.length);
                            for (; key--;) {
                                output[key] = merge(a[key], b[key]);
                            }
                        } else {
                            output = merge(a, b);
                        }
                    }
                }
                return output;
            }
            var series = this;
            var data = series.chart;
            var seriesOptions = series.options;
            var options = seriesOptions.dataLabels;
            var points = series.points;
            var jsAssets;
            var hasRendered = series.hasRendered || 0;
            var d = animObject(seriesOptions.animation).duration;
            /** @type {number} */
            var time = Math.min(d, 200);
            var defer = !data.renderer.forExport && pick(options.defer, 0 < time);
            var renderer = data.renderer;
            options = merge(merge(data.options.plotOptions && data.options.plotOptions.series && data.options.plotOptions.series.dataLabels, data.options.plotOptions && data.options.plotOptions[series.type] && data.options.plotOptions[series.type].dataLabels), options);
            Highcharts.fireEvent(this, "drawDataLabels");
            if (isObject(options) || options.enabled || series._hasPointLabels) {
                var n = series.plotGroup("dataLabelsGroup", "data-labels", defer && !hasRendered ? "hidden" : "inherit", options.zIndex || 6);
                if (defer) {
                    n.attr({
                        opacity: +hasRendered
                    });
                    if (!hasRendered) {
                        setTimeout(function () {
                            var dataLabelsGroup = series.dataLabelsGroup;
                            if (dataLabelsGroup) {
                                if (series.visible) {
                                    n.show(true);
                                }
                                dataLabelsGroup[seriesOptions.animation ? "animate" : "attr"]({
                                    opacity: 1
                                }, {
                                    duration: time
                                });
                            }
                        }, d - time);
                    }
                }
                points.forEach(function (point) {
                    jsAssets = each(merge(options, point.dlOptions || point.options && point.options.dataLabels));
                    jsAssets.forEach(function (options, i) {
                        var uniformChanged = options.enabled && (!point.isNull || point.dataLabelOnNull) && _collectLinesWithStringLiterals(point, options);
                        var e = point.dataLabels ? point.dataLabels[i] : point.dataLabel;
                        var p = point.connectors ? point.connectors[i] : point.connector;
                        var width = pick(options.distance, point.labelDistance);
                        /** @type {boolean} */
                        var isNew = !e;
                        if (uniformChanged) {
                            var value = point.getLabelConfig();
                            var style = pick(options[point.formatPrefix + "Format"], options.format);
                            value = defined(style) ? createElement(style, value, data) : (options[point.formatPrefix + "Formatter"] || options.formatter).call(value, options);
                            style = options.style;
                            var rotation = options.rotation;
                            if (!data.styledMode) {
                                style.color = pick(options.color, style.color, series.color, "#000000");
                                if ("contrast" === style.color) {
                                    point.contrastColor = renderer.getContrast(point.color || series.color);
                                    style.color = !defined(width) && options.inside || 0 > width || seriesOptions.stacking ? point.contrastColor : "#000000";
                                } else {
                                    delete point.contrastColor;
                                }
                                if (seriesOptions.cursor) {
                                    style.cursor = seriesOptions.cursor;
                                }
                            }
                            var styles = {
                                r: options.borderRadius || 0,
                                rotation: rotation,
                                padding: options.padding,
                                zIndex: 1
                            };
                            if (!data.styledMode) {
                                styles.fill = options.backgroundColor;
                                styles.stroke = options.borderColor;
                                styles["stroke-width"] = options.borderWidth;
                            }
                            objectEach(styles, function (isOnlyTutorial, s) {
                                if ("undefined" === typeof isOnlyTutorial) {
                                    delete styles[s];
                                }
                            });
                        }
                        if (!e || uniformChanged && defined(value)) {
                            if (uniformChanged && defined(value)) {
                                if (e) {
                                    styles.text = value;
                                } else {
                                    point.dataLabels = point.dataLabels || [];
                                    e = point.dataLabels[i] = rotation ? renderer.text(value, 0, -9999).addClass("highcharts-data-label") : renderer.label(value, 0, -9999, options.shape, null, null, options.useHTML, null, "data-label");
                                    if (!i) {
                                        point.dataLabel = e;
                                    }
                                    e.addClass(" highcharts-data-label-color-" + point.colorIndex + " " + (options.className || "") + (options.useHTML ? " highcharts-tracker" : ""));
                                }
                                /** @type {!Object} */
                                e.options = options;
                                e.attr(styles);
                                if (!data.styledMode) {
                                    e.css(style).shadow(options.shadow);
                                }
                                if (!e.added) {
                                    e.add(n);
                                }
                                if (options.textPath && !options.useHTML) {
                                    e.setTextPath(point.getDataLabelPath && point.getDataLabelPath(e) || point.graphic, options.textPath);
                                    if (point.dataLabelPath && !options.textPath.enabled) {
                                        point.dataLabelPath = point.dataLabelPath.destroy();
                                    }
                                }
                                series.alignDataLabel(point, e, options, null, isNew);
                            }
                        } else {
                            point.dataLabel = point.dataLabel && point.dataLabel.destroy();
                            if (point.dataLabels) {
                                if (1 === point.dataLabels.length) {
                                    delete point.dataLabels;
                                } else {
                                    delete point.dataLabels[i];
                                }
                            }
                            if (!i) {
                                delete point.dataLabel;
                            }
                            if (p) {
                                point.connector = point.connector.destroy();
                                if (point.connectors) {
                                    if (1 === point.connectors.length) {
                                        delete point.connectors;
                                    } else {
                                        delete point.connectors[i];
                                    }
                                }
                            }
                        }
                    });
                });
            }
            Highcharts.fireEvent(this, "afterDrawDataLabels");
        };
        /**
         * @param {number} point
         * @param {!Object} dataLabel
         * @param {!Object} options
         * @param {!Object} data
         * @param {boolean} isNew
         * @return {undefined}
         */
        Series.prototype.alignDataLabel = function (point, dataLabel, options, data, isNew) {
            var series = this;
            var chart = this.chart;
            var inverted = this.isCartesian && chart.inverted;
            var emailCase = this.enabledDataSorting;
            var alignAttr = pick(point.dlBox && point.dlBox.centerX, point.plotX, -9999);
            var plotY = pick(point.plotY, -9999);
            var bBox = dataLabel.getBBox();
            var rotation = options.rotation;
            var align = options.align;
            var list = chart.isInsidePlot(alignAttr, Math.round(plotY), inverted);
            /** @type {boolean} */
            var emailCaseToDelete = "justify" === pick(options.overflow, emailCase ? "none" : "justify");
            var visible = this.visible && (point.series.forceDL || emailCase && !emailCaseToDelete || list || data && chart.isInsidePlot(alignAttr, inverted ? data.x + 1 : data.y + data.height - 1, inverted));
            /**
             * @param {!Object} id
             * @return {undefined}
             */
            var negRotation = function (id) {
                if (emailCase && series.xAxis && !emailCaseToDelete) {
                    series.setDataLabelStartPos(point, dataLabel, isNew, list, id);
                }
            };
            if (visible) {
                var baseline = chart.renderer.fontMetrics(chart.styledMode ? void 0 : options.style.fontSize, dataLabel).b;
                data = extend({
                    x: inverted ? this.yAxis.len - plotY : alignAttr,
                    y: Math.round(inverted ? this.xAxis.len - alignAttr : plotY),
                    width: 0,
                    height: 0
                }, data);
                extend(options, {
                    width: bBox.width,
                    height: bBox.height
                });
                if (rotation) {
                    /** @type {boolean} */
                    emailCaseToDelete = false;
                    alignAttr = chart.renderer.rotCorr(baseline, rotation);
                    alignAttr = {
                        x: data.x + options.x + data.width / 2 + alignAttr.x,
                        y: data.y + options.y + {
                            top: 0,
                            middle: .5,
                            bottom: 1
                        }[options.verticalAlign] * data.height
                    };
                    negRotation(alignAttr);
                    dataLabel[isNew ? "attr" : "animate"](alignAttr).attr({
                        align: align
                    });
                    /** @type {number} */
                    negRotation = (rotation + 720) % 360;
                    /** @type {boolean} */
                    negRotation = 180 < negRotation && 360 > negRotation;
                    if ("left" === align) {
                        alignAttr.y -= negRotation ? bBox.height : 0;
                    } else {
                        if ("center" === align) {
                            alignAttr.x -= bBox.width / 2;
                            alignAttr.y -= bBox.height / 2;
                        } else {
                            if ("right" === align) {
                                alignAttr.x -= bBox.width;
                                alignAttr.y -= negRotation ? 0 : bBox.height;
                            }
                        }
                    }
                    /** @type {boolean} */
                    dataLabel.placed = true;
                    dataLabel.alignAttr = alignAttr;
                } else {
                    negRotation(data);
                    dataLabel.align(options, null, data);
                    alignAttr = dataLabel.alignAttr;
                }
                if (emailCaseToDelete && 0 <= data.height) {
                    this.justifyDataLabel(dataLabel, options, alignAttr, bBox, data, isNew);
                } else {
                    if (pick(options.crop, true)) {
                        visible = chart.isInsidePlot(alignAttr.x, alignAttr.y) && chart.isInsidePlot(alignAttr.x + bBox.width, alignAttr.y + bBox.height);
                    }
                }
                if (options.shape && !rotation) {
                    dataLabel[isNew ? "attr" : "animate"]({
                        anchorX: inverted ? chart.plotWidth - point.plotY : point.plotX,
                        anchorY: inverted ? chart.plotHeight - point.plotX : point.plotY
                    });
                }
            }
            if (isNew && emailCase) {
                /** @type {boolean} */
                dataLabel.placed = false;
            }
            if (!(visible || emailCase && !emailCaseToDelete)) {
                dataLabel.hide(true);
                /** @type {boolean} */
                dataLabel.placed = false;
            }
        };
        /**
         * @param {number} h
         * @param {!Object} d
         * @param {boolean} event
         * @param {?} current
         * @param {!Object} position
         * @return {undefined}
         */
        Series.prototype.setDataLabelStartPos = function (h, d, event, current, position) {
            var chart = this.chart;
            var inverted = chart.inverted;
            var pos = this.xAxis;
            var neg = pos.reversed;
            /** @type {number} */
            var y = inverted ? d.height / 2 : d.width / 2;
            /** @type {number} */
            h = (h = h.pointWidth) ? h / 2 : 0;
            pos = inverted ? position.x : neg ? -y - h : pos.width - y + h;
            position = inverted ? neg ? this.yAxis.height - y + h : -y - h : position.y;
            d.startXPos = pos;
            /** @type {!Object} */
            d.startYPos = position;
            if (current) {
                if ("hidden" === d.visibility) {
                    d.show();
                    d.attr({
                        opacity: 0
                    }).animate({
                        opacity: 1
                    });
                }
            } else {
                d.attr({
                    opacity: 1
                }).animate({
                    opacity: 0
                }, void 0, d.hide);
            }
            if (chart.hasRendered) {
                if (event) {
                    d.attr({
                        x: d.startXPos,
                        y: d.startYPos
                    });
                }
                /** @type {boolean} */
                d.placed = true;
            }
        };
        /**
         * @param {!Object} dataLabel
         * @param {!Object} options
         * @param {!Object} alignAttr
         * @param {!Object} bBox
         * @param {!Array} callback
         * @param {boolean} isNew
         * @return {?}
         */
        Series.prototype.justifyDataLabel = function (dataLabel, options, alignAttr, bBox, callback, isNew) {
            var chart = this.chart;
            var align = options.align;
            var location = options.verticalAlign;
            var padding = dataLabel.box ? 0 : dataLabel.padding || 0;
            var off = alignAttr.x + padding;
            if (0 > off) {
                if ("right" === align) {
                    /** @type {string} */
                    options.align = "left";
                    /** @type {boolean} */
                    options.inside = true;
                } else {
                    /** @type {number} */
                    options.x = -off;
                }
                /** @type {boolean} */
                var justified = true;
            }
            /** @type {number} */
            off = alignAttr.x + bBox.width - padding;
            if (off > chart.plotWidth) {
                if ("left" === align) {
                    /** @type {string} */
                    options.align = "right";
                    /** @type {boolean} */
                    options.inside = true;
                } else {
                    /** @type {number} */
                    options.x = chart.plotWidth - off;
                }
                /** @type {boolean} */
                justified = true;
            }
            off = alignAttr.y + padding;
            if (0 > off) {
                if ("bottom" === location) {
                    /** @type {string} */
                    options.verticalAlign = "top";
                    /** @type {boolean} */
                    options.inside = true;
                } else {
                    /** @type {number} */
                    options.y = -off;
                }
                /** @type {boolean} */
                justified = true;
            }
            /** @type {number} */
            off = alignAttr.y + bBox.height - padding;
            if (off > chart.plotHeight) {
                if ("top" === location) {
                    /** @type {string} */
                    options.verticalAlign = "bottom";
                    /** @type {boolean} */
                    options.inside = true;
                } else {
                    /** @type {number} */
                    options.y = chart.plotHeight - off;
                }
                /** @type {boolean} */
                justified = true;
            }
            if (justified) {
                /** @type {boolean} */
                dataLabel.placed = !isNew;
                dataLabel.align(options, null, callback);
            }
            return justified;
        };
        if (seriesTypes.pie) {
            seriesTypes.pie.prototype.dataLabelPositioners = {
                radialDistributionY: function (event) {
                    return event.top + event.distributeBox.pos;
                },
                radialDistributionX: function (series, point, y, maxWidth) {
                    return series.getX(y < point.top + 2 || y > point.bottom - 2 ? maxWidth : y, point.half, point);
                },
                justify: function (point, radius, p) {
                    return p[0] + (point.half ? -1 : 1) * (radius + point.labelDistance);
                },
                alignToPlotEdges: function (y2, x, y, x2) {
                    y2 = y2.getBBox().width;
                    return x ? y2 + x2 : y - y2 - x2;
                },
                alignToConnectors: function (text, y, x1, x2) {
                    /** @type {number} */
                    var x = 0;
                    var minx;
                    text.forEach(function (point) {
                        minx = point.dataLabel.getBBox().width;
                        if (minx > x) {
                            x = minx;
                        }
                    });
                    return y ? x + x2 : x1 - x - x2;
                }
            };
            /**
             * @return {undefined}
             */
            seriesTypes.pie.prototype.drawDataLabels = function () {
                var series = this;
                var d = series.data;
                var data;
                var chart = series.chart;
                var options = series.options.dataLabels;
                var connectorPadding = options.connectorPadding;
                var strokeWidth;
                var plotWidth = chart.plotWidth;
                var plotHeight = chart.plotHeight;
                var xm = chart.plotLeft;
                /** @type {number} */
                var size = Math.round(chart.chartWidth / 3);
                var connector;
                var point = series.center;
                /** @type {number} */
                var radius = point[2] / 2;
                var centerY = point[1];
                var dataLabel;
                var dataLabelWidth;
                var opts;
                var height;
                /** @type {!Array} */
                var stack = [[], []];
                var x;
                var y;
                var visibility;
                var j;
                /** @type {!Array} */
                var overflow = [0, 0, 0, 0];
                var renderer = series.dataLabelPositioners;
                var style;
                if (series.visible && (options.enabled || series._hasPointLabels) && (d.forEach(function (point) {
                    if (point.dataLabel && point.visible && point.dataLabel.shortened) {
                        point.dataLabel.attr({
                            width: "auto"
                        }).css({
                            width: "auto",
                            textOverflow: "clip"
                        });
                        /** @type {boolean} */
                        point.dataLabel.shortened = false;
                    }
                }), Series.prototype.drawDataLabels.apply(series), d.forEach(function (point) {
                    if (point.dataLabel) {
                        if (point.visible) {
                            stack[point.half].push(point);
                            /** @type {null} */
                            point.dataLabel._pos = null;
                            if (!defined(options.style.width) && !defined(point.options.dataLabels && point.options.dataLabels.style && point.options.dataLabels.style.width) && point.dataLabel.getBBox().width > size) {
                                point.dataLabel.css({
                                    width: .7 * size
                                });
                                /** @type {boolean} */
                                point.dataLabel.shortened = true;
                            }
                        } else {
                            point.dataLabel = point.dataLabel.destroy();
                            if (point.dataLabels && 1 === point.dataLabels.length) {
                                delete point.dataLabels;
                            }
                        }
                    }
                }), stack.forEach(function (a, i) {
                    var startLen = a.length;
                    /** @type {!Array} */
                    var positions = [];
                    var offset_w;
                    if (startLen) {
                        series.sortByAngle(a, i - .5);
                        if (0 < series.maxLabelDistance) {
                            /** @type {number} */
                            var width = Math.max(0, centerY - radius - series.maxLabelDistance);
                            /** @type {number} */
                            var avail_width = Math.min(centerY + radius + series.maxLabelDistance, chart.plotHeight);
                            a.forEach(function (point) {
                                if (0 < point.labelDistance && point.dataLabel) {
                                    /** @type {number} */
                                    point.top = Math.max(0, centerY - radius - point.labelDistance);
                                    /** @type {number} */
                                    point.bottom = Math.min(centerY + radius + point.labelDistance, chart.plotHeight);
                                    offset_w = point.dataLabel.getBBox().height || 21;
                                    point.distributeBox = {
                                        target: point.labelPosition.natural.y - point.top + offset_w / 2,
                                        size: offset_w,
                                        rank: point.y
                                    };
                                    positions.push(point.distributeBox);
                                }
                            });
                            /** @type {number} */
                            width = avail_width + offset_w - width;
                            Highcharts.distribute(positions, width, width / 5);
                        }
                        /** @type {number} */
                        j = 0;
                        for (; j < startLen; j++) {
                            data = a[j];
                            opts = data.labelPosition;
                            dataLabel = data.dataLabel;
                            /** @type {string} */
                            visibility = false === data.visible ? "hidden" : "inherit";
                            y = width = opts.natural.y;
                            if (positions && defined(data.distributeBox)) {
                                if ("undefined" === typeof data.distributeBox.pos) {
                                    /** @type {string} */
                                    visibility = "hidden";
                                } else {
                                    height = data.distributeBox.size;
                                    y = renderer.radialDistributionY(data);
                                }
                            }
                            delete data.positionIndex;
                            if (options.justify) {
                                x = renderer.justify(data, radius, point);
                            } else {
                                switch (options.alignTo) {
                                    case "connectors":
                                        x = renderer.alignToConnectors(a, i, plotWidth, xm);
                                        break;
                                    case "plotEdges":
                                        x = renderer.alignToPlotEdges(dataLabel, i, plotWidth, xm);
                                        break;
                                    default:
                                        x = renderer.radialDistributionX(series, data, y, width);
                                }
                            }
                            dataLabel._attr = {
                                visibility: visibility,
                                align: opts.alignment
                            };
                            dataLabel._pos = {
                                x: x + options.x + ({
                                    left: connectorPadding,
                                    right: -connectorPadding
                                }[opts.alignment] || 0),
                                y: y + options.y - 10
                            };
                            opts.final.x = x;
                            opts.final.y = y;
                            if (pick(options.crop, true)) {
                                dataLabelWidth = dataLabel.getBBox().width;
                                /** @type {null} */
                                width = null;
                                if (x - dataLabelWidth < connectorPadding && 1 === i) {
                                    /** @type {number} */
                                    width = Math.round(dataLabelWidth - x + connectorPadding);
                                    /** @type {number} */
                                    overflow[3] = Math.max(width, overflow[3]);
                                } else {
                                    if (x + dataLabelWidth > plotWidth - connectorPadding && 0 === i) {
                                        /** @type {number} */
                                        width = Math.round(x + dataLabelWidth - plotWidth + connectorPadding);
                                        /** @type {number} */
                                        overflow[1] = Math.max(width, overflow[1]);
                                    }
                                }
                                if (0 > y - height / 2) {
                                    /** @type {number} */
                                    overflow[0] = Math.max(Math.round(-y + height / 2), overflow[0]);
                                } else {
                                    if (y + height / 2 > plotHeight) {
                                        /** @type {number} */
                                        overflow[2] = Math.max(Math.round(y + height / 2 - plotHeight), overflow[2]);
                                    }
                                }
                                /** @type {null} */
                                dataLabel.sideOverflow = width;
                            }
                        }
                    }
                }), 0 === arrayMax(overflow) || this.verifyDataLabelOverflow(overflow))) {
                    this.placeDataLabels();
                    this.points.forEach(function (point) {
                        style = merge(options, point.options.dataLabels);
                        if (strokeWidth = pick(style.connectorWidth, 1)) {
                            var isNew;
                            connector = point.connector;
                            if ((dataLabel = point.dataLabel) && dataLabel._pos && point.visible && 0 < point.labelDistance) {
                                visibility = dataLabel._attr.visibility;
                                if (isNew = !connector) {
                                    point.connector = connector = chart.renderer.path().addClass("highcharts-data-label-connector  highcharts-color-" + point.colorIndex + (point.className ? " " + point.className : "")).add(series.dataLabelsGroup);
                                    if (!chart.styledMode) {
                                        connector.attr({
                                            "stroke-width": strokeWidth,
                                            stroke: style.connectorColor || point.color || "#666666"
                                        });
                                    }
                                }
                                connector[isNew ? "attr" : "animate"]({
                                    d: point.getConnectorPath()
                                });
                                connector.attr("visibility", visibility);
                            } else {
                                if (connector) {
                                    point.connector = connector.destroy();
                                }
                            }
                        }
                    });
                }
            };
            /**
             * @return {undefined}
             */
            seriesTypes.pie.prototype.placeDataLabels = function () {
                this.points.forEach(function (point) {
                    var dataLabel = point.dataLabel;
                    var _pos;
                    if (dataLabel && point.visible) {
                        if (_pos = dataLabel._pos) {
                            if (dataLabel.sideOverflow) {
                                /** @type {number} */
                                dataLabel._attr.width = Math.max(dataLabel.getBBox().width - dataLabel.sideOverflow, 0);
                                dataLabel.css({
                                    width: dataLabel._attr.width + "px",
                                    textOverflow: (this.options.dataLabels.style || {}).textOverflow || "ellipsis"
                                });
                                /** @type {boolean} */
                                dataLabel.shortened = true;
                            }
                            dataLabel.attr(dataLabel._attr);
                            dataLabel[dataLabel.moved ? "animate" : "attr"](_pos);
                            /** @type {boolean} */
                            dataLabel.moved = true;
                        } else {
                            if (dataLabel) {
                                dataLabel.attr({
                                    y: -9999
                                });
                            }
                        }
                    }
                    delete point.distributeBox;
                }, this);
            };
            /** @type {!Object} */
            seriesTypes.pie.prototype.alignDataLabel = H;
            /**
             * @param {!Array} overflow
             * @return {?}
             */
            seriesTypes.pie.prototype.verifyDataLabelOverflow = function (overflow) {
                var array = this.center;
                var options = this.options;
                var region = options.center;
                var base = options.minSize || 80;
                /** @type {boolean} */
                var ret = null !== options.size;
                if (!ret) {
                    if (null !== region[0]) {
                        /** @type {number} */
                        var value = Math.max(array[2] - Math.max(overflow[1], overflow[3]), base);
                    } else {
                        /** @type {number} */
                        value = Math.max(array[2] - overflow[1] - overflow[3], base);
                        array[0] += (overflow[3] - overflow[1]) / 2;
                    }
                    if (null !== region[1]) {
                        value = map(value, base, array[2] - Math.max(overflow[0], overflow[2]));
                    } else {
                        value = map(value, base, array[2] - overflow[0] - overflow[2]);
                        array[1] += (overflow[0] - overflow[2]) / 2;
                    }
                    if (value < array[2]) {
                        /** @type {number} */
                        array[2] = value;
                        /** @type {number} */
                        array[3] = Math.min(relativeLength(options.innerSize || 0, value), value);
                        this.translate(array);
                        if (this.drawDataLabels) {
                            this.drawDataLabels();
                        }
                    } else {
                        /** @type {boolean} */
                        ret = true;
                    }
                }
                return ret;
            };
        }
        if (seriesTypes.column) {
            /**
             * @param {!Object} point
             * @param {!Object} d
             * @param {!Object} options
             * @param {!Object} alignTo
             * @param {boolean} isNew
             * @return {undefined}
             */
            seriesTypes.column.prototype.alignDataLabel = function (point, d, options, alignTo, isNew) {
                var inverted = this.chart.inverted;
                var series = point.series;
                var dlBox = point.dlBox || point.shapeArgs;
                var below = pick(point.below, point.plotY > pick(this.translatedThreshold, series.yAxis.len));
                var inside = pick(options.inside, !!this.options.stacking);
                if (dlBox) {
                    alignTo = merge(dlBox);
                    if (0 > alignTo.y) {
                        alignTo.height += alignTo.y;
                        /** @type {number} */
                        alignTo.y = 0;
                    }
                    /** @type {number} */
                    dlBox = alignTo.y + alignTo.height - series.yAxis.len;
                    if (0 < dlBox) {
                        alignTo.height -= dlBox;
                    }
                    if (inverted) {
                        alignTo = {
                            x: series.yAxis.len - alignTo.y - alignTo.height,
                            y: series.xAxis.len - alignTo.x - alignTo.width,
                            width: alignTo.height,
                            height: alignTo.width
                        };
                    }
                    if (!inside) {
                        if (inverted) {
                            alignTo.x += below ? 0 : alignTo.width;
                            /** @type {number} */
                            alignTo.width = 0;
                        } else {
                            alignTo.y += below ? alignTo.height : 0;
                            /** @type {number} */
                            alignTo.height = 0;
                        }
                    }
                }
                options.align = pick(options.align, !inverted || inside ? "center" : below ? "right" : "left");
                options.verticalAlign = pick(options.verticalAlign, inverted || inside ? "middle" : below ? "top" : "bottom");
                Series.prototype.alignDataLabel.call(this, point, d, options, alignTo, isNew);
                if (alignTo && (0 >= alignTo.height && alignTo.y === this.chart.plotHeight || 0 >= alignTo.width && 0 === alignTo.x)) {
                    d.hide(true);
                    /** @type {boolean} */
                    d.placed = false;
                }
                if (options.inside && point.contrastColor) {
                    d.css({
                        color: point.contrastColor
                    });
                }
            };
        }
    });
    set(x1, "modules/overlapping-datalabels.src.js", [x1["parts/Globals.js"], x1["parts/Utilities.js"]], function (Highcharts, exports) {
        var isFinite = exports.isArray;
        var niceScaleExtent = exports.objectEach;
        var pick = exports.pick;
        exports = Highcharts.Chart;
        var addEvent = Highcharts.addEvent;
        var each = Highcharts.fireEvent;
        addEvent(exports, "render", function () {
            /** @type {!Array} */
            var out = [];
            (this.labelCollectors || []).forEach(function (func) {
                out = out.concat(func());
            });
            (this.yAxis || []).forEach(function (yAxis) {
                if (yAxis.options.stackLabels && !yAxis.options.stackLabels.allowOverlap) {
                    niceScaleExtent(yAxis.stacks, function (radiusAxis) {
                        niceScaleExtent(radiusAxis, function (value) {
                            out.push(value.label);
                        });
                    });
                }
            });
            (this.series || []).forEach(function (series) {
                var dataLabelOptions = series.options.dataLabels;
                if (series.visible && (false !== dataLabelOptions.enabled || series._hasPointLabels)) {
                    series.points.forEach(function (point) {
                        if (point.visible) {
                            (isFinite(point.dataLabels) ? point.dataLabels : point.dataLabel ? [point.dataLabel] : []).forEach(function (a) {
                                var opt = a.options;
                                a.labelrank = pick(opt.labelrank, point.labelrank, point.shapeArgs && point.shapeArgs.height);
                                if (!opt.allowOverlap) {
                                    out.push(a);
                                }
                            });
                        }
                    });
                }
            });
            this.hideOverlappingLabels(out);
        });
        /**
         * @param {!Array} labels
         * @return {undefined}
         */
        exports.prototype.hideOverlappingLabels = function (labels) {
            var item = this;
            var labelsLength = labels.length;
            var renderer = item.renderer;
            var label;
            var i;
            var label2;
            /** @type {boolean} */
            var D = false;
            /**
             * @param {!Object} options
             * @return {?}
             */
            var show = function (options) {
                var gap = options.box ? 0 : options.padding || 0;
                /** @type {number} */
                var size = 0;
                if (options && (!options.alignAttr || options.placed)) {
                    var xhair = options.alignAttr || {
                        x: options.attr("x"),
                        y: options.attr("y")
                    };
                    var group = options.parentGroup;
                    if (!options.width) {
                        size = options.getBBox();
                        options.width = size.width;
                        options.height = size.height;
                        size = renderer.fontMetrics(null, options.element).h;
                    }
                    return {
                        x: xhair.x + (group.translateX || 0) + gap,
                        y: xhair.y + (group.translateY || 0) + gap - size,
                        width: options.width - 2 * gap,
                        height: options.height - 2 * gap
                    };
                }
            };
            /** @type {number} */
            i = 0;
            for (; i < labelsLength; i++) {
                if (label = labels[i]) {
                    label.oldOpacity = label.opacity;
                    /** @type {number} */
                    label.newOpacity = 1;
                    label.absoluteBox = show(label);
                }
            }
            labels.sort(function (a, b) {
                return (b.labelrank || 0) - (a.labelrank || 0);
            });
            /** @type {number} */
            i = 0;
            for (; i < labelsLength; i++) {
                var b = (show = labels[i]) && show.absoluteBox;
                /** @type {number} */
                label = i + 1;
                for (; label < labelsLength; ++label) {
                    var a = (label2 = labels[label]) && label2.absoluteBox;
                    if (!(!b || !a || show === label2 || 0 === show.newOpacity || 0 === label2.newOpacity || a.x > b.x + b.width || a.x + a.width < b.x || a.y > b.y + b.height || a.y + a.height < b.y)) {
                        /** @type {number} */
                        (show.labelrank < label2.labelrank ? show : label2).newOpacity = 0;
                    }
                }
            }
            labels.forEach(function (label) {
                var complete;
                if (label) {
                    var newOpacity = label.newOpacity;
                    if (label.oldOpacity !== newOpacity) {
                        if (label.alignAttr && label.placed) {
                            if (newOpacity) {
                                label.show(true);
                            } else {
                                /**
                                 * @return {undefined}
                                 */
                                complete = function () {
                                    label.hide(true);
                                    /** @type {boolean} */
                                    label.placed = false;
                                };
                            }
                            /** @type {boolean} */
                            D = true;
                            label.alignAttr.opacity = newOpacity;
                            label[label.isOld ? "animate" : "attr"](label.alignAttr, null, complete);
                            each(item, "afterHideOverlappingLabel");
                        } else {
                            label.attr({
                                opacity: newOpacity
                            });
                        }
                    }
                    /** @type {boolean} */
                    label.isOld = true;
                }
            });
            if (D) {
                each(item, "afterHideAllOverlappingLabels");
            }
        };
    });
    set(x1, "parts/Interaction.js", [x1["parts/Globals.js"], x1["parts/Utilities.js"]], function (H, _) {
        var add = _.defined;
        var extend = _.extend;
        var isArray = _.isArray;
        var isObject = _.isObject;
        var forIn = _.objectEach;
        var pick = _.pick;
        var addEvent = H.addEvent;
        _ = H.Chart;
        var createElement = H.createElement;
        var css = H.css;
        var defaultOptions = H.defaultOptions;
        var defaultPlotOptions = H.defaultPlotOptions;
        var fireEvent = H.fireEvent;
        var hasTouch = H.hasTouch;
        var Legend = H.Legend;
        var merge = H.merge;
        var Point = H.Point;
        var Series = H.Series;
        var seriesTypes = H.seriesTypes;
        var svg = H.svg;
        var TrackerMixin = H.TrackerMixin = {
            drawTrackerPoint: function () {
                var series = this;
                var chart = series.chart;
                var pointer = chart.pointer;
                /**
                 * @param {!Object} e
                 * @return {undefined}
                 */
                var onMouseOver = function (e) {
                    var target = pointer.getPointFromEvent(e);
                    if ("undefined" !== typeof target) {
                        /** @type {boolean} */
                        pointer.isDirectTouch = true;
                        target.onMouseOver(e);
                    }
                };
                var pipelets;
                series.points.forEach(function (data) {
                    pipelets = isArray(data.dataLabels) ? data.dataLabels : data.dataLabel ? [data.dataLabel] : [];
                    if (data.graphic) {
                        /** @type {!Object} */
                        data.graphic.element.point = data;
                    }
                    pipelets.forEach(function (options) {
                        if (options.div) {
                            /** @type {!Object} */
                            options.div.point = data;
                        } else {
                            /** @type {!Object} */
                            options.element.point = data;
                        }
                    });
                });
                if (!series._hasTracking) {
                    series.trackerGroups.forEach(function (name) {
                        if (series[name]) {
                            series[name].addClass("highcharts-tracker").on("mouseover", onMouseOver).on("mouseout", function (e) {
                                pointer.onTrackerMouseOut(e);
                            });
                            if (hasTouch) {
                                series[name].on("touchstart", onMouseOver);
                            }
                            if (!chart.styledMode && series.options.cursor) {
                                series[name].css(css).css({
                                    cursor: series.options.cursor
                                });
                            }
                        }
                    });
                    /** @type {boolean} */
                    series._hasTracking = true;
                }
                fireEvent(this, "afterDrawTracker");
            },
            drawTrackerGraph: function () {
                var series = this;
                var options = series.options;
                var trackByArea = options.trackByArea;
                /** @type {!Array<?>} */
                var trackerPath = [].concat(trackByArea ? series.areaPath : series.graphPath);
                /** @type {number} */
                var trackerPathLength = trackerPath.length;
                var chart = series.chart;
                var pointer = chart.pointer;
                var renderer = chart.renderer;
                var snap = chart.options.tooltip.snap;
                var tracker = series.tracker;
                var i;
                /**
                 * @return {undefined}
                 */
                var onMouseOver = function () {
                    if (chart.hoverSeries !== series) {
                        series.onMouseOver();
                    }
                };
                /** @type {string} */
                var TRACKER_FILL = "rgba(192,192,192," + (svg ? .0001 : .002) + ")";
                if (trackerPathLength && !trackByArea) {
                    /** @type {number} */
                    i = trackerPathLength + 1;
                    for (; i--;) {
                        if ("M" === trackerPath[i]) {
                            trackerPath.splice(i + 1, 0, trackerPath[i + 1] - snap, trackerPath[i + 2], "L");
                        }
                        if (i && "M" === trackerPath[i] || i === trackerPathLength) {
                            trackerPath.splice(i, 0, "L", trackerPath[i - 2] + snap, trackerPath[i - 1]);
                        }
                    }
                }
                if (tracker) {
                    tracker.attr({
                        d: trackerPath
                    });
                } else {
                    if (series.graph) {
                        series.tracker = renderer.path(trackerPath).attr({
                            visibility: series.visible ? "visible" : "hidden",
                            zIndex: 2
                        }).addClass(trackByArea ? "highcharts-tracker-area" : "highcharts-tracker-line").add(series.group);
                        if (!chart.styledMode) {
                            series.tracker.attr({
                                "stroke-linejoin": "round",
                                stroke: TRACKER_FILL,
                                fill: trackByArea ? TRACKER_FILL : "none",
                                "stroke-width": series.graph.strokeWidth() + (trackByArea ? 0 : 2 * snap)
                            });
                        }
                        [series.tracker, series.markerGroup].forEach(function (tracker) {
                            tracker.addClass("highcharts-tracker").on("mouseover", onMouseOver).on("mouseout", function (e) {
                                pointer.onTrackerMouseOut(e);
                            });
                            if (options.cursor && !chart.styledMode) {
                                tracker.css({
                                    cursor: options.cursor
                                });
                            }
                            if (hasTouch) {
                                tracker.on("touchstart", onMouseOver);
                            }
                        });
                    }
                }
                fireEvent(this, "afterDrawTracker");
            }
        };
        if (seriesTypes.column) {
            /** @type {function(): undefined} */
            seriesTypes.column.prototype.drawTracker = TrackerMixin.drawTrackerPoint;
        }
        if (seriesTypes.pie) {
            /** @type {function(): undefined} */
            seriesTypes.pie.prototype.drawTracker = TrackerMixin.drawTrackerPoint;
        }
        if (seriesTypes.scatter) {
            /** @type {function(): undefined} */
            seriesTypes.scatter.prototype.drawTracker = TrackerMixin.drawTrackerPoint;
        }
        extend(Legend.prototype, {
            setItemEvents: function (item, legendItem, useHTML) {
                var legend = this;
                var boxWrapper = legend.chart.renderer.boxWrapper;
                /** @type {boolean} */
                var isCompItem = item instanceof Point;
                /** @type {string} */
                var activeClass = "highcharts-legend-" + (isCompItem ? "point" : "series") + "-active";
                var k = legend.chart.styledMode;
                (useHTML ? legendItem : item.legendGroup).on("mouseover", function () {
                    if (item.visible) {
                        legend.allItems.forEach(function (handler) {
                            if (item !== handler) {
                                handler.setState("inactive", !isCompItem);
                            }
                        });
                    }
                    item.setState("hover");
                    if (item.visible) {
                        boxWrapper.addClass(activeClass);
                    }
                    if (!k) {
                        legendItem.css(legend.options.itemHoverStyle);
                    }
                }).on("mouseout", function () {
                    if (!legend.chart.styledMode) {
                        legendItem.css(merge(item.visible ? legend.itemStyle : legend.itemHiddenStyle));
                    }
                    legend.allItems.forEach(function (series) {
                        if (item !== series) {
                            series.setState("", !isCompItem);
                        }
                    });
                    boxWrapper.removeClass(activeClass);
                    item.setState();
                }).on("click", function (event) {
                    /**
                     * @return {undefined}
                     */
                    var update = function () {
                        if (item.setVisible) {
                            item.setVisible();
                        }
                        legend.allItems.forEach(function (self) {
                            if (item !== self) {
                                self.setState(item.visible ? "inactive" : "", !isCompItem);
                            }
                        });
                    };
                    boxWrapper.removeClass(activeClass);
                    event = {
                        browserEvent: event
                    };
                    if (item.firePointEvent) {
                        item.firePointEvent("legendItemClick", event, update);
                    } else {
                        fireEvent(item, "legendItemClick", event, update);
                    }
                });
            },
            createCheckboxForItem: function (item) {
                item.checkbox = createElement("input", {
                    type: "checkbox",
                    className: "highcharts-legend-checkbox",
                    checked: item.selected,
                    defaultChecked: item.selected
                }, this.options.itemCheckboxStyle, this.chart.container);
                addEvent(item.checkbox, "click", function (event) {
                    fireEvent(item.series || item, "checkboxClick", {
                        checked: event.target.checked,
                        item: item
                    }, function () {
                        item.select();
                    });
                });
            }
        });
        extend(_.prototype, {
            showResetZoom: function () {
                /**
                 * @return {undefined}
                 */
                function zoomOut() {
                    chart.zoomOut();
                }
                var chart = this;
                var lang = defaultOptions.lang;
                var btnOptions = chart.options.chart.resetZoomButton;
                var attr = btnOptions.theme;
                var states = attr.states;
                /** @type {(null|string)} */
                var x = "chart" === btnOptions.relativeTo || "spaceBox" === btnOptions.relativeTo ? null : "plotBox";
                fireEvent(this, "beforeShowResetZoom", null, function () {
                    chart.resetZoomButton = chart.renderer.button(lang.resetZoom, null, null, zoomOut, attr, states && states.hover).attr({
                        align: btnOptions.position.align,
                        title: lang.resetZoomTitle
                    }).addClass("highcharts-reset-zoom").add().align(btnOptions.position, false, x);
                });
                fireEvent(this, "afterShowResetZoom");
            },
            zoomOut: function () {
                fireEvent(this, "selection", {
                    resetSelection: true
                }, this.zoom);
            },
            zoom: function (event) {
                var chart = this;
                var c;
                var pointer = chart.pointer;
                /** @type {boolean} */
                var onFadeEnded = false;
                var i = chart.inverted ? pointer.mouseDownX : pointer.mouseDownY;
                if (!event || event.resetSelection) {
                    chart.axes.forEach(function (elem) {
                        c = elem.zoom();
                    });
                    /** @type {boolean} */
                    pointer.initiated = false;
                } else {
                    event.xAxis.concat(event.yAxis).forEach(function (axisData) {
                        var axis = axisData.axis;
                        var y = chart.inverted ? axis.left : axis.top;
                        var zIncLen = chart.inverted ? y + axis.width : y + axis.height;
                        var isXAxis = axis.isXAxis;
                        /** @type {boolean} */
                        var k = false;
                        if (!isXAxis && i >= y && i <= zIncLen || isXAxis || !add(i)) {
                            /** @type {boolean} */
                            k = true;
                        }
                        if (pointer[isXAxis ? "zoomX" : "zoomY"] && k) {
                            c = axis.zoom(axisData.min, axisData.max);
                            if (axis.displayBtn) {
                                /** @type {boolean} */
                                onFadeEnded = true;
                            }
                        }
                    });
                }
                var opts = chart.resetZoomButton;
                if (onFadeEnded && !opts) {
                    chart.showResetZoom();
                } else {
                    if (!onFadeEnded && isObject(opts)) {
                        chart.resetZoomButton = opts.destroy();
                    }
                }
                if (c) {
                    chart.redraw(pick(chart.options.chart.animation, event && event.animation, 100 > chart.pointCount));
                }
            },
            pan: function (e, options) {
                var chart = this;
                var hoverPoints = chart.hoverPoints;
                var arg = chart.options.chart;
                var f;
                options = "object" === typeof options ? options : {
                    enabled: options,
                    type: "x"
                };
                if (arg && arg.panning) {
                    /** @type {string} */
                    arg.panning = options;
                }
                var s = options.type;
                fireEvent(this, "pan", {
                    originalEvent: e
                }, function () {
                    if (hoverPoints) {
                        hoverPoints.forEach(function (DefaultProvider) {
                            DefaultProvider.setState();
                        });
                    }
                    /** @type {!Array} */
                    var pipelets = [1];
                    if ("xy" === s) {
                        /** @type {!Array} */
                        pipelets = [1, 0];
                    } else {
                        if ("y" === s) {
                            /** @type {!Array} */
                            pipelets = [0];
                        }
                    }
                    pipelets.forEach(function (isX) {
                        var axis = chart[isX ? "xAxis" : "yAxis"][0];
                        var spill = axis.options;
                        var horiz = axis.horiz;
                        var mousePos = e[horiz ? "chartX" : "chartY"];
                        /** @type {string} */
                        horiz = horiz ? "mouseDownX" : "mouseDownY";
                        var newMin = chart[horiz];
                        /** @type {number} */
                        var max = (axis.pointRange || 0) / 2;
                        /** @type {number} */
                        var p1 = axis.reversed && !chart.inverted || !axis.reversed && chart.inverted ? -1 : 1;
                        var extremes = axis.getExtremes();
                        var newMax = axis.toValue(newMin - mousePos, true) + max * p1;
                        /** @type {number} */
                        p1 = axis.toValue(newMin + axis.len - mousePos, true) - max * p1;
                        /** @type {boolean} */
                        var firstIsSmaller = p1 < newMax;
                        newMin = firstIsSmaller ? p1 : newMax;
                        newMax = firstIsSmaller ? newMax : p1;
                        /** @type {number} */
                        p1 = Math.min(extremes.dataMin, max ? extremes.min : axis.toValue(axis.toPixels(extremes.min) - axis.minPixelPadding));
                        /** @type {number} */
                        max = Math.max(extremes.dataMax, max ? extremes.max : axis.toValue(axis.toPixels(extremes.max) + axis.minPixelPadding));
                        if (!spill.ordinal) {
                            if (isX) {
                                /** @type {number} */
                                spill = p1 - newMin;
                                if (0 < spill) {
                                    newMax = newMax + spill;
                                    /** @type {number} */
                                    newMin = p1;
                                }
                                /** @type {number} */
                                spill = newMax - max;
                                if (0 < spill) {
                                    /** @type {number} */
                                    newMax = max;
                                    /** @type {number} */
                                    newMin = newMin - spill;
                                }
                            }
                            if (axis.series.length && newMin !== extremes.min && newMax !== extremes.max && isX || axis.panningState && newMin >= axis.panningState.startMin && newMax <= axis.panningState.startMax) {
                                axis.setExtremes(newMin, newMax, false, false, {
                                    trigger: "pan"
                                });
                                /** @type {boolean} */
                                f = true;
                            }
                            chart[horiz] = mousePos;
                        }
                    });
                    if (f) {
                        chart.redraw(false);
                    }
                    css(chart.container, {
                        cursor: "move"
                    });
                });
            }
        });
        extend(Point.prototype, {
            select: function (selected, accumulate) {
                var point = this;
                var series = point.series;
                var chart = series.chart;
                this.selectedStaging = selected = pick(selected, !point.selected);
                point.firePointEvent(selected ? "select" : "unselect", {
                    accumulate: accumulate
                }, function () {
                    point.selected = point.options.selected = selected;
                    series.options.data[series.data.indexOf(point)] = point.options;
                    point.setState(selected && "select");
                    if (!accumulate) {
                        chart.getSelectedPoints().forEach(function (loopPoint) {
                            var series = loopPoint.series;
                            if (loopPoint.selected && loopPoint !== point) {
                                /** @type {boolean} */
                                loopPoint.selected = loopPoint.options.selected = false;
                                series.options.data[series.data.indexOf(loopPoint)] = loopPoint.options;
                                loopPoint.setState(chart.hoverPoints && series.options.inactiveOtherPoints ? "inactive" : "");
                                loopPoint.firePointEvent("unselect");
                            }
                        });
                    }
                });
                delete this.selectedStaging;
            },
            onMouseOver: function (e) {
                var chart = this.series.chart;
                var pointer = chart.pointer;
                e = e ? pointer.normalize(e) : pointer.getChartCoordinatesFromPoint(this, chart.inverted);
                pointer.runPointActions(e, this);
            },
            onMouseOut: function () {
                var chart = this.series.chart;
                this.firePointEvent("mouseOut");
                if (!this.series.options.inactiveOtherPoints) {
                    (chart.hoverPoints || []).forEach(function (DefaultProvider) {
                        DefaultProvider.setState();
                    });
                }
                /** @type {null} */
                chart.hoverPoints = chart.hoverPoint = null;
            },
            importEvents: function () {
                if (!this.hasImportedEvents) {
                    var point = this;
                    var events = merge(point.series.options.point, point.options).events;
                    point.events = events;
                    forIn(events, function (fn2, play) {
                        if (H.isFunction(fn2)) {
                            addEvent(point, play, fn2);
                        }
                    });
                    /** @type {boolean} */
                    this.hasImportedEvents = true;
                }
            },
            setState: function (state, move) {
                var series = this.series;
                var type = this.state;
                var stateOptions = series.options.states[state || "normal"] || {};
                var markerOptions = defaultPlotOptions[series.type].marker && series.options.marker;
                var hasMarkers = markerOptions && false === markerOptions.enabled;
                var markerStateOptions = markerOptions && markerOptions.states && markerOptions.states[state || "normal"] || {};
                /** @type {boolean} */
                var isStr = false === markerStateOptions.enabled;
                var stateMarkerGraphic = series.stateMarkerGraphic;
                var pointMarker = this.marker || {};
                var chart = series.chart;
                var halo = series.halo;
                var data;
                var normalDisabled = markerOptions && series.markerAttribs;
                state = state || "";
                if (!(state === this.state && !move || this.selected && "select" !== state || false === stateOptions.enabled || state && (isStr || hasMarkers && false === markerStateOptions.enabled) || state && pointMarker.states && pointMarker.states[state] && false === pointMarker.states[state].enabled)) {
                    /** @type {!Object} */
                    this.state = state;
                    if (normalDisabled) {
                        data = series.markerAttribs(this, state);
                    }
                    if (this.graphic) {
                        if (type) {
                            this.graphic.removeClass("highcharts-point-" + type);
                        }
                        if (state) {
                            this.graphic.addClass("highcharts-point-" + state);
                        }
                        if (!chart.styledMode) {
                            var data = series.pointAttribs(this, state);
                            var value = pick(chart.options.chart.animation, stateOptions.animation);
                            if (series.options.inactiveOtherPoints) {
                                (this.dataLabels || []).forEach(function (a) {
                                    if (a) {
                                        a.animate({
                                            opacity: data.opacity
                                        }, value);
                                    }
                                });
                                if (this.connector) {
                                    this.connector.animate({
                                        opacity: data.opacity
                                    }, value);
                                }
                            }
                            this.graphic.animate(data, value);
                        }
                        if (data) {
                            this.graphic.animate(data, pick(chart.options.chart.animation, markerStateOptions.animation, markerOptions.animation));
                        }
                        if (stateMarkerGraphic) {
                            stateMarkerGraphic.hide();
                        }
                    } else {
                        if (state && markerStateOptions) {
                            type = pointMarker.symbol || series.symbol;
                            if (stateMarkerGraphic && stateMarkerGraphic.currentSymbol !== type) {
                                stateMarkerGraphic = stateMarkerGraphic.destroy();
                            }
                            if (data) {
                                if (stateMarkerGraphic) {
                                    stateMarkerGraphic[move ? "animate" : "attr"]({
                                        x: data.x,
                                        y: data.y
                                    });
                                } else {
                                    if (type) {
                                        series.stateMarkerGraphic = stateMarkerGraphic = chart.renderer.symbol(type, data.x, data.y, data.width, data.height).add(series.markerGroup);
                                        stateMarkerGraphic.currentSymbol = type;
                                    }
                                }
                            }
                            if (!chart.styledMode && stateMarkerGraphic) {
                                stateMarkerGraphic.attr(series.pointAttribs(this, state));
                            }
                        }
                        if (stateMarkerGraphic) {
                            stateMarkerGraphic[state && this.isInside ? "show" : "hide"]();
                            stateMarkerGraphic.element.point = this;
                        }
                    }
                    state = stateOptions.halo;
                    stateOptions = (stateMarkerGraphic = this.graphic || stateMarkerGraphic) && stateMarkerGraphic.visibility || "inherit";
                    if (state && state.size && stateMarkerGraphic && "hidden" !== stateOptions && !this.isCluster) {
                        if (!halo) {
                            series.halo = halo = chart.renderer.path().add(stateMarkerGraphic.parentGroup);
                        }
                        halo.show()[move ? "animate" : "attr"]({
                            d: this.haloPath(state.size)
                        });
                        halo.attr({
                            "class": "highcharts-halo highcharts-color-" + pick(this.colorIndex, series.colorIndex) + (this.className ? " " + this.className : ""),
                            visibility: stateOptions,
                            zIndex: -1
                        });
                        halo.point = this;
                        if (!chart.styledMode) {
                            halo.attr(extend({
                                fill: this.color || series.color,
                                "fill-opacity": state.opacity
                            }, state.attributes));
                        }
                    } else {
                        if (halo && halo.point && halo.point.haloPath) {
                            halo.animate({
                                d: halo.point.haloPath(0)
                            }, null, halo.hide);
                        }
                    }
                    fireEvent(this, "afterSetState");
                }
            },
            haloPath: function (key) {
                return this.series.chart.renderer.symbols.circle(Math.floor(this.plotX) - key, this.plotY - key, 2 * key, 2 * key);
            }
        });
        extend(Series.prototype, {
            onMouseOver: function () {
                var chart = this.chart;
                var hoverSeries = chart.hoverSeries;
                if (hoverSeries && hoverSeries !== this) {
                    hoverSeries.onMouseOut();
                }
                if (this.options.events.mouseOver) {
                    fireEvent(this, "mouseOver");
                }
                this.setState("hover");
                chart.hoverSeries = this;
            },
            onMouseOut: function () {
                var options = this.options;
                var chart = this.chart;
                var tooltip = chart.tooltip;
                var hoverPoint = chart.hoverPoint;
                /** @type {null} */
                chart.hoverSeries = null;
                if (hoverPoint) {
                    hoverPoint.onMouseOut();
                }
                if (this && options.events.mouseOut) {
                    fireEvent(this, "mouseOut");
                }
                if (!(!tooltip || this.stickyTracking || tooltip.shared && !this.noSharedTooltip)) {
                    tooltip.hide();
                }
                chart.series.forEach(function (series) {
                    series.setState("", true);
                });
            },
            setState: function (state, base) {
                var series = this;
                var options = series.options;
                var graph = series.graph;
                var delta = options.inactiveOtherPoints;
                var data = options.states;
                var lineWidth = options.lineWidth;
                var opacity = options.opacity;
                var s = pick(data[state || "normal"] && data[state || "normal"].animation, series.chart.options.chart.animation);
                /** @type {number} */
                options = 0;
                state = state || "";
                if (series.state !== state && ([series.group, series.markerGroup, series.dataLabelsGroup].forEach(function (group) {
                    if (group) {
                        if (series.state) {
                            group.removeClass("highcharts-series-" + series.state);
                        }
                        if (state) {
                            group.addClass("highcharts-series-" + state);
                        }
                    }
                }), series.state = state, !series.chart.styledMode)) {
                    if (data[state] && false === data[state].enabled) {
                        return;
                    }
                    if (state) {
                        lineWidth = data[state].lineWidth || lineWidth + (data[state].lineWidthPlus || 0);
                        opacity = pick(data[state].opacity, opacity);
                    }
                    if (graph && !graph.dashstyle) {
                        data = {
                            "stroke-width": lineWidth
                        };
                        graph.animate(data, s);
                        for (; series["zone-graph-" + options];) {
                            series["zone-graph-" + options].attr(data);
                            /** @type {number} */
                            options = options + 1;
                        }
                    }
                    if (!delta) {
                        [series.group, series.markerGroup, series.dataLabelsGroup, series.labelBySeries].forEach(function (a) {
                            if (a) {
                                a.animate({
                                    opacity: opacity
                                }, s);
                            }
                        });
                    }
                }
                if (base && delta && series.points) {
                    series.setAllPointsToState(state);
                }
            },
            setAllPointsToState: function (state) {
                this.points.forEach(function (aComponent) {
                    if (aComponent.setState) {
                        aComponent.setState(state);
                    }
                });
            },
            setVisible: function (vis, redraw) {
                var series = this;
                var chart = series.chart;
                var legendItem = series.legendItem;
                var ignoreHiddenSeries = chart.options.chart.ignoreHiddenSeries;
                var oldVisibility = series.visible;
                /** @type {string} */
                var type = (series.visible = vis = series.options.visible = series.userOptions.visible = "undefined" === typeof vis ? !oldVisibility : vis) ? "show" : "hide";
                ["group", "dataLabelsGroup", "markerGroup", "tracker", "tt"].forEach(function (name) {
                    if (series[name]) {
                        series[name][type]();
                    }
                });
                if (chart.hoverSeries === series || (chart.hoverPoint && chart.hoverPoint.series) === series) {
                    series.onMouseOut();
                }
                if (legendItem) {
                    chart.legend.colorizeItem(series, vis);
                }
                /** @type {boolean} */
                series.isDirty = true;
                if (series.options.stacking) {
                    chart.series.forEach(function (otherSeries) {
                        if (otherSeries.options.stacking && otherSeries.visible) {
                            /** @type {boolean} */
                            otherSeries.isDirty = true;
                        }
                    });
                }
                series.linkedSeries.forEach(function (otherSeries) {
                    otherSeries.setVisible(vis, false);
                });
                if (ignoreHiddenSeries) {
                    /** @type {boolean} */
                    chart.isDirtyBox = true;
                }
                fireEvent(series, type);
                if (false !== redraw) {
                    chart.redraw();
                }
            },
            show: function () {
                this.setVisible(true);
            },
            hide: function () {
                this.setVisible(false);
            },
            select: function (value) {
                this.selected = value = this.options.selected = "undefined" === typeof value ? !this.selected : value;
                if (this.checkbox) {
                    /** @type {boolean} */
                    this.checkbox.checked = value;
                }
                fireEvent(this, value ? "select" : "unselect");
            },
            drawTracker: TrackerMixin.drawTrackerGraph
        });
    });
    set(x1, "parts/Responsive.js", [x1["parts/Globals.js"], x1["parts/Utilities.js"]], function (parent, H) {
        var isArray = H.isArray;
        var isObject = H.isObject;
        var objectEach = H.objectEach;
        var pick = H.pick;
        var splat = H.splat;
        H = parent.Chart;
        /**
         * @param {boolean} key
         * @param {?} callback
         * @return {undefined}
         */
        H.prototype.setResponsive = function (key, callback) {
            var options = this.options.responsive;
            /** @type {!Array} */
            var ruleIds = [];
            var currentResponsive = this.currentResponsive;
            if (!callback && options && options.rules) {
                options.rules.forEach(function (rule) {
                    if ("undefined" === typeof rule._id) {
                        rule._id = parent.uniqueKey();
                    }
                    this.matchResponsiveRule(rule, ruleIds);
                }, this);
            }
            callback = parent.merge.apply(0, ruleIds.map(function (idCredentialEdited) {
                return parent.find(options.rules, function (item) {
                    return item._id === idCredentialEdited;
                }).chartOptions;
            }));
            /** @type {boolean} */
            callback.isResponsiveOptions = true;
            /** @type {(string|undefined)} */
            ruleIds = ruleIds.toString() || void 0;
            if (ruleIds !== (currentResponsive && currentResponsive.ruleIds)) {
                if (currentResponsive) {
                    this.update(currentResponsive.undoOptions, key, true);
                }
                if (ruleIds) {
                    currentResponsive = this.currentOptions(callback);
                    /** @type {boolean} */
                    currentResponsive.isResponsiveOptions = true;
                    this.currentResponsive = {
                        ruleIds: ruleIds,
                        mergedOptions: callback,
                        undoOptions: currentResponsive
                    };
                    this.update(callback, key, true);
                } else {
                    this.currentResponsive = void 0;
                }
            }
        };
        /**
         * @param {!Object} rule
         * @param {!Array} matches
         * @return {undefined}
         */
        H.prototype.matchResponsiveRule = function (rule, matches) {
            var current = rule.condition;
            if ((current.callback || function () {
                return this.chartWidth <= pick(current.maxWidth, Number.MAX_VALUE) && this.chartHeight <= pick(current.maxHeight, Number.MAX_VALUE) && this.chartWidth >= pick(current.minWidth, 0) && this.chartHeight >= pick(current.minHeight, 0);
            }).call(this)) {
                matches.push(rule._id);
            }
        };
        /**
         * @param {!Array} options
         * @return {?}
         */
        H.prototype.currentOptions = function (options) {
            /**
             * @param {!Object} options
             * @param {!NodeList} data
             * @param {!NodeList} ret
             * @param {number} depth
             * @return {undefined}
             */
            function getCurrent(options, data, ret, depth) {
                var i;
                objectEach(options, function (val, name) {
                    if (!depth && -1 < LocaTable.collectionsWithUpdate.indexOf(name)) {
                        val = splat(val);
                        /** @type {!Array} */
                        ret[name] = [];
                        /** @type {number} */
                        i = 0;
                        for (; i < val.length; i++) {
                            if (data[name][i]) {
                                ret[name][i] = {};
                                getCurrent(val[i], data[name][i], ret[name][i], depth + 1);
                            }
                        }
                    } else {
                        if (isObject(val)) {
                            /** @type {(Array|{})} */
                            ret[name] = isArray(val) ? [] : {};
                            getCurrent(val, data[name] || {}, ret[name], depth + 1);
                        } else {
                            ret[name] = "undefined" === typeof data[name] ? null : data[name];
                        }
                    }
                });
            }
            var LocaTable = this;
            var ret = {};
            getCurrent(options, this.options, ret, 0);
            return ret;
        };
    });
    set(x1, "masters/highcharts.src.js", [x1["parts/Globals.js"], x1["parts/Utilities.js"]], function (childCompute, H) {
        var extend = H.extend;
        extend(childCompute, {
            animObject: H.animObject,
            arrayMax: H.arrayMax,
            arrayMin: H.arrayMin,
            attr: H.attr,
            correctFloat: H.correctFloat,
            defined: H.defined,
            destroyObjectProperties: H.destroyObjectProperties,
            discardElement: H.discardElement,
            erase: H.erase,
            extend: H.extend,
            extendClass: H.extendClass,
            isArray: H.isArray,
            isClass: H.isClass,
            isDOMElement: H.isDOMElement,
            isNumber: H.isNumber,
            isObject: H.isObject,
            isString: H.isString,
            numberFormat: H.numberFormat,
            objectEach: H.objectEach,
            offset: H.offset,
            pad: H.pad,
            pick: H.pick,
            pInt: H.pInt,
            relativeLength: H.relativeLength,
            setAnimation: H.setAnimation,
            splat: H.splat,
            syncTimeout: H.syncTimeout,
            wrap: H.wrap
        });
        return childCompute;
    });
    x1["masters/highcharts.src.js"]._modules = x1;
    return x1["masters/highcharts.src.js"];
});
